var ve=Object.defineProperty;var ye=(c,s,i)=>s in c?ve(c,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):c[s]=i;var F=(c,s,i)=>(ye(c,typeof s!="symbol"?s+"":s,i),i);(function(){const s=document.createElement("link").relList;if(s&&s.supports&&s.supports("modulepreload"))return;for(const u of document.querySelectorAll('link[rel="modulepreload"]'))a(u);new MutationObserver(u=>{for(const l of u)if(l.type==="childList")for(const d of l.addedNodes)d.tagName==="LINK"&&d.rel==="modulepreload"&&a(d)}).observe(document,{childList:!0,subtree:!0});function i(u){const l={};return u.integrity&&(l.integrity=u.integrity),u.referrerPolicy&&(l.referrerPolicy=u.referrerPolicy),u.crossOrigin==="use-credentials"?l.credentials="include":u.crossOrigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function a(u){if(u.ep)return;u.ep=!0;const l=i(u);fetch(u.href,l)}})();const styles="";var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(c){return c&&c.__esModule&&Object.prototype.hasOwnProperty.call(c,"default")?c.default:c}function getAugmentedNamespace(c){if(c.__esModule)return c;var s=c.default;if(typeof s=="function"){var i=function a(){if(this instanceof a){var u=[null];u.push.apply(u,arguments);var l=Function.bind.apply(s,u);return new l}return s.apply(this,arguments)};i.prototype=s.prototype}else i={};return Object.defineProperty(i,"__esModule",{value:!0}),Object.keys(c).forEach(function(a){var u=Object.getOwnPropertyDescriptor(c,a);Object.defineProperty(i,a,u.get?u:{enumerable:!0,get:function(){return c[a]}})}),i}var stats_min={exports:{}};(function(c,s){(function(i,a){c.exports=a()})(commonjsGlobal,function(){var i=function(){function a(v){return d.appendChild(v.dom),v}function u(v){for(var y=0;y<d.children.length;y++)d.children[y].style.display=y===v?"block":"none";l=v}var l=0,d=document.createElement("div");d.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",d.addEventListener("click",function(v){v.preventDefault(),u(++l%d.children.length)},!1);var h=(performance||Date).now(),f=h,p=0,g=a(new i.Panel("FPS","#0ff","#002")),m=a(new i.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var _=a(new i.Panel("MB","#f08","#201"));return u(0),{REVISION:16,dom:d,addPanel:a,showPanel:u,begin:function(){h=(performance||Date).now()},end:function(){p++;var v=(performance||Date).now();if(m.update(v-h,200),v>f+1e3&&(g.update(1e3*p/(v-f),100),f=v,p=0,_)){var y=performance.memory;_.update(y.usedJSHeapSize/1048576,y.jsHeapSizeLimit/1048576)}return v},update:function(){h=this.end()},domElement:d,setMode:u}};return i.Panel=function(a,u,l){var d=1/0,h=0,f=Math.round,p=f(window.devicePixelRatio||1),g=80*p,m=48*p,_=3*p,v=2*p,y=3*p,A=15*p,T=74*p,x=30*p,O=document.createElement("canvas");O.width=g,O.height=m,O.style.cssText="width:80px;height:48px";var E=O.getContext("2d");return E.font="bold "+9*p+"px Helvetica,Arial,sans-serif",E.textBaseline="top",E.fillStyle=l,E.fillRect(0,0,g,m),E.fillStyle=u,E.fillText(a,_,v),E.fillRect(y,A,T,x),E.fillStyle=l,E.globalAlpha=.9,E.fillRect(y,A,T,x),{dom:O,update:function(b,N){d=Math.min(d,b),h=Math.max(h,b),E.fillStyle=l,E.globalAlpha=1,E.fillRect(0,0,g,A),E.fillStyle=u,E.fillText(f(b)+" "+a+" ("+f(d)+"-"+f(h)+")",_,v),E.drawImage(O,y+p,A,T-p,x,y,A,T-p,x),E.fillRect(y+T-p,A,p,x),E.fillStyle=l,E.globalAlpha=.9,E.fillRect(y+T-p,A,p,f((1-b/N)*x))}}},i})})(stats_min);var stats_minExports=stats_min.exports;const Stats=getDefaultExportFromCjs(stats_minExports);class Renderer{constructor(s,i,a){F(this,"running");F(this,"context");F(this,"device");F(this,"presentationFormat");F(this,"depthTexture",null);this.device=s,this.context=i,this.presentationFormat=a,this.running=!0}static async init(s){const i=await navigator.gpu.requestAdapter();if(!i)throw new Error("Unable to acquire GPU adapter, is WebGPU enabled?");const a=await i.requestDevice(),u=s.getContext("webgpu"),l=navigator.gpu.getPreferredCanvasFormat();return new Renderer(a,u,l)}configure(s,i){this.context.configure({device:this.device,format:this.presentationFormat,alphaMode:"opaque"}),this.depthTexture=this.device.createTexture({size:{width:s,height:i},format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT})}render(s){const i=this.device.createCommandEncoder(),u={colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:{r:75/255,g:0/255,b:130/255,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},l=i.beginRenderPass(u);s(l),l.end(),this.device.queue.submit([i.finish()])}}function WorkerWrapper(){return new Worker("/assets/contouring.worker-64dc21cc.js")}var EPSILON$1=1e-6,ARRAY_TYPE=typeof Float32Array<"u"?Float32Array:Array,degree=Math.PI/180;function toRadian(c){return c*degree}Math.hypot||(Math.hypot=function(){for(var c=0,s=arguments.length;s--;)c+=arguments[s]*arguments[s];return Math.sqrt(c)});function create$4(){var c=new ARRAY_TYPE(9);return ARRAY_TYPE!=Float32Array&&(c[1]=0,c[2]=0,c[3]=0,c[5]=0,c[6]=0,c[7]=0),c[0]=1,c[4]=1,c[8]=1,c}function create$3(){var c=new ARRAY_TYPE(16);return ARRAY_TYPE!=Float32Array&&(c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[11]=0,c[12]=0,c[13]=0,c[14]=0),c[0]=1,c[5]=1,c[10]=1,c[15]=1,c}function copy$1(c,s){return c[0]=s[0],c[1]=s[1],c[2]=s[2],c[3]=s[3],c[4]=s[4],c[5]=s[5],c[6]=s[6],c[7]=s[7],c[8]=s[8],c[9]=s[9],c[10]=s[10],c[11]=s[11],c[12]=s[12],c[13]=s[13],c[14]=s[14],c[15]=s[15],c}function identity(c){return c[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,c}function invert(c,s){var i=s[0],a=s[1],u=s[2],l=s[3],d=s[4],h=s[5],f=s[6],p=s[7],g=s[8],m=s[9],_=s[10],v=s[11],y=s[12],A=s[13],T=s[14],x=s[15],O=i*h-a*d,E=i*f-u*d,b=i*p-l*d,N=a*f-u*h,C=a*p-l*h,w=u*p-l*f,S=g*A-m*y,M=g*T-_*y,P=g*x-v*y,I=m*T-_*A,k=m*x-v*A,D=_*x-v*T,R=O*D-E*k+b*I+N*P-C*M+w*S;return R?(R=1/R,c[0]=(h*D-f*k+p*I)*R,c[1]=(u*k-a*D-l*I)*R,c[2]=(A*w-T*C+x*N)*R,c[3]=(_*C-m*w-v*N)*R,c[4]=(f*P-d*D-p*M)*R,c[5]=(i*D-u*P+l*M)*R,c[6]=(T*b-y*w-x*E)*R,c[7]=(g*w-_*b+v*E)*R,c[8]=(d*k-h*P+p*S)*R,c[9]=(a*P-i*k-l*S)*R,c[10]=(y*C-A*b+x*O)*R,c[11]=(m*b-g*C-v*O)*R,c[12]=(h*M-d*I-f*S)*R,c[13]=(i*I-a*M+u*S)*R,c[14]=(A*E-y*N-T*O)*R,c[15]=(g*N-m*E+_*O)*R,c):null}function multiply$2(c,s,i){var a=s[0],u=s[1],l=s[2],d=s[3],h=s[4],f=s[5],p=s[6],g=s[7],m=s[8],_=s[9],v=s[10],y=s[11],A=s[12],T=s[13],x=s[14],O=s[15],E=i[0],b=i[1],N=i[2],C=i[3];return c[0]=E*a+b*h+N*m+C*A,c[1]=E*u+b*f+N*_+C*T,c[2]=E*l+b*p+N*v+C*x,c[3]=E*d+b*g+N*y+C*O,E=i[4],b=i[5],N=i[6],C=i[7],c[4]=E*a+b*h+N*m+C*A,c[5]=E*u+b*f+N*_+C*T,c[6]=E*l+b*p+N*v+C*x,c[7]=E*d+b*g+N*y+C*O,E=i[8],b=i[9],N=i[10],C=i[11],c[8]=E*a+b*h+N*m+C*A,c[9]=E*u+b*f+N*_+C*T,c[10]=E*l+b*p+N*v+C*x,c[11]=E*d+b*g+N*y+C*O,E=i[12],b=i[13],N=i[14],C=i[15],c[12]=E*a+b*h+N*m+C*A,c[13]=E*u+b*f+N*_+C*T,c[14]=E*l+b*p+N*v+C*x,c[15]=E*d+b*g+N*y+C*O,c}function translate(c,s,i){var a=i[0],u=i[1],l=i[2],d,h,f,p,g,m,_,v,y,A,T,x;return s===c?(c[12]=s[0]*a+s[4]*u+s[8]*l+s[12],c[13]=s[1]*a+s[5]*u+s[9]*l+s[13],c[14]=s[2]*a+s[6]*u+s[10]*l+s[14],c[15]=s[3]*a+s[7]*u+s[11]*l+s[15]):(d=s[0],h=s[1],f=s[2],p=s[3],g=s[4],m=s[5],_=s[6],v=s[7],y=s[8],A=s[9],T=s[10],x=s[11],c[0]=d,c[1]=h,c[2]=f,c[3]=p,c[4]=g,c[5]=m,c[6]=_,c[7]=v,c[8]=y,c[9]=A,c[10]=T,c[11]=x,c[12]=d*a+g*u+y*l+s[12],c[13]=h*a+m*u+A*l+s[13],c[14]=f*a+_*u+T*l+s[14],c[15]=p*a+v*u+x*l+s[15]),c}function scale$1(c,s,i){var a=i[0],u=i[1],l=i[2];return c[0]=s[0]*a,c[1]=s[1]*a,c[2]=s[2]*a,c[3]=s[3]*a,c[4]=s[4]*u,c[5]=s[5]*u,c[6]=s[6]*u,c[7]=s[7]*u,c[8]=s[8]*l,c[9]=s[9]*l,c[10]=s[10]*l,c[11]=s[11]*l,c[12]=s[12],c[13]=s[13],c[14]=s[14],c[15]=s[15],c}function rotateX(c,s,i){var a=Math.sin(i),u=Math.cos(i),l=s[4],d=s[5],h=s[6],f=s[7],p=s[8],g=s[9],m=s[10],_=s[11];return s!==c&&(c[0]=s[0],c[1]=s[1],c[2]=s[2],c[3]=s[3],c[12]=s[12],c[13]=s[13],c[14]=s[14],c[15]=s[15]),c[4]=l*u+p*a,c[5]=d*u+g*a,c[6]=h*u+m*a,c[7]=f*u+_*a,c[8]=p*u-l*a,c[9]=g*u-d*a,c[10]=m*u-h*a,c[11]=_*u-f*a,c}function fromQuat(c,s){var i=s[0],a=s[1],u=s[2],l=s[3],d=i+i,h=a+a,f=u+u,p=i*d,g=a*d,m=a*h,_=u*d,v=u*h,y=u*f,A=l*d,T=l*h,x=l*f;return c[0]=1-m-y,c[1]=g+x,c[2]=_-T,c[3]=0,c[4]=g-x,c[5]=1-p-y,c[6]=v+A,c[7]=0,c[8]=_+T,c[9]=v-A,c[10]=1-p-m,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,c}function perspectiveNO(c,s,i,a,u){var l=1/Math.tan(s/2),d;return c[0]=l/i,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=l,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[11]=-1,c[12]=0,c[13]=0,c[15]=0,u!=null&&u!==1/0?(d=1/(a-u),c[10]=(u+a)*d,c[14]=2*u*a*d):(c[10]=-1,c[14]=-2*a),c}var perspective=perspectiveNO,mul=multiply$2;function create$2(){var c=new ARRAY_TYPE(3);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0),c}function length(c){var s=c[0],i=c[1],a=c[2];return Math.hypot(s,i,a)}function fromValues$1(c,s,i){var a=new ARRAY_TYPE(3);return a[0]=c,a[1]=s,a[2]=i,a}function copy(c,s){return c[0]=s[0],c[1]=s[1],c[2]=s[2],c}function set(c,s,i,a){return c[0]=s,c[1]=i,c[2]=a,c}function add(c,s,i){return c[0]=s[0]+i[0],c[1]=s[1]+i[1],c[2]=s[2]+i[2],c}function subtract(c,s,i){return c[0]=s[0]-i[0],c[1]=s[1]-i[1],c[2]=s[2]-i[2],c}function scale(c,s,i){return c[0]=s[0]*i,c[1]=s[1]*i,c[2]=s[2]*i,c}function normalize$2(c,s){var i=s[0],a=s[1],u=s[2],l=i*i+a*a+u*u;return l>0&&(l=1/Math.sqrt(l)),c[0]=s[0]*l,c[1]=s[1]*l,c[2]=s[2]*l,c}function dot(c,s){return c[0]*s[0]+c[1]*s[1]+c[2]*s[2]}function cross(c,s,i){var a=s[0],u=s[1],l=s[2],d=i[0],h=i[1],f=i[2];return c[0]=u*f-l*h,c[1]=l*d-a*f,c[2]=a*h-u*d,c}function zero(c){return c[0]=0,c[1]=0,c[2]=0,c}var sub=subtract,len=length;(function(){var c=create$2();return function(s,i,a,u,l,d){var h,f;for(i||(i=3),a||(a=0),u?f=Math.min(u*i+a,s.length):f=s.length,h=a;h<f;h+=i)c[0]=s[h],c[1]=s[h+1],c[2]=s[h+2],l(c,c,d),s[h]=c[0],s[h+1]=c[1],s[h+2]=c[2];return s}})();function create$1(){var c=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0,c[3]=0),c}function fromValues(c,s,i,a){var u=new ARRAY_TYPE(4);return u[0]=c,u[1]=s,u[2]=i,u[3]=a,u}function normalize$1(c,s){var i=s[0],a=s[1],u=s[2],l=s[3],d=i*i+a*a+u*u+l*l;return d>0&&(d=1/Math.sqrt(d)),c[0]=i*d,c[1]=a*d,c[2]=u*d,c[3]=l*d,c}(function(){var c=create$1();return function(s,i,a,u,l,d){var h,f;for(i||(i=4),a||(a=0),u?f=Math.min(u*i+a,s.length):f=s.length,h=a;h<f;h+=i)c[0]=s[h],c[1]=s[h+1],c[2]=s[h+2],c[3]=s[h+3],l(c,c,d),s[h]=c[0],s[h+1]=c[1],s[h+2]=c[2],s[h+3]=c[3];return s}})();function create(){var c=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0),c[3]=1,c}function setAxisAngle(c,s,i){i=i*.5;var a=Math.sin(i);return c[0]=a*s[0],c[1]=a*s[1],c[2]=a*s[2],c[3]=Math.cos(i),c}function multiply$1(c,s,i){var a=s[0],u=s[1],l=s[2],d=s[3],h=i[0],f=i[1],p=i[2],g=i[3];return c[0]=a*g+d*h+u*p-l*f,c[1]=u*g+d*f+l*h-a*p,c[2]=l*g+d*p+a*f-u*h,c[3]=d*g-a*h-u*f-l*p,c}function rotateY(c,s,i){i*=.5;var a=s[0],u=s[1],l=s[2],d=s[3],h=Math.sin(i),f=Math.cos(i);return c[0]=a*f-l*h,c[1]=u*f+d*h,c[2]=l*f+a*h,c[3]=d*f-u*h,c}function rotateZ(c,s,i){i*=.5;var a=s[0],u=s[1],l=s[2],d=s[3],h=Math.sin(i),f=Math.cos(i);return c[0]=a*f+u*h,c[1]=u*f-a*h,c[2]=l*f+d*h,c[3]=d*f-l*h,c}function slerp(c,s,i,a){var u=s[0],l=s[1],d=s[2],h=s[3],f=i[0],p=i[1],g=i[2],m=i[3],_,v,y,A,T;return v=u*f+l*p+d*g+h*m,v<0&&(v=-v,f=-f,p=-p,g=-g,m=-m),1-v>EPSILON$1?(_=Math.acos(v),y=Math.sin(_),A=Math.sin((1-a)*_)/y,T=Math.sin(a*_)/y):(A=1-a,T=a),c[0]=A*u+T*f,c[1]=A*l+T*p,c[2]=A*d+T*g,c[3]=A*h+T*m,c}function fromMat3(c,s){var i=s[0]+s[4]+s[8],a;if(i>0)a=Math.sqrt(i+1),c[3]=.5*a,a=.5/a,c[0]=(s[5]-s[7])*a,c[1]=(s[6]-s[2])*a,c[2]=(s[1]-s[3])*a;else{var u=0;s[4]>s[0]&&(u=1),s[8]>s[u*3+u]&&(u=2);var l=(u+1)%3,d=(u+2)%3;a=Math.sqrt(s[u*3+u]-s[l*3+l]-s[d*3+d]+1),c[u]=.5*a,a=.5/a,c[3]=(s[l*3+d]-s[d*3+l])*a,c[l]=(s[l*3+u]+s[u*3+l])*a,c[d]=(s[d*3+u]+s[u*3+d])*a}return c}var normalize=normalize$1,rotationTo=function(){var c=create$2(),s=fromValues$1(1,0,0),i=fromValues$1(0,1,0);return function(a,u,l){var d=dot(u,l);return d<-.999999?(cross(c,s,u),len(c)<1e-6&&cross(c,i,u),normalize$2(c,c),setAxisAngle(a,c,Math.PI),a):d>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(cross(c,u,l),a[0]=c[0],a[1]=c[1],a[2]=c[2],a[3]=1+d,normalize(a,a))}}();(function(){var c=create(),s=create();return function(i,a,u,l,d,h){return slerp(c,a,d,h),slerp(s,u,l,h),slerp(i,c,s,2*h*(1-h)),i}})();(function(){var c=create$4();return function(s,i,a,u){return c[0]=a[0],c[3]=a[1],c[6]=a[2],c[1]=u[0],c[4]=u[1],c[7]=u[2],c[2]=-i[0],c[5]=-i[1],c[8]=-i[2],normalize(s,fromMat3(s,c))}})();const version="14.7.77",createExtendedExponentialRampToValueAutomationEvent=(c,s,i)=>({endTime:s,insertTime:i,type:"exponentialRampToValue",value:c}),createExtendedLinearRampToValueAutomationEvent=(c,s,i)=>({endTime:s,insertTime:i,type:"linearRampToValue",value:c}),createSetValueAutomationEvent=(c,s)=>({startTime:s,type:"setValue",value:c}),createSetValueCurveAutomationEvent=(c,s,i)=>({duration:i,startTime:s,type:"setValueCurve",values:c}),getTargetValueAtTime=(c,s,{startTime:i,target:a,timeConstant:u})=>a+(s-a)*Math.exp((i-c)/u),isExponentialRampToValueAutomationEvent=c=>c.type==="exponentialRampToValue",isLinearRampToValueAutomationEvent=c=>c.type==="linearRampToValue",isAnyRampToValueAutomationEvent=c=>isExponentialRampToValueAutomationEvent(c)||isLinearRampToValueAutomationEvent(c),isSetValueAutomationEvent=c=>c.type==="setValue",isSetValueCurveAutomationEvent=c=>c.type==="setValueCurve",getValueOfAutomationEventAtIndexAtTime=(c,s,i,a)=>{const u=c[s];return u===void 0?a:isAnyRampToValueAutomationEvent(u)||isSetValueAutomationEvent(u)?u.value:isSetValueCurveAutomationEvent(u)?u.values[u.values.length-1]:getTargetValueAtTime(i,getValueOfAutomationEventAtIndexAtTime(c,s-1,u.startTime,a),u)},getEndTimeAndValueOfPreviousAutomationEvent=(c,s,i,a,u)=>i===void 0?[a.insertTime,u]:isAnyRampToValueAutomationEvent(i)?[i.endTime,i.value]:isSetValueAutomationEvent(i)?[i.startTime,i.value]:isSetValueCurveAutomationEvent(i)?[i.startTime+i.duration,i.values[i.values.length-1]]:[i.startTime,getValueOfAutomationEventAtIndexAtTime(c,s-1,i.startTime,u)],isCancelAndHoldAutomationEvent=c=>c.type==="cancelAndHold",isCancelScheduledValuesAutomationEvent=c=>c.type==="cancelScheduledValues",getEventTime=c=>isCancelAndHoldAutomationEvent(c)||isCancelScheduledValuesAutomationEvent(c)?c.cancelTime:isExponentialRampToValueAutomationEvent(c)||isLinearRampToValueAutomationEvent(c)?c.endTime:c.startTime,getExponentialRampValueAtTime=(c,s,i,{endTime:a,value:u})=>i===u?u:0<i&&0<u||i<0&&u<0?i*(u/i)**((c-s)/(a-s)):0,getLinearRampValueAtTime=(c,s,i,{endTime:a,value:u})=>i+(c-s)/(a-s)*(u-i),interpolateValue=(c,s)=>{const i=Math.floor(s),a=Math.ceil(s);return i===a?c[i]:(1-(s-i))*c[i]+(1-(a-s))*c[a]},getValueCurveValueAtTime=(c,{duration:s,startTime:i,values:a})=>{const u=(c-i)/s*(a.length-1);return interpolateValue(a,u)},isSetTargetAutomationEvent=c=>c.type==="setTarget";class AutomationEventList{constructor(s){this._automationEvents=[],this._currenTime=0,this._defaultValue=s}[Symbol.iterator](){return this._automationEvents[Symbol.iterator]()}add(s){const i=getEventTime(s);if(isCancelAndHoldAutomationEvent(s)||isCancelScheduledValuesAutomationEvent(s)){const a=this._automationEvents.findIndex(l=>isCancelScheduledValuesAutomationEvent(s)&&isSetValueCurveAutomationEvent(l)?l.startTime+l.duration>=i:getEventTime(l)>=i),u=this._automationEvents[a];if(a!==-1&&(this._automationEvents=this._automationEvents.slice(0,a)),isCancelAndHoldAutomationEvent(s)){const l=this._automationEvents[this._automationEvents.length-1];if(u!==void 0&&isAnyRampToValueAutomationEvent(u)){if(isSetTargetAutomationEvent(l))throw new Error("The internal list is malformed.");const d=isSetValueCurveAutomationEvent(l)?l.startTime+l.duration:getEventTime(l),h=isSetValueCurveAutomationEvent(l)?l.values[l.values.length-1]:l.value,f=isExponentialRampToValueAutomationEvent(u)?getExponentialRampValueAtTime(i,d,h,u):getLinearRampValueAtTime(i,d,h,u),p=isExponentialRampToValueAutomationEvent(u)?createExtendedExponentialRampToValueAutomationEvent(f,i,this._currenTime):createExtendedLinearRampToValueAutomationEvent(f,i,this._currenTime);this._automationEvents.push(p)}l!==void 0&&isSetTargetAutomationEvent(l)&&this._automationEvents.push(createSetValueAutomationEvent(this.getValue(i),i)),l!==void 0&&isSetValueCurveAutomationEvent(l)&&l.startTime+l.duration>i&&(this._automationEvents[this._automationEvents.length-1]=createSetValueCurveAutomationEvent(new Float32Array([6,7]),l.startTime,i-l.startTime))}}else{const a=this._automationEvents.findIndex(d=>getEventTime(d)>i),u=a===-1?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[a-1];if(u!==void 0&&isSetValueCurveAutomationEvent(u)&&getEventTime(u)+u.duration>i)return!1;const l=isExponentialRampToValueAutomationEvent(s)?createExtendedExponentialRampToValueAutomationEvent(s.value,s.endTime,this._currenTime):isLinearRampToValueAutomationEvent(s)?createExtendedLinearRampToValueAutomationEvent(s.value,i,this._currenTime):s;if(a===-1)this._automationEvents.push(l);else{if(isSetValueCurveAutomationEvent(s)&&i+s.duration>getEventTime(this._automationEvents[a]))return!1;this._automationEvents.splice(a,0,l)}}return!0}flush(s){const i=this._automationEvents.findIndex(a=>getEventTime(a)>s);if(i>1){const a=this._automationEvents.slice(i-1),u=a[0];isSetTargetAutomationEvent(u)&&a.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents,i-2,u.startTime,this._defaultValue),u.startTime)),this._automationEvents=a}}getValue(s){if(this._automationEvents.length===0)return this._defaultValue;const i=this._automationEvents.findIndex(d=>getEventTime(d)>s),a=this._automationEvents[i],u=(i===-1?this._automationEvents.length:i)-1,l=this._automationEvents[u];if(l!==void 0&&isSetTargetAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)||a.insertTime>s))return getTargetValueAtTime(s,getValueOfAutomationEventAtIndexAtTime(this._automationEvents,u-1,l.startTime,this._defaultValue),l);if(l!==void 0&&isSetValueAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)))return l.value;if(l!==void 0&&isSetValueCurveAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)||l.startTime+l.duration>s))return s<l.startTime+l.duration?getValueCurveValueAtTime(s,l):l.values[l.values.length-1];if(l!==void 0&&isAnyRampToValueAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)))return l.value;if(a!==void 0&&isExponentialRampToValueAutomationEvent(a)){const[d,h]=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,u,l,a,this._defaultValue);return getExponentialRampValueAtTime(s,d,h,a)}if(a!==void 0&&isLinearRampToValueAutomationEvent(a)){const[d,h]=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,u,l,a,this._defaultValue);return getLinearRampValueAtTime(s,d,h,a)}return this._defaultValue}}const createCancelAndHoldAutomationEvent=c=>({cancelTime:c,type:"cancelAndHold"}),createCancelScheduledValuesAutomationEvent=c=>({cancelTime:c,type:"cancelScheduledValues"}),createExponentialRampToValueAutomationEvent=(c,s)=>({endTime:s,type:"exponentialRampToValue",value:c}),createLinearRampToValueAutomationEvent=(c,s)=>({endTime:s,type:"linearRampToValue",value:c}),createSetTargetAutomationEvent=(c,s,i)=>({startTime:s,target:c,timeConstant:i,type:"setTarget"}),createAbortError=()=>new DOMException("","AbortError"),createAddActiveInputConnectionToAudioNode=c=>(s,i,[a,u,l],d)=>{c(s[u],[i,a,l],h=>h[0]===i&&h[1]===a,d)},createAddAudioNodeConnections=c=>(s,i,a)=>{const u=[];for(let l=0;l<a.numberOfInputs;l+=1)u.push(new Set);c.set(s,{activeInputs:u,outputs:new Set,passiveInputs:new WeakMap,renderer:i})},createAddAudioParamConnections=c=>(s,i)=>{c.set(s,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:i})},ACTIVE_AUDIO_NODE_STORE=new WeakSet,AUDIO_NODE_CONNECTIONS_STORE=new WeakMap,AUDIO_NODE_STORE=new WeakMap,AUDIO_PARAM_CONNECTIONS_STORE=new WeakMap,AUDIO_PARAM_STORE=new WeakMap,CONTEXT_STORE=new WeakMap,EVENT_LISTENERS=new WeakMap,CYCLE_COUNTERS=new WeakMap,NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS=new WeakMap,NODE_TO_PROCESSOR_MAPS=new WeakMap,handler={construct(){return handler}},isConstructible=c=>{try{const s=new Proxy(c,handler);new s}catch{return!1}return!0},IMPORT_STATEMENT_REGEX=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,splitImportStatements=(c,s)=>{const i=[];let a=c.replace(/^[\s]+/,""),u=a.match(IMPORT_STATEMENT_REGEX);for(;u!==null;){const l=u[1].slice(1,-1),d=u[0].replace(/([\s]+)?;?$/,"").replace(l,new URL(l,s).toString());i.push(d),a=a.slice(u[0].length).replace(/^[\s]+/,""),u=a.match(IMPORT_STATEMENT_REGEX)}return[i.join(";"),a]},verifyParameterDescriptors=c=>{if(c!==void 0&&!Array.isArray(c))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},verifyProcessorCtor=c=>{if(!isConstructible(c))throw new TypeError("The given value for processorCtor should be a constructor.");if(c.prototype===null||typeof c.prototype!="object")throw new TypeError("The given value for processorCtor should have a prototype.")},createAddAudioWorkletModule=(c,s,i,a,u,l,d,h,f,p,g,m,_)=>{let v=0;return(y,A,T={credentials:"omit"})=>{const x=g.get(y);if(x!==void 0&&x.has(A))return Promise.resolve();const O=p.get(y);if(O!==void 0){const N=O.get(A);if(N!==void 0)return N}const E=l(y),b=E.audioWorklet===void 0?u(A).then(([N,C])=>{const[w,S]=splitImportStatements(N,C),M=`${w};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${S}
})})(window,'_AWGS')`;return i(M)}).then(()=>{const N=_._AWGS.pop();if(N===void 0)throw new SyntaxError;a(E.currentTime,E.sampleRate,()=>N(class{},void 0,(C,w)=>{if(C.trim()==="")throw s();const S=NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(E);if(S!==void 0){if(S.has(C))throw s();verifyProcessorCtor(w),verifyParameterDescriptors(w.parameterDescriptors),S.set(C,w)}else verifyProcessorCtor(w),verifyParameterDescriptors(w.parameterDescriptors),NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(E,new Map([[C,w]]))},E.sampleRate,void 0,void 0))}):Promise.all([u(A),Promise.resolve(c(m,m))]).then(([[N,C],w])=>{const S=v+1;v=S;const[M,P]=splitImportStatements(N,C),R=`${M};((AudioWorkletProcessor,registerProcessor)=>{${P}
})(${w?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${w?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${w?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${S}',class extends AudioWorkletProcessor{process(){return !1}})`,z=new Blob([R],{type:"application/javascript; charset=utf-8"}),V=URL.createObjectURL(z);return E.audioWorklet.addModule(V,T).then(()=>{if(h(E))return E;const L=d(E);return L.audioWorklet.addModule(V,T).then(()=>L)}).then(L=>{if(f===null)throw new SyntaxError;try{new f(L,`__sac${S}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(V))});return O===void 0?p.set(y,new Map([[A,b]])):O.set(A,b),b.then(()=>{const N=g.get(y);N===void 0?g.set(y,new Set([A])):N.add(A)}).finally(()=>{const N=p.get(y);N!==void 0&&N.delete(A)}),b}},getValueForKey=(c,s)=>{const i=c.get(s);if(i===void 0)throw new Error("A value with the given key could not be found.");return i},pickElementFromSet=(c,s)=>{const i=Array.from(c).filter(s);if(i.length>1)throw Error("More than one element was found.");if(i.length===0)throw Error("No element was found.");const[a]=i;return c.delete(a),a},deletePassiveInputConnectionToAudioNode=(c,s,i,a)=>{const u=getValueForKey(c,s),l=pickElementFromSet(u,d=>d[0]===i&&d[1]===a);return u.size===0&&c.delete(s),l},getEventListenersOfAudioNode=c=>getValueForKey(EVENT_LISTENERS,c),setInternalStateToActive=c=>{if(ACTIVE_AUDIO_NODE_STORE.has(c))throw new Error("The AudioNode is already stored.");ACTIVE_AUDIO_NODE_STORE.add(c),getEventListenersOfAudioNode(c).forEach(s=>s(!0))},isAudioWorkletNode=c=>"port"in c,setInternalStateToPassive=c=>{if(!ACTIVE_AUDIO_NODE_STORE.has(c))throw new Error("The AudioNode is not stored.");ACTIVE_AUDIO_NODE_STORE.delete(c),getEventListenersOfAudioNode(c).forEach(s=>s(!1))},setInternalStateToPassiveWhenNecessary=(c,s)=>{!isAudioWorkletNode(c)&&s.every(i=>i.size===0)&&setInternalStateToPassive(c)},createAddConnectionToAudioNode=(c,s,i,a,u,l,d,h,f,p,g,m,_)=>{const v=new WeakMap;return(y,A,T,x,O)=>{const{activeInputs:E,passiveInputs:b}=l(A),{outputs:N}=l(y),C=h(y),w=S=>{const M=f(A),P=f(y);if(S){const I=deletePassiveInputConnectionToAudioNode(b,y,T,x);c(E,y,I,!1),!O&&!m(y)&&i(P,M,T,x),_(A)&&setInternalStateToActive(A)}else{const I=a(E,y,T,x);s(b,x,I,!1),!O&&!m(y)&&u(P,M,T,x);const k=d(A);if(k===0)g(A)&&setInternalStateToPassiveWhenNecessary(A,E);else{const D=v.get(A);D!==void 0&&clearTimeout(D),v.set(A,setTimeout(()=>{g(A)&&setInternalStateToPassiveWhenNecessary(A,E)},k*1e3))}}};return p(N,[A,T,x],S=>S[0]===A&&S[1]===T&&S[2]===x,!0)?(C.add(w),g(y)?c(E,y,[T,x,w],!0):s(b,x,[y,T,w],!0),!0):!1}},createAddPassiveInputConnectionToAudioNode=c=>(s,i,[a,u,l],d)=>{const h=s.get(a);h===void 0?s.set(a,new Set([[u,i,l]])):c(h,[u,i,l],f=>f[0]===u&&f[1]===i,d)},createAddSilentConnection=c=>(s,i)=>{const a=c(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});i.connect(a).connect(s.destination);const u=()=>{i.removeEventListener("ended",u),i.disconnect(a),a.disconnect()};i.addEventListener("ended",u)},createAddUnrenderedAudioWorkletNode=c=>(s,i)=>{c(s).add(i)},DEFAULT_OPTIONS$j={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},createAnalyserNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=u(h),g={...DEFAULT_OPTIONS$j,...f},m=a(p,g),_=l(p)?s():null;super(h,!1,m,_),this._nativeAnalyserNode=m}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(h){this._nativeAnalyserNode.fftSize=h}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(h){const f=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=h,!(h>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=f,i()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(h){const f=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=h,!(this._nativeAnalyserNode.maxDecibels>h))throw this._nativeAnalyserNode.minDecibels=f,i()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(h){this._nativeAnalyserNode.smoothingTimeConstant=h}getByteFrequencyData(h){this._nativeAnalyserNode.getByteFrequencyData(h)}getByteTimeDomainData(h){this._nativeAnalyserNode.getByteTimeDomainData(h)}getFloatFrequencyData(h){this._nativeAnalyserNode.getFloatFrequencyData(h)}getFloatTimeDomainData(h){this._nativeAnalyserNode.getFloatTimeDomainData(h)}},isOwnedByContext=(c,s)=>c.context===s,createAnalyserNodeRendererFactory=(c,s,i)=>()=>{const a=new WeakMap,u=async(l,d)=>{let h=s(l);if(!isOwnedByContext(h,d)){const p={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,fftSize:h.fftSize,maxDecibels:h.maxDecibels,minDecibels:h.minDecibels,smoothingTimeConstant:h.smoothingTimeConstant};h=c(d,p)}return a.set(d,h),await i(l,d,h),h};return{render(l,d){const h=a.get(d);return h!==void 0?Promise.resolve(h):u(l,d)}}},testAudioBufferCopyChannelMethodsOutOfBoundsSupport=c=>{try{c.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},createIndexSizeError=()=>new DOMException("","IndexSizeError"),wrapAudioBufferGetChannelDataMethod=c=>{c.getChannelData=(s=>i=>{try{return s.call(c,i)}catch(a){throw a.code===12?createIndexSizeError():a}})(c.getChannelData)},DEFAULT_OPTIONS$i={numberOfChannels:1},createAudioBufferConstructor=(c,s,i,a,u,l,d,h)=>{let f=null;return class de{constructor(g){if(u===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:m,numberOfChannels:_,sampleRate:v}={...DEFAULT_OPTIONS$i,...g};f===null&&(f=new u(1,1,44100));const y=a!==null&&s(l,l)?new a({length:m,numberOfChannels:_,sampleRate:v}):f.createBuffer(_,m,v);if(y.numberOfChannels===0)throw i();return typeof y.copyFromChannel!="function"?(d(y),wrapAudioBufferGetChannelDataMethod(y)):s(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(y))||h(y),c.add(y),y}static[Symbol.hasInstance](g){return g!==null&&typeof g=="object"&&Object.getPrototypeOf(g)===de.prototype||c.has(g)}}},MOST_NEGATIVE_SINGLE_FLOAT=-34028234663852886e22,MOST_POSITIVE_SINGLE_FLOAT=-MOST_NEGATIVE_SINGLE_FLOAT,isActiveAudioNode=c=>ACTIVE_AUDIO_NODE_STORE.has(c),DEFAULT_OPTIONS$h={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},createAudioBufferSourceNodeConstructor=(c,s,i,a,u,l,d,h)=>class extends c{constructor(p,g){const m=l(p),_={...DEFAULT_OPTIONS$h,...g},v=u(m,_),y=d(m),A=y?s():null;super(p,!1,v,A),this._audioBufferSourceNodeRenderer=A,this._isBufferNullified=!1,this._isBufferSet=_.buffer!==null,this._nativeAudioBufferSourceNode=v,this._onended=null,this._playbackRate=i(this,y,v.playbackRate,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(p){if(this._nativeAudioBufferSourceNode.buffer=p,p!==null){if(this._isBufferSet)throw a();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(p){this._nativeAudioBufferSourceNode.loop=p}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(p){this._nativeAudioBufferSourceNode.loopEnd=p}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(p){this._nativeAudioBufferSourceNode.loopStart=p}get onended(){return this._onended}set onended(p){const g=typeof p=="function"?h(this,p):null;this._nativeAudioBufferSourceNode.onended=g;const m=this._nativeAudioBufferSourceNode.onended;this._onended=m!==null&&m===g?p:m}get playbackRate(){return this._playbackRate}start(p=0,g=0,m){if(this._nativeAudioBufferSourceNode.start(p,g,m),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=m===void 0?[p,g]:[p,g,m]),this.context.state!=="closed"){setInternalStateToActive(this);const _=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",_),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",_)}}stop(p=0){this._nativeAudioBufferSourceNode.stop(p),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=p)}},createAudioBufferSourceNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap;let d=null,h=null;const f=async(p,g)=>{let m=i(p);const _=isOwnedByContext(m,g);if(!_){const v={buffer:m.buffer,channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,loop:m.loop,loopEnd:m.loopEnd,loopStart:m.loopStart,playbackRate:m.playbackRate.value};m=s(g,v),d!==null&&m.start(...d),h!==null&&m.stop(h)}return l.set(g,m),_?await c(g,p.playbackRate,m.playbackRate):await a(g,p.playbackRate,m.playbackRate),await u(p,g,m),m};return{set start(p){d=p},set stop(p){h=p},render(p,g){const m=l.get(g);return m!==void 0?Promise.resolve(m):f(p,g)}}},isAudioBufferSourceNode=c=>"playbackRate"in c,isBiquadFilterNode=c=>"frequency"in c&&"gain"in c,isConstantSourceNode=c=>"offset"in c,isGainNode=c=>!("frequency"in c)&&"gain"in c,isOscillatorNode=c=>"detune"in c&&"frequency"in c,isStereoPannerNode=c=>"pan"in c,getAudioNodeConnections=c=>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE,c),getAudioParamConnections=c=>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE,c),deactivateActiveAudioNodeInputConnections=(c,s)=>{const{activeInputs:i}=getAudioNodeConnections(c);i.forEach(u=>u.forEach(([l])=>{s.includes(c)||deactivateActiveAudioNodeInputConnections(l,[...s,c])}));const a=isAudioBufferSourceNode(c)?[c.playbackRate]:isAudioWorkletNode(c)?Array.from(c.parameters.values()):isBiquadFilterNode(c)?[c.Q,c.detune,c.frequency,c.gain]:isConstantSourceNode(c)?[c.offset]:isGainNode(c)?[c.gain]:isOscillatorNode(c)?[c.detune,c.frequency]:isStereoPannerNode(c)?[c.pan]:[];for(const u of a){const l=getAudioParamConnections(u);l!==void 0&&l.activeInputs.forEach(([d])=>deactivateActiveAudioNodeInputConnections(d,s))}isActiveAudioNode(c)&&setInternalStateToPassive(c)},deactivateAudioGraph=c=>{deactivateActiveAudioNodeInputConnections(c.destination,[])},isValidLatencyHint=c=>c===void 0||typeof c=="number"||typeof c=="string"&&(c==="balanced"||c==="interactive"||c==="playback"),createAudioContextConstructor=(c,s,i,a,u,l,d,h,f)=>class extends c{constructor(g={}){if(f===null)throw new Error("Missing the native AudioContext constructor.");let m;try{m=new f(g)}catch(y){throw y.code===12&&y.message==="sampleRate is not in range"?i():y}if(m===null)throw a();if(!isValidLatencyHint(g.latencyHint))throw new TypeError(`The provided value '${g.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(g.sampleRate!==void 0&&m.sampleRate!==g.sampleRate)throw i();super(m,2);const{latencyHint:_}=g,{sampleRate:v}=m;if(this._baseLatency=typeof m.baseLatency=="number"?m.baseLatency:_==="balanced"?512/v:_==="interactive"||_===void 0?256/v:_==="playback"?1024/v:Math.max(2,Math.min(128,Math.round(_*v/128)))*128/v,this._nativeAudioContext=m,f.name==="webkitAudioContext"?(this._nativeGainNode=m.createGain(),this._nativeOscillatorNode=m.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(m.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,m.state==="running"){this._state="suspended";const y=()=>{this._state==="suspended"&&(this._state=null),m.removeEventListener("statechange",y)};m.addEventListener("statechange",y)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){return this.state==="closed"?this._nativeAudioContext.close().then(()=>{throw s()}):(this._state==="suspended"&&(this._state=null),this._nativeAudioContext.close().then(()=>{this._nativeGainNode!==null&&this._nativeOscillatorNode!==null&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),deactivateAudioGraph(this)}))}createMediaElementSource(g){return new u(this,{mediaElement:g})}createMediaStreamDestination(){return new l(this)}createMediaStreamSource(g){return new d(this,{mediaStream:g})}createMediaStreamTrackSource(g){return new h(this,{mediaStreamTrack:g})}resume(){return this._state==="suspended"?new Promise((g,m)=>{const _=()=>{this._nativeAudioContext.removeEventListener("statechange",_),this._nativeAudioContext.state==="running"?g():this.resume().then(g,m)};this._nativeAudioContext.addEventListener("statechange",_)}):this._nativeAudioContext.resume().catch(g=>{throw g===void 0||g.code===15?s():g})}suspend(){return this._nativeAudioContext.suspend().catch(g=>{throw g===void 0?s():g})}},createAudioDestinationNodeConstructor=(c,s,i,a,u,l,d,h)=>class extends c{constructor(p,g){const m=l(p),_=d(m),v=u(m,g,_),y=_?s(h):null;super(p,!1,v,y),this._isNodeOfNativeOfflineAudioContext=_,this._nativeAudioDestinationNode=v}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(p){if(this._isNodeOfNativeOfflineAudioContext)throw a();if(p>this._nativeAudioDestinationNode.maxChannelCount)throw i();this._nativeAudioDestinationNode.channelCount=p}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(p){if(this._isNodeOfNativeOfflineAudioContext)throw a();this._nativeAudioDestinationNode.channelCountMode=p}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}},createAudioDestinationNodeRenderer=c=>{const s=new WeakMap,i=async(a,u)=>{const l=u.destination;return s.set(u,l),await c(a,u,l),l};return{render(a,u){const l=s.get(u);return l!==void 0?Promise.resolve(l):i(a,u)}}},createAudioListenerFactory=(c,s,i,a,u,l,d,h)=>(f,p)=>{const g=p.listener,m=()=>{const N=new Float32Array(1),C=s(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),w=d(p);let S=!1,M=[0,0,-1,0,1,0],P=[0,0,0];const I=()=>{if(S)return;S=!0;const z=a(p,256,9,0);z.onaudioprocess=({inputBuffer:V})=>{const L=[l(V,N,0),l(V,N,1),l(V,N,2),l(V,N,3),l(V,N,4),l(V,N,5)];L.some((q,j)=>q!==M[j])&&(g.setOrientation(...L),M=L);const $=[l(V,N,6),l(V,N,7),l(V,N,8)];$.some((q,j)=>q!==P[j])&&(g.setPosition(...$),P=$)},C.connect(z)},k=z=>V=>{V!==M[z]&&(M[z]=V,g.setOrientation(...M))},D=z=>V=>{V!==P[z]&&(P[z]=V,g.setPosition(...P))},R=(z,V,L)=>{const $=i(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:V});$.connect(C,0,z),$.start(),Object.defineProperty($.offset,"defaultValue",{get(){return V}});const q=c({context:f},w,$.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT);return h(q,"value",j=>()=>j.call(q),j=>U=>{try{j.call(q,U)}catch(Z){if(Z.code!==9)throw Z}I(),w&&L(U)}),q.cancelAndHoldAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.cancelAndHoldAtTime),q.cancelScheduledValues=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.cancelScheduledValues),q.exponentialRampToValueAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.exponentialRampToValueAtTime),q.linearRampToValueAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.linearRampToValueAtTime),q.setTargetAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.setTargetAtTime),q.setValueAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.setValueAtTime),q.setValueCurveAtTime=(j=>w?()=>{throw u()}:(...U)=>{const Z=j.apply(q,U);return I(),Z})(q.setValueCurveAtTime),q};return{forwardX:R(0,0,k(0)),forwardY:R(1,0,k(1)),forwardZ:R(2,-1,k(2)),positionX:R(6,0,D(0)),positionY:R(7,0,D(1)),positionZ:R(8,0,D(2)),upX:R(3,0,k(3)),upY:R(4,1,k(4)),upZ:R(5,0,k(5))}},{forwardX:_,forwardY:v,forwardZ:y,positionX:A,positionY:T,positionZ:x,upX:O,upY:E,upZ:b}=g.forwardX===void 0?m():g;return{get forwardX(){return _},get forwardY(){return v},get forwardZ(){return y},get positionX(){return A},get positionY(){return T},get positionZ(){return x},get upX(){return O},get upY(){return E},get upZ(){return b}}},isAudioNode$1=c=>"context"in c,isAudioNodeOutputConnection=c=>isAudioNode$1(c[0]),insertElementInSet=(c,s,i,a)=>{for(const u of c)if(i(u)){if(a)return!1;throw Error("The set contains at least one similar element.")}return c.add(s),!0},addActiveInputConnectionToAudioParam=(c,s,[i,a],u)=>{insertElementInSet(c,[s,i,a],l=>l[0]===s&&l[1]===i,u)},addPassiveInputConnectionToAudioParam=(c,[s,i,a],u)=>{const l=c.get(s);l===void 0?c.set(s,new Set([[i,a]])):insertElementInSet(l,[i,a],d=>d[0]===i,u)},isNativeAudioNodeFaker=c=>"inputs"in c,connectNativeAudioNodeToNativeAudioNode=(c,s,i,a)=>{if(isNativeAudioNodeFaker(s)){const u=s.inputs[a];return c.connect(u,i,0),[u,i,0]}return c.connect(s,i,a),[s,i,a]},deleteActiveInputConnection=(c,s,i)=>{for(const a of c)if(a[0]===s&&a[1]===i)return c.delete(a),a;return null},deleteActiveInputConnectionToAudioParam=(c,s,i)=>pickElementFromSet(c,a=>a[0]===s&&a[1]===i),deleteEventListenerOfAudioNode=(c,s)=>{if(!getEventListenersOfAudioNode(c).delete(s))throw new Error("Missing the expected event listener.")},deletePassiveInputConnectionToAudioParam=(c,s,i)=>{const a=getValueForKey(c,s),u=pickElementFromSet(a,l=>l[0]===i);return a.size===0&&c.delete(s),u},disconnectNativeAudioNodeFromNativeAudioNode=(c,s,i,a)=>{isNativeAudioNodeFaker(s)?c.disconnect(s.inputs[a],i,0):c.disconnect(s,i,a)},getNativeAudioNode=c=>getValueForKey(AUDIO_NODE_STORE,c),getNativeAudioParam=c=>getValueForKey(AUDIO_PARAM_STORE,c),isPartOfACycle=c=>CYCLE_COUNTERS.has(c),isPassiveAudioNode=c=>!ACTIVE_AUDIO_NODE_STORE.has(c),testAudioNodeDisconnectMethodSupport=(c,s)=>new Promise(i=>{if(s!==null)i(!0);else{const a=c.createScriptProcessor(256,1,1),u=c.createGain(),l=c.createBuffer(1,2,44100),d=l.getChannelData(0);d[0]=1,d[1]=1;const h=c.createBufferSource();h.buffer=l,h.loop=!0,h.connect(a).connect(c.destination),h.connect(u),h.disconnect(u),a.onaudioprocess=f=>{const p=f.inputBuffer.getChannelData(0);Array.prototype.some.call(p,g=>g===1)?i(!0):i(!1),h.stop(),a.onaudioprocess=null,h.disconnect(a),a.disconnect(c.destination)},h.start()}}),visitEachAudioNodeOnce=(c,s)=>{const i=new Map;for(const a of c)for(const u of a){const l=i.get(u);i.set(u,l===void 0?1:l+1)}i.forEach((a,u)=>s(u,a))},isNativeAudioNode$1=c=>"context"in c,wrapAudioNodeDisconnectMethod=c=>{const s=new Map;c.connect=(i=>(a,u=0,l=0)=>{const d=isNativeAudioNode$1(a)?i(a,u,l):i(a,u),h=s.get(a);return h===void 0?s.set(a,[{input:l,output:u}]):h.every(f=>f.input!==l||f.output!==u)&&h.push({input:l,output:u}),d})(c.connect.bind(c)),c.disconnect=(i=>(a,u,l)=>{if(i.apply(c),a===void 0)s.clear();else if(typeof a=="number")for(const[d,h]of s){const f=h.filter(p=>p.output!==a);f.length===0?s.delete(d):s.set(d,f)}else if(s.has(a))if(u===void 0)s.delete(a);else{const d=s.get(a);if(d!==void 0){const h=d.filter(f=>f.output!==u&&(f.input!==l||l===void 0));h.length===0?s.delete(a):s.set(a,h)}}for(const[d,h]of s)h.forEach(f=>{isNativeAudioNode$1(d)?c.connect(d,f.output,f.input):c.connect(d,f.output)})})(c.disconnect)},addConnectionToAudioParamOfAudioContext=(c,s,i,a)=>{const{activeInputs:u,passiveInputs:l}=getAudioParamConnections(s),{outputs:d}=getAudioNodeConnections(c),h=getEventListenersOfAudioNode(c),f=p=>{const g=getNativeAudioNode(c),m=getNativeAudioParam(s);if(p){const _=deletePassiveInputConnectionToAudioParam(l,c,i);addActiveInputConnectionToAudioParam(u,c,_,!1),!a&&!isPartOfACycle(c)&&g.connect(m,i)}else{const _=deleteActiveInputConnectionToAudioParam(u,c,i);addPassiveInputConnectionToAudioParam(l,_,!1),!a&&!isPartOfACycle(c)&&g.disconnect(m,i)}};return insertElementInSet(d,[s,i],p=>p[0]===s&&p[1]===i,!0)?(h.add(f),isActiveAudioNode(c)?addActiveInputConnectionToAudioParam(u,c,[i,f],!0):addPassiveInputConnectionToAudioParam(l,[c,i,f],!0),!0):!1},deleteInputConnectionOfAudioNode=(c,s,i,a)=>{const{activeInputs:u,passiveInputs:l}=getAudioNodeConnections(s),d=deleteActiveInputConnection(u[a],c,i);return d===null?[deletePassiveInputConnectionToAudioNode(l,c,i,a)[2],!1]:[d[2],!0]},deleteInputConnectionOfAudioParam=(c,s,i)=>{const{activeInputs:a,passiveInputs:u}=getAudioParamConnections(s),l=deleteActiveInputConnection(a,c,i);return l===null?[deletePassiveInputConnectionToAudioParam(u,c,i)[1],!1]:[l[2],!0]},deleteInputsOfAudioNode=(c,s,i,a,u)=>{const[l,d]=deleteInputConnectionOfAudioNode(c,i,a,u);if(l!==null&&(deleteEventListenerOfAudioNode(c,l),d&&!s&&!isPartOfACycle(c)&&disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(c),getNativeAudioNode(i),a,u)),isActiveAudioNode(i)){const{activeInputs:h}=getAudioNodeConnections(i);setInternalStateToPassiveWhenNecessary(i,h)}},deleteInputsOfAudioParam=(c,s,i,a)=>{const[u,l]=deleteInputConnectionOfAudioParam(c,i,a);u!==null&&(deleteEventListenerOfAudioNode(c,u),l&&!s&&!isPartOfACycle(c)&&getNativeAudioNode(c).disconnect(getNativeAudioParam(i),a))},deleteAnyConnection=(c,s)=>{const i=getAudioNodeConnections(c),a=[];for(const u of i.outputs)isAudioNodeOutputConnection(u)?deleteInputsOfAudioNode(c,s,...u):deleteInputsOfAudioParam(c,s,...u),a.push(u[0]);return i.outputs.clear(),a},deleteConnectionAtOutput=(c,s,i)=>{const a=getAudioNodeConnections(c),u=[];for(const l of a.outputs)l[1]===i&&(isAudioNodeOutputConnection(l)?deleteInputsOfAudioNode(c,s,...l):deleteInputsOfAudioParam(c,s,...l),u.push(l[0]),a.outputs.delete(l));return u},deleteConnectionToDestination=(c,s,i,a,u)=>{const l=getAudioNodeConnections(c);return Array.from(l.outputs).filter(d=>d[0]===i&&(a===void 0||d[1]===a)&&(u===void 0||d[2]===u)).map(d=>(isAudioNodeOutputConnection(d)?deleteInputsOfAudioNode(c,s,...d):deleteInputsOfAudioParam(c,s,...d),l.outputs.delete(d),d[0]))},createAudioNodeConstructor=(c,s,i,a,u,l,d,h,f,p,g,m,_,v,y,A)=>class extends p{constructor(x,O,E,b){super(E),this._context=x,this._nativeAudioNode=E;const N=g(x);m(N)&&i(testAudioNodeDisconnectMethodSupport,()=>testAudioNodeDisconnectMethodSupport(N,A))!==!0&&wrapAudioNodeDisconnectMethod(E),AUDIO_NODE_STORE.set(this,E),EVENT_LISTENERS.set(this,new Set),x.state!=="closed"&&O&&setInternalStateToActive(this),c(this,b,E)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(x){this._nativeAudioNode.channelCount=x}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(x){this._nativeAudioNode.channelCountMode=x}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(x){this._nativeAudioNode.channelInterpretation=x}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(x,O=0,E=0){if(O<0||O>=this._nativeAudioNode.numberOfOutputs)throw u();const b=g(this._context),N=y(b);if(_(x)||v(x))throw l();if(isAudioNode$1(x)){const S=getNativeAudioNode(x);try{const P=connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode,S,O,E),I=isPassiveAudioNode(this);(N||I)&&this._nativeAudioNode.disconnect(...P),this.context.state!=="closed"&&!I&&isPassiveAudioNode(x)&&setInternalStateToActive(x)}catch(P){throw P.code===12?l():P}if(s(this,x,O,E,N)){const P=f([this],x);visitEachAudioNodeOnce(P,a(N))}return x}const C=getNativeAudioParam(x);if(C.name==="playbackRate"&&C.maxValue===1024)throw d();try{this._nativeAudioNode.connect(C,O),(N||isPassiveAudioNode(this))&&this._nativeAudioNode.disconnect(C,O)}catch(S){throw S.code===12?l():S}if(addConnectionToAudioParamOfAudioContext(this,x,O,N)){const S=f([this],x);visitEachAudioNodeOnce(S,a(N))}}disconnect(x,O,E){let b;const N=g(this._context),C=y(N);if(x===void 0)b=deleteAnyConnection(this,C);else if(typeof x=="number"){if(x<0||x>=this.numberOfOutputs)throw u();b=deleteConnectionAtOutput(this,C,x)}else{if(O!==void 0&&(O<0||O>=this.numberOfOutputs)||isAudioNode$1(x)&&E!==void 0&&(E<0||E>=x.numberOfInputs))throw u();if(b=deleteConnectionToDestination(this,C,x,O,E),b.length===0)throw l()}for(const w of b){const S=f([this],w);visitEachAudioNodeOnce(S,h)}}},createAudioParamFactory=(c,s,i,a,u,l,d,h,f,p,g,m,_)=>(v,y,A,T=null,x=null)=>{const O=new AutomationEventList(A.defaultValue),E=y?a(O):null,b={get defaultValue(){return A.defaultValue},get maxValue(){return T===null?A.maxValue:T},get minValue(){return x===null?A.minValue:x},get value(){return A.value},set value(N){A.value=N,b.setValueAtTime(N,v.context.currentTime)},cancelAndHoldAtTime(N){if(typeof A.cancelAndHoldAtTime=="function")E===null&&O.flush(v.context.currentTime),O.add(u(N)),A.cancelAndHoldAtTime(N);else{const C=Array.from(O).pop();E===null&&O.flush(v.context.currentTime),O.add(u(N));const w=Array.from(O).pop();A.cancelScheduledValues(N),C!==w&&w!==void 0&&(w.type==="exponentialRampToValue"?A.exponentialRampToValueAtTime(w.value,w.endTime):w.type==="linearRampToValue"?A.linearRampToValueAtTime(w.value,w.endTime):w.type==="setValue"?A.setValueAtTime(w.value,w.startTime):w.type==="setValueCurve"&&A.setValueCurveAtTime(w.values,w.startTime,w.duration))}return b},cancelScheduledValues(N){return E===null&&O.flush(v.context.currentTime),O.add(l(N)),A.cancelScheduledValues(N),b},exponentialRampToValueAtTime(N,C){if(N===0)throw new RangeError;if(!Number.isFinite(C)||C<0)throw new RangeError;return E===null&&O.flush(v.context.currentTime),O.add(d(N,C)),A.exponentialRampToValueAtTime(N,C),b},linearRampToValueAtTime(N,C){return E===null&&O.flush(v.context.currentTime),O.add(h(N,C)),A.linearRampToValueAtTime(N,C),b},setTargetAtTime(N,C,w){return E===null&&O.flush(v.context.currentTime),O.add(f(N,C,w)),A.setTargetAtTime(N,C,w),b},setValueAtTime(N,C){return E===null&&O.flush(v.context.currentTime),O.add(p(N,C)),A.setValueAtTime(N,C),b},setValueCurveAtTime(N,C,w){const S=N instanceof Float32Array?N:new Float32Array(N);if(m!==null&&m.name==="webkitAudioContext"){const M=C+w,P=v.context.sampleRate,I=Math.ceil(C*P),k=Math.floor(M*P),D=k-I,R=new Float32Array(D);for(let V=0;V<D;V+=1){const L=(S.length-1)/w*((I+V)/P-C),$=Math.floor(L),q=Math.ceil(L);R[V]=$===q?S[$]:(1-(L-$))*S[$]+(1-(q-L))*S[q]}E===null&&O.flush(v.context.currentTime),O.add(g(R,C,w)),A.setValueCurveAtTime(R,C,w);const z=k/P;z<M&&_(b,R[R.length-1],z),_(b,S[S.length-1],M)}else E===null&&O.flush(v.context.currentTime),O.add(g(S,C,w)),A.setValueCurveAtTime(S,C,w);return b}};return i.set(b,A),s.set(b,v),c(b,E),b},createAudioParamRenderer=c=>({replay(s){for(const i of c)if(i.type==="exponentialRampToValue"){const{endTime:a,value:u}=i;s.exponentialRampToValueAtTime(u,a)}else if(i.type==="linearRampToValue"){const{endTime:a,value:u}=i;s.linearRampToValueAtTime(u,a)}else if(i.type==="setTarget"){const{startTime:a,target:u,timeConstant:l}=i;s.setTargetAtTime(u,a,l)}else if(i.type==="setValue"){const{startTime:a,value:u}=i;s.setValueAtTime(u,a)}else if(i.type==="setValueCurve"){const{duration:a,startTime:u,values:l}=i;s.setValueCurveAtTime(l,u,a)}else throw new Error("Can't apply an unknown automation.")}});class ReadOnlyMap{constructor(s){this._map=new Map(s)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(s,i=null){return this._map.forEach((a,u)=>s.call(i,a,u,this))}get(s){return this._map.get(s)}has(s){return this._map.has(s)}keys(){return this._map.keys()}values(){return this._map.values()}}const DEFAULT_OPTIONS$g={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}},createAudioWorkletNodeConstructor=(c,s,i,a,u,l,d,h,f,p,g,m,_,v)=>class extends s{constructor(A,T,x){var O;const E=h(A),b=f(E),N=g({...DEFAULT_OPTIONS$g,...x});_(N);const C=NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(E),w=C==null?void 0:C.get(T),S=b||E.state!=="closed"?E:(O=d(E))!==null&&O!==void 0?O:E,M=u(S,b?null:A.baseLatency,p,T,w,N),P=b?a(T,N,w):null;super(A,!0,M,P);const I=[];M.parameters.forEach((D,R)=>{const z=i(this,b,D);I.push([R,z])}),this._nativeAudioWorkletNode=M,this._onprocessorerror=null,this._parameters=new ReadOnlyMap(I),b&&c(E,this);const{activeInputs:k}=l(this);m(M,k)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(A){const T=typeof A=="function"?v(this,A):null;this._nativeAudioWorkletNode.onprocessorerror=T;const x=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=x!==null&&x===T?A:x}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function copyFromChannel(c,s,i,a,u){if(typeof c.copyFromChannel=="function")s[i].byteLength===0&&(s[i]=new Float32Array(128)),c.copyFromChannel(s[i],a,u);else{const l=c.getChannelData(a);if(s[i].byteLength===0)s[i]=l.slice(u,u+128);else{const d=new Float32Array(l.buffer,u*Float32Array.BYTES_PER_ELEMENT,128);s[i].set(d)}}}const copyToChannel=(c,s,i,a,u)=>{typeof c.copyToChannel=="function"?s[i].byteLength!==0&&c.copyToChannel(s[i],a,u):s[i].byteLength!==0&&c.getChannelData(a).set(s[i],u)},createNestedArrays=(c,s)=>{const i=[];for(let a=0;a<c;a+=1){const u=[],l=typeof s=="number"?s:s[a];for(let d=0;d<l;d+=1)u.push(new Float32Array(128));i.push(u)}return i},getAudioWorkletProcessor=(c,s)=>{const i=getValueForKey(NODE_TO_PROCESSOR_MAPS,c),a=getNativeAudioNode(s);return getValueForKey(i,a)},processBuffer=async(c,s,i,a,u,l,d)=>{const h=s===null?Math.ceil(c.context.length/128)*128:s.length,f=a.channelCount*a.numberOfInputs,p=u.reduce((T,x)=>T+x,0),g=p===0?null:i.createBuffer(p,h,i.sampleRate);if(l===void 0)throw new Error("Missing the processor constructor.");const m=getAudioNodeConnections(c),_=await getAudioWorkletProcessor(i,c),v=createNestedArrays(a.numberOfInputs,a.channelCount),y=createNestedArrays(a.numberOfOutputs,u),A=Array.from(c.parameters.keys()).reduce((T,x)=>({...T,[x]:new Float32Array(128)}),{});for(let T=0;T<h;T+=128){if(a.numberOfInputs>0&&s!==null)for(let x=0;x<a.numberOfInputs;x+=1)for(let O=0;O<a.channelCount;O+=1)copyFromChannel(s,v[x],O,O,T);l.parameterDescriptors!==void 0&&s!==null&&l.parameterDescriptors.forEach(({name:x},O)=>{copyFromChannel(s,A,x,f+O,T)});for(let x=0;x<a.numberOfInputs;x+=1)for(let O=0;O<u[x];O+=1)y[x][O].byteLength===0&&(y[x][O]=new Float32Array(128));try{const x=v.map((E,b)=>m.activeInputs[b].size===0?[]:E),O=d(T/i.sampleRate,i.sampleRate,()=>_.process(x,y,A));if(g!==null)for(let E=0,b=0;E<a.numberOfOutputs;E+=1){for(let N=0;N<u[E];N+=1)copyToChannel(g,y[E],N,b+N,T);b+=u[E]}if(!O)break}catch(x){c.dispatchEvent(new ErrorEvent("processorerror",{colno:x.colno,filename:x.filename,lineno:x.lineno,message:x.message}));break}}return g},createAudioWorkletNodeRendererFactory=(c,s,i,a,u,l,d,h,f,p,g,m,_,v,y,A)=>(T,x,O)=>{const E=new WeakMap;let b=null;const N=async(C,w)=>{let S=g(C),M=null;const P=isOwnedByContext(S,w),I=Array.isArray(x.outputChannelCount)?x.outputChannelCount:Array.from(x.outputChannelCount);if(m===null){const k=I.reduce((V,L)=>V+L,0),D=u(w,{channelCount:Math.max(1,k),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,k)}),R=[];for(let V=0;V<C.numberOfOutputs;V+=1)R.push(a(w,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:I[V]}));const z=d(w,{channelCount:x.channelCount,channelCountMode:x.channelCountMode,channelInterpretation:x.channelInterpretation,gain:1});z.connect=s.bind(null,R),z.disconnect=f.bind(null,R),M=[D,R,z]}else P||(S=new m(w,T));if(E.set(w,M===null?S:M[2]),M!==null){if(b===null){if(O===void 0)throw new Error("Missing the processor constructor.");if(_===null)throw new Error("Missing the native OfflineAudioContext constructor.");const L=C.channelCount*C.numberOfInputs,$=O.parameterDescriptors===void 0?0:O.parameterDescriptors.length,q=L+$;b=processBuffer(C,q===0?null:await(async()=>{const U=new _(q,Math.ceil(C.context.length/128)*128,w.sampleRate),Z=[],te=[];for(let H=0;H<x.numberOfInputs;H+=1)Z.push(d(U,{channelCount:x.channelCount,channelCountMode:x.channelCountMode,channelInterpretation:x.channelInterpretation,gain:1})),te.push(u(U,{channelCount:x.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:x.channelCount}));const ne=await Promise.all(Array.from(C.parameters.values()).map(async H=>{const ee=l(U,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:H.value});return await v(U,H,ee.offset),ee})),Y=a(U,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,L+$)});for(let H=0;H<x.numberOfInputs;H+=1){Z[H].connect(te[H]);for(let ee=0;ee<x.channelCount;ee+=1)te[H].connect(Y,ee,H*x.channelCount+ee)}for(const[H,ee]of ne.entries())ee.connect(Y,0,L+H),ee.start(0);return Y.connect(U.destination),await Promise.all(Z.map(H=>y(C,U,H))),A(U)})(),w,x,I,O,p)}const k=await b,D=i(w,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[R,z,V]=M;k!==null&&(D.buffer=k,D.start(0)),D.connect(R);for(let L=0,$=0;L<C.numberOfOutputs;L+=1){const q=z[L];for(let j=0;j<I[L];j+=1)R.connect(q,$+j,j);$+=I[L]}return V}if(P)for(const[k,D]of C.parameters.entries())await c(w,D,S.parameters.get(k));else for(const[k,D]of C.parameters.entries())await v(w,D,S.parameters.get(k));return await y(C,w,S),S};return{render(C,w){h(w,C);const S=E.get(w);return S!==void 0?Promise.resolve(S):N(C,w)}}},createBaseAudioContextConstructor=(c,s,i,a,u,l,d,h,f,p,g,m,_,v,y,A,T,x,O,E)=>class extends y{constructor(N,C){super(N,C),this._nativeContext=N,this._audioWorklet=c===void 0?void 0:{addModule:(w,S)=>c(this,w,S)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new s(this)}createBiquadFilter(){return new u(this)}createBuffer(N,C,w){return new i({length:C,numberOfChannels:N,sampleRate:w})}createBufferSource(){return new a(this)}createChannelMerger(N=6){return new l(this,{numberOfInputs:N})}createChannelSplitter(N=6){return new d(this,{numberOfOutputs:N})}createConstantSource(){return new h(this)}createConvolver(){return new f(this)}createDelay(N=1){return new g(this,{maxDelayTime:N})}createDynamicsCompressor(){return new m(this)}createGain(){return new _(this)}createIIRFilter(N,C){return new v(this,{feedback:C,feedforward:N})}createOscillator(){return new A(this)}createPanner(){return new T(this)}createPeriodicWave(N,C,w={disableNormalization:!1}){return new x(this,{...w,imag:C,real:N})}createStereoPanner(){return new O(this)}createWaveShaper(){return new E(this)}decodeAudioData(N,C,w){return p(this._nativeContext,N).then(S=>(typeof C=="function"&&C(S),S),S=>{throw typeof w=="function"&&w(S),S})}},DEFAULT_OPTIONS$f={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},createBiquadFilterNodeConstructor=(c,s,i,a,u,l,d,h)=>class extends c{constructor(p,g){const m=l(p),_={...DEFAULT_OPTIONS$f,...g},v=u(m,_),y=d(m),A=y?i():null;super(p,!1,v,A),this._Q=s(this,y,v.Q,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._detune=s(this,y,v.detune,1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT),-1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT)),this._frequency=s(this,y,v.frequency,p.sampleRate/2,0),this._gain=s(this,y,v.gain,40*Math.log10(MOST_POSITIVE_SINGLE_FLOAT),MOST_NEGATIVE_SINGLE_FLOAT),this._nativeBiquadFilterNode=v,h(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(p){this._nativeBiquadFilterNode.type=p}getFrequencyResponse(p,g,m){try{this._nativeBiquadFilterNode.getFrequencyResponse(p,g,m)}catch(_){throw _.code===11?a():_}if(p.length!==g.length||g.length!==m.length)throw a()}},createBiquadFilterNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap,d=async(h,f)=>{let p=i(h);const g=isOwnedByContext(p,f);if(!g){const m={Q:p.Q.value,channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,detune:p.detune.value,frequency:p.frequency.value,gain:p.gain.value,type:p.type};p=s(f,m)}return l.set(f,p),g?(await c(f,h.Q,p.Q),await c(f,h.detune,p.detune),await c(f,h.frequency,p.frequency),await c(f,h.gain,p.gain)):(await a(f,h.Q,p.Q),await a(f,h.detune,p.detune),await a(f,h.frequency,p.frequency),await a(f,h.gain,p.gain)),await u(h,f,p),p};return{render(h,f){const p=l.get(f);return p!==void 0?Promise.resolve(p):d(h,f)}}},createCacheTestResult=(c,s)=>(i,a)=>{const u=s.get(i);if(u!==void 0)return u;const l=c.get(i);if(l!==void 0)return l;try{const d=a();return d instanceof Promise?(c.set(i,d),d.catch(()=>!1).then(h=>(c.delete(i),s.set(i,h),h))):(s.set(i,d),d)}catch{return s.set(i,!1),!1}},DEFAULT_OPTIONS$e={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},createChannelMergerNodeConstructor=(c,s,i,a,u)=>class extends c{constructor(d,h){const f=a(d),p={...DEFAULT_OPTIONS$e,...h},g=i(f,p),m=u(f)?s():null;super(d,!1,g,m)}},createChannelMergerNodeRendererFactory=(c,s,i)=>()=>{const a=new WeakMap,u=async(l,d)=>{let h=s(l);if(!isOwnedByContext(h,d)){const p={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,numberOfInputs:h.numberOfInputs};h=c(d,p)}return a.set(d,h),await i(l,d,h),h};return{render(l,d){const h=a.get(d);return h!==void 0?Promise.resolve(h):u(l,d)}}},DEFAULT_OPTIONS$d={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},createChannelSplitterNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=a(h),g=l({...DEFAULT_OPTIONS$d,...f}),m=i(p,g),_=u(p)?s():null;super(h,!1,m,_)}},createChannelSplitterNodeRendererFactory=(c,s,i)=>()=>{const a=new WeakMap,u=async(l,d)=>{let h=s(l);if(!isOwnedByContext(h,d)){const p={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,numberOfOutputs:h.numberOfOutputs};h=c(d,p)}return a.set(d,h),await i(l,d,h),h};return{render(l,d){const h=a.get(d);return h!==void 0?Promise.resolve(h):u(l,d)}}},createConnectAudioParam=c=>(s,i,a)=>c(i,s,a),createConnectMultipleOutputs=c=>(s,i,a=0,u=0)=>{const l=s[a];if(l===void 0)throw c();return isNativeAudioNode$1(i)?l.connect(i,0,u):l.connect(i,0)},createConnectedNativeAudioBufferSourceNodeFactory=c=>(s,i)=>{const a=c(s,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),u=s.createBuffer(1,2,44100);return a.buffer=u,a.loop=!0,a.connect(i),a.start(),()=>{a.stop(),a.disconnect(i)}},DEFAULT_OPTIONS$c={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},createConstantSourceNodeConstructor=(c,s,i,a,u,l,d)=>class extends c{constructor(f,p){const g=u(f),m={...DEFAULT_OPTIONS$c,...p},_=a(g,m),v=l(g),y=v?i():null;super(f,!1,_,y),this._constantSourceNodeRenderer=y,this._nativeConstantSourceNode=_,this._offset=s(this,v,_.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(f){const p=typeof f=="function"?d(this,f):null;this._nativeConstantSourceNode.onended=p;const g=this._nativeConstantSourceNode.onended;this._onended=g!==null&&g===p?f:g}start(f=0){if(this._nativeConstantSourceNode.start(f),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.start=f),this.context.state!=="closed"){setInternalStateToActive(this);const p=()=>{this._nativeConstantSourceNode.removeEventListener("ended",p),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeConstantSourceNode.addEventListener("ended",p)}}stop(f=0){this._nativeConstantSourceNode.stop(f),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.stop=f)}},createConstantSourceNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap;let d=null,h=null;const f=async(p,g)=>{let m=i(p);const _=isOwnedByContext(m,g);if(!_){const v={channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,offset:m.offset.value};m=s(g,v),d!==null&&m.start(d),h!==null&&m.stop(h)}return l.set(g,m),_?await c(g,p.offset,m.offset):await a(g,p.offset,m.offset),await u(p,g,m),m};return{set start(p){d=p},set stop(p){h=p},render(p,g){const m=l.get(g);return m!==void 0?Promise.resolve(m):f(p,g)}}},createConvertNumberToUnsignedLong=c=>s=>(c[0]=s,c[0]),DEFAULT_OPTIONS$b={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},createConvolverNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=a(h),g={...DEFAULT_OPTIONS$b,...f},m=i(p,g),v=u(p)?s():null;super(h,!1,m,v),this._isBufferNullified=!1,this._nativeConvolverNode=m,g.buffer!==null&&l(this,g.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(h){if(this._nativeConvolverNode.buffer=h,h===null&&this._nativeConvolverNode.buffer!==null){const f=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=f.createBuffer(1,1,f.sampleRate),this._isBufferNullified=!0,l(this,0)}else this._isBufferNullified=!1,l(this,this._nativeConvolverNode.buffer===null?0:this._nativeConvolverNode.buffer.duration)}get normalize(){return this._nativeConvolverNode.normalize}set normalize(h){this._nativeConvolverNode.normalize=h}},createConvolverNodeRendererFactory=(c,s,i)=>()=>{const a=new WeakMap,u=async(l,d)=>{let h=s(l);if(!isOwnedByContext(h,d)){const p={buffer:h.buffer,channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,disableNormalization:!h.normalize};h=c(d,p)}return a.set(d,h),isNativeAudioNodeFaker(h)?await i(l,d,h.inputs[0]):await i(l,d,h),h};return{render(l,d){const h=a.get(d);return h!==void 0?Promise.resolve(h):u(l,d)}}},createCreateNativeOfflineAudioContext=(c,s)=>(i,a,u)=>{if(s===null)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new s(i,a,u)}catch(l){throw l.name==="SyntaxError"?c():l}},createDataCloneError=()=>new DOMException("","DataCloneError"),detachArrayBuffer=c=>{const{port1:s,port2:i}=new MessageChannel;return new Promise(a=>{const u=()=>{i.onmessage=null,s.close(),i.close(),a()};i.onmessage=()=>u();try{s.postMessage(c,[c])}finally{u()}})},createDecodeAudioData=(c,s,i,a,u,l,d,h,f,p,g)=>(m,_)=>{const v=d(m)?m:l(m);if(u.has(_)){const y=i();return Promise.reject(y)}try{u.add(_)}catch{}return s(f,()=>f(v))?v.decodeAudioData(_).then(y=>(detachArrayBuffer(_).catch(()=>{}),s(h,()=>h(y))||g(y),c.add(y),y)):new Promise((y,A)=>{const T=async()=>{try{await detachArrayBuffer(_)}catch{}},x=O=>{A(O),T()};try{v.decodeAudioData(_,O=>{typeof O.copyFromChannel!="function"&&(p(O),wrapAudioBufferGetChannelDataMethod(O)),c.add(O),T().then(()=>y(O))},O=>{x(O===null?a():O)})}catch(O){x(O)}})},createDecrementCycleCounter=(c,s,i,a,u,l,d,h)=>(f,p)=>{const g=s.get(f);if(g===void 0)throw new Error("Missing the expected cycle count.");const m=l(f.context),_=h(m);if(g===p){if(s.delete(f),!_&&d(f)){const v=a(f),{outputs:y}=i(f);for(const A of y)if(isAudioNodeOutputConnection(A)){const T=a(A[0]);c(v,T,A[1],A[2])}else{const T=u(A[0]);v.connect(T,A[1])}}}else s.set(f,g-p)},DEFAULT_OPTIONS$a={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},createDelayNodeConstructor=(c,s,i,a,u,l,d)=>class extends c{constructor(f,p){const g=u(f),m={...DEFAULT_OPTIONS$a,...p},_=a(g,m),v=l(g),y=v?i(m.maxDelayTime):null;super(f,!1,_,y),this._delayTime=s(this,v,_.delayTime),d(this,m.maxDelayTime)}get delayTime(){return this._delayTime}},createDelayNodeRendererFactory=(c,s,i,a,u)=>l=>{const d=new WeakMap,h=async(f,p)=>{let g=i(f);const m=isOwnedByContext(g,p);if(!m){const _={channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,delayTime:g.delayTime.value,maxDelayTime:l};g=s(p,_)}return d.set(p,g),m?await c(p,f.delayTime,g.delayTime):await a(p,f.delayTime,g.delayTime),await u(f,p,g),g};return{render(f,p){const g=d.get(p);return g!==void 0?Promise.resolve(g):h(f,p)}}},createDeleteActiveInputConnectionToAudioNode=c=>(s,i,a,u)=>c(s[u],l=>l[0]===i&&l[1]===a),createDeleteUnrenderedAudioWorkletNode=c=>(s,i)=>{c(s).delete(i)},isDelayNode=c=>"delayTime"in c,createDetectCycles=(c,s,i)=>function a(u,l){const d=isAudioNode$1(l)?l:i(c,l);if(isDelayNode(d))return[];if(u[0]===d)return[u];if(u.includes(d))return[];const{outputs:h}=s(d);return Array.from(h).map(f=>a([...u,d],f[0])).reduce((f,p)=>f.concat(p),[])},getOutputAudioNodeAtIndex=(c,s,i)=>{const a=s[i];if(a===void 0)throw c();return a},createDisconnectMultipleOutputs=c=>(s,i=void 0,a=void 0,u=0)=>i===void 0?s.forEach(l=>l.disconnect()):typeof i=="number"?getOutputAudioNodeAtIndex(c,s,i).disconnect():isNativeAudioNode$1(i)?a===void 0?s.forEach(l=>l.disconnect(i)):u===void 0?getOutputAudioNodeAtIndex(c,s,a).disconnect(i,0):getOutputAudioNodeAtIndex(c,s,a).disconnect(i,0,u):a===void 0?s.forEach(l=>l.disconnect(i)):getOutputAudioNodeAtIndex(c,s,a).disconnect(i,0),DEFAULT_OPTIONS$9={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},createDynamicsCompressorNodeConstructor=(c,s,i,a,u,l,d,h)=>class extends c{constructor(p,g){const m=l(p),_={...DEFAULT_OPTIONS$9,...g},v=a(m,_),y=d(m),A=y?i():null;super(p,!1,v,A),this._attack=s(this,y,v.attack),this._knee=s(this,y,v.knee),this._nativeDynamicsCompressorNode=v,this._ratio=s(this,y,v.ratio),this._release=s(this,y,v.release),this._threshold=s(this,y,v.threshold),h(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(p){const g=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=p,p>2)throw this._nativeDynamicsCompressorNode.channelCount=g,u()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(p){const g=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=p,p==="max")throw this._nativeDynamicsCompressorNode.channelCountMode=g,u()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return typeof this._nativeDynamicsCompressorNode.reduction.value=="number"?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}},createDynamicsCompressorNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap,d=async(h,f)=>{let p=i(h);const g=isOwnedByContext(p,f);if(!g){const m={attack:p.attack.value,channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,knee:p.knee.value,ratio:p.ratio.value,release:p.release.value,threshold:p.threshold.value};p=s(f,m)}return l.set(f,p),g?(await c(f,h.attack,p.attack),await c(f,h.knee,p.knee),await c(f,h.ratio,p.ratio),await c(f,h.release,p.release),await c(f,h.threshold,p.threshold)):(await a(f,h.attack,p.attack),await a(f,h.knee,p.knee),await a(f,h.ratio,p.ratio),await a(f,h.release,p.release),await a(f,h.threshold,p.threshold)),await u(h,f,p),p};return{render(h,f){const p=l.get(f);return p!==void 0?Promise.resolve(p):d(h,f)}}},createEncodingError=()=>new DOMException("","EncodingError"),createEvaluateSource=c=>s=>new Promise((i,a)=>{if(c===null){a(new SyntaxError);return}const u=c.document.head;if(u===null)a(new SyntaxError);else{const l=c.document.createElement("script"),d=new Blob([s],{type:"application/javascript"}),h=URL.createObjectURL(d),f=c.onerror,p=()=>{c.onerror=f,URL.revokeObjectURL(h)};c.onerror=(g,m,_,v,y)=>{if(m===h||m===c.location.href&&_===1&&v===1)return p(),a(y),!1;if(f!==null)return f(g,m,_,v,y)},l.onerror=()=>{p(),a(new SyntaxError)},l.onload=()=>{p(),i()},l.src=h,l.type="module",u.appendChild(l)}}),createEventTargetConstructor=c=>class{constructor(i){this._nativeEventTarget=i,this._listeners=new WeakMap}addEventListener(i,a,u){if(a!==null){let l=this._listeners.get(a);l===void 0&&(l=c(this,a),typeof a=="function"&&this._listeners.set(a,l)),this._nativeEventTarget.addEventListener(i,l,u)}}dispatchEvent(i){return this._nativeEventTarget.dispatchEvent(i)}removeEventListener(i,a,u){const l=a===null?void 0:this._listeners.get(a);this._nativeEventTarget.removeEventListener(i,l===void 0?null:l,u)}},createExposeCurrentFrameAndCurrentTime=c=>(s,i,a)=>{Object.defineProperties(c,{currentFrame:{configurable:!0,get(){return Math.round(s*i)}},currentTime:{configurable:!0,get(){return s}}});try{return a()}finally{c!==null&&(delete c.currentFrame,delete c.currentTime)}},createFetchSource=c=>async s=>{try{const i=await fetch(s);if(i.ok)return[await i.text(),i.url]}catch{}throw c()},DEFAULT_OPTIONS$8={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},createGainNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=u(h),g={...DEFAULT_OPTIONS$8,...f},m=a(p,g),_=l(p),v=_?i():null;super(h,!1,m,v),this._gain=s(this,_,m.gain,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get gain(){return this._gain}},createGainNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap,d=async(h,f)=>{let p=i(h);const g=isOwnedByContext(p,f);if(!g){const m={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,gain:p.gain.value};p=s(f,m)}return l.set(f,p),g?await c(f,h.gain,p.gain):await a(f,h.gain,p.gain),await u(h,f,p),p};return{render(h,f){const p=l.get(f);return p!==void 0?Promise.resolve(p):d(h,f)}}},createGetActiveAudioWorkletNodeInputs=(c,s)=>i=>s(c,i),createGetAudioNodeRenderer=c=>s=>{const i=c(s);if(i.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return i.renderer},createGetAudioNodeTailTime=c=>s=>{var i;return(i=c.get(s))!==null&&i!==void 0?i:0},createGetAudioParamRenderer=c=>s=>{const i=c(s);if(i.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return i.renderer},createGetBackupOfflineAudioContext=c=>s=>c.get(s),createInvalidStateError=()=>new DOMException("","InvalidStateError"),createGetNativeContext=c=>s=>{const i=c.get(s);if(i===void 0)throw createInvalidStateError();return i},createGetOrCreateBackupOfflineAudioContext=(c,s)=>i=>{let a=c.get(i);if(a!==void 0)return a;if(s===null)throw new Error("Missing the native OfflineAudioContext constructor.");return a=new s(1,1,44100),c.set(i,a),a},createGetUnrenderedAudioWorkletNodes=c=>s=>{const i=c.get(s);if(i===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return i},createInvalidAccessError=()=>new DOMException("","InvalidAccessError"),wrapIIRFilterNodeGetFrequencyResponseMethod=c=>{c.getFrequencyResponse=(s=>(i,a,u)=>{if(i.length!==a.length||a.length!==u.length)throw createInvalidAccessError();return s.call(c,i,a,u)})(c.getFrequencyResponse)},DEFAULT_OPTIONS$7={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},createIIRFilterNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=a(h),g=u(p),m={...DEFAULT_OPTIONS$7,...f},_=s(p,g?null:h.baseLatency,m),v=g?i(m.feedback,m.feedforward):null;super(h,!1,_,v),wrapIIRFilterNodeGetFrequencyResponseMethod(_),this._nativeIIRFilterNode=_,l(this,1)}getFrequencyResponse(h,f,p){return this._nativeIIRFilterNode.getFrequencyResponse(h,f,p)}},filterBuffer=(c,s,i,a,u,l,d,h,f,p,g)=>{const m=p.length;let _=h;for(let v=0;v<m;v+=1){let y=i[0]*p[v];for(let A=1;A<u;A+=1){const T=_-A&f-1;y+=i[A]*l[T],y-=c[A]*d[T]}for(let A=u;A<a;A+=1)y+=i[A]*l[_-A&f-1];for(let A=u;A<s;A+=1)y-=c[A]*d[_-A&f-1];l[_]=p[v],d[_]=y,_=_+1&f-1,g[v]=y}return _},filterFullBuffer=(c,s,i,a)=>{const u=i instanceof Float64Array?i:new Float64Array(i),l=a instanceof Float64Array?a:new Float64Array(a),d=u.length,h=l.length,f=Math.min(d,h);if(u[0]!==1){for(let y=0;y<d;y+=1)l[y]/=u[0];for(let y=1;y<h;y+=1)u[y]/=u[0]}const p=32,g=new Float32Array(p),m=new Float32Array(p),_=s.createBuffer(c.numberOfChannels,c.length,c.sampleRate),v=c.numberOfChannels;for(let y=0;y<v;y+=1){const A=c.getChannelData(y),T=_.getChannelData(y);g.fill(0),m.fill(0),filterBuffer(u,d,l,h,f,g,m,0,p,A,T)}return _},createIIRFilterNodeRendererFactory=(c,s,i,a,u)=>(l,d)=>{const h=new WeakMap;let f=null;const p=async(g,m)=>{let _=null,v=s(g);const y=isOwnedByContext(v,m);if(m.createIIRFilter===void 0?_=c(m,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}):y||(v=m.createIIRFilter(d,l)),h.set(m,_===null?v:_),_!==null){if(f===null){if(i===null)throw new Error("Missing the native OfflineAudioContext constructor.");const T=new i(g.context.destination.channelCount,g.context.length,m.sampleRate);f=(async()=>{await a(g,T,T.destination);const x=await u(T);return filterFullBuffer(x,m,l,d)})()}const A=await f;return _.buffer=A,_.start(0),_}return await a(g,m,v),v};return{render(g,m){const _=h.get(m);return _!==void 0?Promise.resolve(_):p(g,m)}}},createIncrementCycleCounterFactory=(c,s,i,a,u,l)=>d=>(h,f)=>{const p=c.get(h);if(p===void 0){if(!d&&l(h)){const g=a(h),{outputs:m}=i(h);for(const _ of m)if(isAudioNodeOutputConnection(_)){const v=a(_[0]);s(g,v,_[1],_[2])}else{const v=u(_[0]);g.disconnect(v,_[1])}}c.set(h,f)}else c.set(h,p+f)},createIsAnyAudioContext=(c,s)=>i=>{const a=c.get(i);return s(a)||s(i)},createIsAnyAudioNode=(c,s)=>i=>c.has(i)||s(i),createIsAnyAudioParam=(c,s)=>i=>c.has(i)||s(i),createIsAnyOfflineAudioContext=(c,s)=>i=>{const a=c.get(i);return s(a)||s(i)},createIsNativeAudioContext=c=>s=>c!==null&&s instanceof c,createIsNativeAudioNode=c=>s=>c!==null&&typeof c.AudioNode=="function"&&s instanceof c.AudioNode,createIsNativeAudioParam=c=>s=>c!==null&&typeof c.AudioParam=="function"&&s instanceof c.AudioParam,createIsNativeContext=(c,s)=>i=>c(i)||s(i),createIsNativeOfflineAudioContext=c=>s=>c!==null&&s instanceof c,createIsSecureContext=c=>c!==null&&c.isSecureContext,createMediaElementAudioSourceNodeConstructor=(c,s,i,a)=>class extends c{constructor(l,d){const h=i(l),f=s(h,d);if(a(h))throw TypeError();super(l,!0,f,null),this._nativeMediaElementAudioSourceNode=f}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}},DEFAULT_OPTIONS$6={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},createMediaStreamAudioDestinationNodeConstructor=(c,s,i,a)=>class extends c{constructor(l,d){const h=i(l);if(a(h))throw new TypeError;const f={...DEFAULT_OPTIONS$6,...d},p=s(h,f);super(l,!1,p,null),this._nativeMediaStreamAudioDestinationNode=p}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}},createMediaStreamAudioSourceNodeConstructor=(c,s,i,a)=>class extends c{constructor(l,d){const h=i(l),f=s(h,d);if(a(h))throw new TypeError;super(l,!0,f,null),this._nativeMediaStreamAudioSourceNode=f}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}},createMediaStreamTrackAudioSourceNodeConstructor=(c,s,i)=>class extends c{constructor(u,l){const d=i(u),h=s(d,l);super(u,!0,h,null)}},createMinimalBaseAudioContextConstructor=(c,s,i,a,u,l)=>class extends i{constructor(h,f){super(h),this._nativeContext=h,CONTEXT_STORE.set(this,h),a(h)&&u.set(h,new Set),this._destination=new c(this,f),this._listener=s(this,h),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(h){const f=typeof h=="function"?l(this,h):null;this._nativeContext.onstatechange=f;const p=this._nativeContext.onstatechange;this._onstatechange=p!==null&&p===f?h:p}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}},testPromiseSupport=c=>{const s=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const i=c.decodeAudioData(s.buffer,()=>{});return i===void 0?!1:(i.catch(()=>{}),!0)}catch{}return!1},createMonitorConnections=(c,s)=>(i,a,u)=>{const l=new Set;return i.connect=(d=>(h,f=0,p=0)=>{const g=l.size===0;if(s(h))return d.call(i,h,f,p),c(l,[h,f,p],m=>m[0]===h&&m[1]===f&&m[2]===p,!0),g&&a(),h;d.call(i,h,f),c(l,[h,f],m=>m[0]===h&&m[1]===f,!0),g&&a()})(i.connect),i.disconnect=(d=>(h,f,p)=>{const g=l.size>0;if(h===void 0)d.apply(i),l.clear();else if(typeof h=="number"){d.call(i,h);for(const _ of l)_[1]===h&&l.delete(_)}else{s(h)?d.call(i,h,f,p):d.call(i,h,f);for(const _ of l)_[0]===h&&(f===void 0||_[1]===f)&&(p===void 0||_[2]===p)&&l.delete(_)}const m=l.size===0;g&&m&&u()})(i.disconnect),i},assignNativeAudioNodeOption=(c,s,i)=>{const a=s[i];a!==void 0&&a!==c[i]&&(c[i]=a)},assignNativeAudioNodeOptions=(c,s)=>{assignNativeAudioNodeOption(c,s,"channelCount"),assignNativeAudioNodeOption(c,s,"channelCountMode"),assignNativeAudioNodeOption(c,s,"channelInterpretation")},testAnalyserNodeGetFloatTimeDomainDataMethodSupport=c=>typeof c.getFloatTimeDomainData=="function",wrapAnalyserNodeGetFloatTimeDomainDataMethod=c=>{c.getFloatTimeDomainData=s=>{const i=new Uint8Array(s.length);c.getByteTimeDomainData(i);const a=Math.max(i.length,c.fftSize);for(let u=0;u<a;u+=1)s[u]=(i[u]-128)*.0078125;return s}},createNativeAnalyserNodeFactory=(c,s)=>(i,a)=>{const u=i.createAnalyser();if(assignNativeAudioNodeOptions(u,a),!(a.maxDecibels>a.minDecibels))throw s();return assignNativeAudioNodeOption(u,a,"fftSize"),assignNativeAudioNodeOption(u,a,"maxDecibels"),assignNativeAudioNodeOption(u,a,"minDecibels"),assignNativeAudioNodeOption(u,a,"smoothingTimeConstant"),c(testAnalyserNodeGetFloatTimeDomainDataMethodSupport,()=>testAnalyserNodeGetFloatTimeDomainDataMethodSupport(u))||wrapAnalyserNodeGetFloatTimeDomainDataMethod(u),u},createNativeAudioBufferConstructor=c=>c===null?null:c.hasOwnProperty("AudioBuffer")?c.AudioBuffer:null,assignNativeAudioNodeAudioParamValue=(c,s,i)=>{const a=s[i];a!==void 0&&a!==c[i].value&&(c[i].value=a)},wrapAudioBufferSourceNodeStartMethodConsecutiveCalls=c=>{c.start=(s=>{let i=!1;return(a=0,u=0,l)=>{if(i)throw createInvalidStateError();s.call(c,a,u,l),i=!0}})(c.start)},wrapAudioScheduledSourceNodeStartMethodNegativeParameters=c=>{c.start=(s=>(i=0,a=0,u)=>{if(typeof u=="number"&&u<0||a<0||i<0)throw new RangeError("The parameters can't be negative.");s.call(c,i,a,u)})(c.start)},wrapAudioScheduledSourceNodeStopMethodNegativeParameters=c=>{c.stop=(s=>(i=0)=>{if(i<0)throw new RangeError("The parameter can't be negative.");s.call(c,i)})(c.stop)},createNativeAudioBufferSourceNodeFactory=(c,s,i,a,u,l,d,h,f,p,g)=>(m,_)=>{const v=m.createBufferSource();return assignNativeAudioNodeOptions(v,_),assignNativeAudioNodeAudioParamValue(v,_,"playbackRate"),assignNativeAudioNodeOption(v,_,"buffer"),assignNativeAudioNodeOption(v,_,"loop"),assignNativeAudioNodeOption(v,_,"loopEnd"),assignNativeAudioNodeOption(v,_,"loopStart"),s(i,()=>i(m))||wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(v),s(a,()=>a(m))||f(v),s(u,()=>u(m))||p(v,m),s(l,()=>l(m))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(v),s(d,()=>d(m))||g(v,m),s(h,()=>h(m))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(v),c(m,v),v},createNativeAudioContextConstructor=c=>c===null?null:c.hasOwnProperty("AudioContext")?c.AudioContext:c.hasOwnProperty("webkitAudioContext")?c.webkitAudioContext:null,createNativeAudioDestinationNodeFactory=(c,s)=>(i,a,u)=>{const l=i.destination;if(l.channelCount!==a)try{l.channelCount=a}catch{}u&&l.channelCountMode!=="explicit"&&(l.channelCountMode="explicit"),l.maxChannelCount===0&&Object.defineProperty(l,"maxChannelCount",{value:a});const d=c(i,{channelCount:a,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,gain:1});return s(d,"channelCount",h=>()=>h.call(d),h=>f=>{h.call(d,f);try{l.channelCount=f}catch(p){if(f>l.maxChannelCount)throw p}}),s(d,"channelCountMode",h=>()=>h.call(d),h=>f=>{h.call(d,f),l.channelCountMode=f}),s(d,"channelInterpretation",h=>()=>h.call(d),h=>f=>{h.call(d,f),l.channelInterpretation=f}),Object.defineProperty(d,"maxChannelCount",{get:()=>l.maxChannelCount}),d.connect(l),d},createNativeAudioWorkletNodeConstructor=c=>c===null?null:c.hasOwnProperty("AudioWorkletNode")?c.AudioWorkletNode:null,testClonabilityOfAudioWorkletNodeOptions=c=>{const{port1:s}=new MessageChannel;try{s.postMessage(c)}finally{s.close()}},createNativeAudioWorkletNodeFactory=(c,s,i,a,u)=>(l,d,h,f,p,g)=>{if(h!==null)try{const m=new h(l,f,g),_=new Map;let v=null;if(Object.defineProperties(m,{channelCount:{get:()=>g.channelCount,set:()=>{throw c()}},channelCountMode:{get:()=>"explicit",set:()=>{throw c()}},onprocessorerror:{get:()=>v,set:y=>{typeof v=="function"&&m.removeEventListener("processorerror",v),v=typeof y=="function"?y:null,typeof v=="function"&&m.addEventListener("processorerror",v)}}}),m.addEventListener=(y=>(...A)=>{if(A[0]==="processorerror"){const T=typeof A[1]=="function"?A[1]:typeof A[1]=="object"&&A[1]!==null&&typeof A[1].handleEvent=="function"?A[1].handleEvent:null;if(T!==null){const x=_.get(A[1]);x!==void 0?A[1]=x:(A[1]=O=>{O.type==="error"?(Object.defineProperties(O,{type:{value:"processorerror"}}),T(O)):T(new ErrorEvent(A[0],{...O}))},_.set(T,A[1]))}}return y.call(m,"error",A[1],A[2]),y.call(m,...A)})(m.addEventListener),m.removeEventListener=(y=>(...A)=>{if(A[0]==="processorerror"){const T=_.get(A[1]);T!==void 0&&(_.delete(A[1]),A[1]=T)}return y.call(m,"error",A[1],A[2]),y.call(m,A[0],A[1],A[2])})(m.removeEventListener),g.numberOfOutputs!==0){const y=i(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return m.connect(y).connect(l.destination),u(m,()=>y.disconnect(),()=>y.connect(l.destination))}return m}catch(m){throw m.code===11?a():m}if(p===void 0)throw a();return testClonabilityOfAudioWorkletNodeOptions(g),s(l,d,p,g)},computeBufferSize=(c,s)=>c===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(c*s))))),cloneAudioWorkletNodeOptions=c=>new Promise((s,i)=>{const{port1:a,port2:u}=new MessageChannel;a.onmessage=({data:l})=>{a.close(),u.close(),s(l)},a.onmessageerror=({data:l})=>{a.close(),u.close(),i(l)},u.postMessage(c)}),createAudioWorkletProcessorPromise=async(c,s)=>{const i=await cloneAudioWorkletNodeOptions(s);return new c(i)},createAudioWorkletProcessor=(c,s,i,a)=>{let u=NODE_TO_PROCESSOR_MAPS.get(c);u===void 0&&(u=new WeakMap,NODE_TO_PROCESSOR_MAPS.set(c,u));const l=createAudioWorkletProcessorPromise(i,a);return u.set(s,l),l},createNativeAudioWorkletNodeFakerFactory=(c,s,i,a,u,l,d,h,f,p,g,m,_)=>(v,y,A,T)=>{if(T.numberOfInputs===0&&T.numberOfOutputs===0)throw f();const x=Array.isArray(T.outputChannelCount)?T.outputChannelCount:Array.from(T.outputChannelCount);if(x.some(B=>B<1))throw f();if(x.length!==T.numberOfOutputs)throw s();if(T.channelCountMode!=="explicit")throw f();const O=T.channelCount*T.numberOfInputs,E=x.reduce((B,G)=>B+G,0),b=A.parameterDescriptors===void 0?0:A.parameterDescriptors.length;if(O+b>6||E>6)throw f();const N=new MessageChannel,C=[],w=[];for(let B=0;B<T.numberOfInputs;B+=1)C.push(d(v,{channelCount:T.channelCount,channelCountMode:T.channelCountMode,channelInterpretation:T.channelInterpretation,gain:1})),w.push(u(v,{channelCount:T.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:T.channelCount}));const S=[];if(A.parameterDescriptors!==void 0)for(const{defaultValue:B,maxValue:G,minValue:J,name:Q}of A.parameterDescriptors){const X=l(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:T.parameterData[Q]!==void 0?T.parameterData[Q]:B===void 0?0:B});Object.defineProperties(X.offset,{defaultValue:{get:()=>B===void 0?0:B},maxValue:{get:()=>G===void 0?MOST_POSITIVE_SINGLE_FLOAT:G},minValue:{get:()=>J===void 0?MOST_NEGATIVE_SINGLE_FLOAT:J}}),S.push(X)}const M=a(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,O+b)}),P=computeBufferSize(y,v.sampleRate),I=h(v,P,O+b,Math.max(1,E)),k=u(v,{channelCount:Math.max(1,E),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,E)}),D=[];for(let B=0;B<T.numberOfOutputs;B+=1)D.push(a(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:x[B]}));for(let B=0;B<T.numberOfInputs;B+=1){C[B].connect(w[B]);for(let G=0;G<T.channelCount;G+=1)w[B].connect(M,G,B*T.channelCount+G)}const R=new ReadOnlyMap(A.parameterDescriptors===void 0?[]:A.parameterDescriptors.map(({name:B},G)=>{const J=S[G];return J.connect(M,0,O+G),J.start(0),[B,J.offset]}));M.connect(I);let z=T.channelInterpretation,V=null;const L=T.numberOfOutputs===0?[I]:D,$={get bufferSize(){return P},get channelCount(){return T.channelCount},set channelCount(B){throw i()},get channelCountMode(){return T.channelCountMode},set channelCountMode(B){throw i()},get channelInterpretation(){return z},set channelInterpretation(B){for(const G of C)G.channelInterpretation=B;z=B},get context(){return I.context},get inputs(){return C},get numberOfInputs(){return T.numberOfInputs},get numberOfOutputs(){return T.numberOfOutputs},get onprocessorerror(){return V},set onprocessorerror(B){typeof V=="function"&&$.removeEventListener("processorerror",V),V=typeof B=="function"?B:null,typeof V=="function"&&$.addEventListener("processorerror",V)},get parameters(){return R},get port(){return N.port2},addEventListener(...B){return I.addEventListener(B[0],B[1],B[2])},connect:c.bind(null,L),disconnect:p.bind(null,L),dispatchEvent(...B){return I.dispatchEvent(B[0])},removeEventListener(...B){return I.removeEventListener(B[0],B[1],B[2])}},q=new Map;N.port1.addEventListener=(B=>(...G)=>{if(G[0]==="message"){const J=typeof G[1]=="function"?G[1]:typeof G[1]=="object"&&G[1]!==null&&typeof G[1].handleEvent=="function"?G[1].handleEvent:null;if(J!==null){const Q=q.get(G[1]);Q!==void 0?G[1]=Q:(G[1]=X=>{g(v.currentTime,v.sampleRate,()=>J(X))},q.set(J,G[1]))}}return B.call(N.port1,G[0],G[1],G[2])})(N.port1.addEventListener),N.port1.removeEventListener=(B=>(...G)=>{if(G[0]==="message"){const J=q.get(G[1]);J!==void 0&&(q.delete(G[1]),G[1]=J)}return B.call(N.port1,G[0],G[1],G[2])})(N.port1.removeEventListener);let j=null;Object.defineProperty(N.port1,"onmessage",{get:()=>j,set:B=>{typeof j=="function"&&N.port1.removeEventListener("message",j),j=typeof B=="function"?B:null,typeof j=="function"&&(N.port1.addEventListener("message",j),N.port1.start())}}),A.prototype.port=N.port1;let U=null;createAudioWorkletProcessor(v,$,A,T).then(B=>U=B);const te=createNestedArrays(T.numberOfInputs,T.channelCount),ne=createNestedArrays(T.numberOfOutputs,x),Y=A.parameterDescriptors===void 0?[]:A.parameterDescriptors.reduce((B,{name:G})=>({...B,[G]:new Float32Array(128)}),{});let H=!0;const ee=()=>{T.numberOfOutputs>0&&I.disconnect(k);for(let B=0,G=0;B<T.numberOfOutputs;B+=1){const J=D[B];for(let Q=0;Q<x[B];Q+=1)k.disconnect(J,G+Q,Q);G+=x[B]}},W=new Map;I.onaudioprocess=({inputBuffer:B,outputBuffer:G})=>{if(U!==null){const J=m($);for(let Q=0;Q<P;Q+=128){for(let X=0;X<T.numberOfInputs;X+=1)for(let K=0;K<T.channelCount;K+=1)copyFromChannel(B,te[X],K,K,Q);A.parameterDescriptors!==void 0&&A.parameterDescriptors.forEach(({name:X},K)=>{copyFromChannel(B,Y,X,O+K,Q)});for(let X=0;X<T.numberOfInputs;X+=1)for(let K=0;K<x[X];K+=1)ne[X][K].byteLength===0&&(ne[X][K]=new Float32Array(128));try{const X=te.map((se,ie)=>{if(J[ie].size>0)return W.set(ie,P/128),se;const le=W.get(ie);return le===void 0?[]:(se.every(ge=>ge.every(_e=>_e===0))&&(le===1?W.delete(ie):W.set(ie,le-1)),se)});H=g(v.currentTime+Q/v.sampleRate,v.sampleRate,()=>U.process(X,ne,Y));for(let se=0,ie=0;se<T.numberOfOutputs;se+=1){for(let ue=0;ue<x[se];ue+=1)copyToChannel(G,ne[se],ue,ie+ue,Q);ie+=x[se]}}catch(X){H=!1,$.dispatchEvent(new ErrorEvent("processorerror",{colno:X.colno,filename:X.filename,lineno:X.lineno,message:X.message}))}if(!H){for(let X=0;X<T.numberOfInputs;X+=1){C[X].disconnect(w[X]);for(let K=0;K<T.channelCount;K+=1)w[Q].disconnect(M,K,X*T.channelCount+K)}if(A.parameterDescriptors!==void 0){const X=A.parameterDescriptors.length;for(let K=0;K<X;K+=1){const se=S[K];se.disconnect(M,0,O+K),se.stop()}}M.disconnect(I),I.onaudioprocess=null,re?ee():ce();break}}}};let re=!1;const oe=d(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),ae=()=>I.connect(oe).connect(v.destination),ce=()=>{I.disconnect(oe),oe.disconnect()},pe=()=>{if(H){ce(),T.numberOfOutputs>0&&I.connect(k);for(let B=0,G=0;B<T.numberOfOutputs;B+=1){const J=D[B];for(let Q=0;Q<x[B];Q+=1)k.connect(J,G+Q,Q);G+=x[B]}}re=!0},me=()=>{H&&(ae(),ee()),re=!1};return ae(),_($,pe,me)},createNativeBiquadFilterNode=(c,s)=>{const i=c.createBiquadFilter();return assignNativeAudioNodeOptions(i,s),assignNativeAudioNodeAudioParamValue(i,s,"Q"),assignNativeAudioNodeAudioParamValue(i,s,"detune"),assignNativeAudioNodeAudioParamValue(i,s,"frequency"),assignNativeAudioNodeAudioParamValue(i,s,"gain"),assignNativeAudioNodeOption(i,s,"type"),i},createNativeChannelMergerNodeFactory=(c,s)=>(i,a)=>{const u=i.createChannelMerger(a.numberOfInputs);return c!==null&&c.name==="webkitAudioContext"&&s(i,u),assignNativeAudioNodeOptions(u,a),u},wrapChannelSplitterNode=c=>{const s=c.numberOfOutputs;Object.defineProperty(c,"channelCount",{get:()=>s,set:i=>{if(i!==s)throw createInvalidStateError()}}),Object.defineProperty(c,"channelCountMode",{get:()=>"explicit",set:i=>{if(i!=="explicit")throw createInvalidStateError()}}),Object.defineProperty(c,"channelInterpretation",{get:()=>"discrete",set:i=>{if(i!=="discrete")throw createInvalidStateError()}})},createNativeChannelSplitterNode=(c,s)=>{const i=c.createChannelSplitter(s.numberOfOutputs);return assignNativeAudioNodeOptions(i,s),wrapChannelSplitterNode(i),i},createNativeConstantSourceNodeFactory=(c,s,i,a,u)=>(l,d)=>{if(l.createConstantSource===void 0)return i(l,d);const h=l.createConstantSource();return assignNativeAudioNodeOptions(h,d),assignNativeAudioNodeAudioParamValue(h,d,"offset"),s(a,()=>a(l))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(h),s(u,()=>u(l))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(h),c(l,h),h},interceptConnections=(c,s)=>(c.connect=s.connect.bind(s),c.disconnect=s.disconnect.bind(s),c),createNativeConstantSourceNodeFakerFactory=(c,s,i,a)=>(u,{offset:l,...d})=>{const h=u.createBuffer(1,2,44100),f=s(u,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),p=i(u,{...d,gain:l}),g=h.getChannelData(0);g[0]=1,g[1]=1,f.buffer=h,f.loop=!0;const m={get bufferSize(){},get channelCount(){return p.channelCount},set channelCount(y){p.channelCount=y},get channelCountMode(){return p.channelCountMode},set channelCountMode(y){p.channelCountMode=y},get channelInterpretation(){return p.channelInterpretation},set channelInterpretation(y){p.channelInterpretation=y},get context(){return p.context},get inputs(){return[]},get numberOfInputs(){return f.numberOfInputs},get numberOfOutputs(){return p.numberOfOutputs},get offset(){return p.gain},get onended(){return f.onended},set onended(y){f.onended=y},addEventListener(...y){return f.addEventListener(y[0],y[1],y[2])},dispatchEvent(...y){return f.dispatchEvent(y[0])},removeEventListener(...y){return f.removeEventListener(y[0],y[1],y[2])},start(y=0){f.start.call(f,y)},stop(y=0){f.stop.call(f,y)}},_=()=>f.connect(p),v=()=>f.disconnect(p);return c(u,f),a(interceptConnections(m,p),_,v)},createNativeConvolverNodeFactory=(c,s)=>(i,a)=>{const u=i.createConvolver();if(assignNativeAudioNodeOptions(u,a),a.disableNormalization===u.normalize&&(u.normalize=!a.disableNormalization),assignNativeAudioNodeOption(u,a,"buffer"),a.channelCount>2||(s(u,"channelCount",l=>()=>l.call(u),l=>d=>{if(d>2)throw c();return l.call(u,d)}),a.channelCountMode==="max"))throw c();return s(u,"channelCountMode",l=>()=>l.call(u),l=>d=>{if(d==="max")throw c();return l.call(u,d)}),u},createNativeDelayNode=(c,s)=>{const i=c.createDelay(s.maxDelayTime);return assignNativeAudioNodeOptions(i,s),assignNativeAudioNodeAudioParamValue(i,s,"delayTime"),i},createNativeDynamicsCompressorNodeFactory=c=>(s,i)=>{const a=s.createDynamicsCompressor();if(assignNativeAudioNodeOptions(a,i),i.channelCount>2||i.channelCountMode==="max")throw c();return assignNativeAudioNodeAudioParamValue(a,i,"attack"),assignNativeAudioNodeAudioParamValue(a,i,"knee"),assignNativeAudioNodeAudioParamValue(a,i,"ratio"),assignNativeAudioNodeAudioParamValue(a,i,"release"),assignNativeAudioNodeAudioParamValue(a,i,"threshold"),a},createNativeGainNode=(c,s)=>{const i=c.createGain();return assignNativeAudioNodeOptions(i,s),assignNativeAudioNodeAudioParamValue(i,s,"gain"),i},createNativeIIRFilterNodeFactory=c=>(s,i,a)=>{if(s.createIIRFilter===void 0)return c(s,i,a);const u=s.createIIRFilter(a.feedforward,a.feedback);return assignNativeAudioNodeOptions(u,a),u};function divide(c,s){const i=s[0]*s[0]+s[1]*s[1];return[(c[0]*s[0]+c[1]*s[1])/i,(c[1]*s[0]-c[0]*s[1])/i]}function multiply(c,s){return[c[0]*s[0]-c[1]*s[1],c[0]*s[1]+c[1]*s[0]]}function evaluatePolynomial(c,s){let i=[0,0];for(let a=c.length-1;a>=0;a-=1)i=multiply(i,s),i[0]+=c[a];return i}const createNativeIIRFilterNodeFakerFactory=(c,s,i,a)=>(u,l,{channelCount:d,channelCountMode:h,channelInterpretation:f,feedback:p,feedforward:g})=>{const m=computeBufferSize(l,u.sampleRate),_=p instanceof Float64Array?p:new Float64Array(p),v=g instanceof Float64Array?g:new Float64Array(g),y=_.length,A=v.length,T=Math.min(y,A);if(y===0||y>20)throw a();if(_[0]===0)throw s();if(A===0||A>20)throw a();if(v[0]===0)throw s();if(_[0]!==1){for(let S=0;S<A;S+=1)v[S]/=_[0];for(let S=1;S<y;S+=1)_[S]/=_[0]}const x=i(u,m,d,d);x.channelCount=d,x.channelCountMode=h,x.channelInterpretation=f;const O=32,E=[],b=[],N=[];for(let S=0;S<d;S+=1){E.push(0);const M=new Float32Array(O),P=new Float32Array(O);M.fill(0),P.fill(0),b.push(M),N.push(P)}x.onaudioprocess=S=>{const M=S.inputBuffer,P=S.outputBuffer,I=M.numberOfChannels;for(let k=0;k<I;k+=1){const D=M.getChannelData(k),R=P.getChannelData(k);E[k]=filterBuffer(_,y,v,A,T,b[k],N[k],E[k],O,D,R)}};const C=u.sampleRate/2;return interceptConnections({get bufferSize(){return m},get channelCount(){return x.channelCount},set channelCount(S){x.channelCount=S},get channelCountMode(){return x.channelCountMode},set channelCountMode(S){x.channelCountMode=S},get channelInterpretation(){return x.channelInterpretation},set channelInterpretation(S){x.channelInterpretation=S},get context(){return x.context},get inputs(){return[x]},get numberOfInputs(){return x.numberOfInputs},get numberOfOutputs(){return x.numberOfOutputs},addEventListener(...S){return x.addEventListener(S[0],S[1],S[2])},dispatchEvent(...S){return x.dispatchEvent(S[0])},getFrequencyResponse(S,M,P){if(S.length!==M.length||M.length!==P.length)throw c();const I=S.length;for(let k=0;k<I;k+=1){const D=-Math.PI*(S[k]/C),R=[Math.cos(D),Math.sin(D)],z=evaluatePolynomial(v,R),V=evaluatePolynomial(_,R),L=divide(z,V);M[k]=Math.sqrt(L[0]*L[0]+L[1]*L[1]),P[k]=Math.atan2(L[1],L[0])}},removeEventListener(...S){return x.removeEventListener(S[0],S[1],S[2])}},x)},createNativeMediaElementAudioSourceNode=(c,s)=>c.createMediaElementSource(s.mediaElement),createNativeMediaStreamAudioDestinationNode=(c,s)=>{const i=c.createMediaStreamDestination();return assignNativeAudioNodeOptions(i,s),i.numberOfOutputs===1&&Object.defineProperty(i,"numberOfOutputs",{get:()=>0}),i},createNativeMediaStreamAudioSourceNode=(c,{mediaStream:s})=>{const i=s.getAudioTracks();i.sort((l,d)=>l.id<d.id?-1:l.id>d.id?1:0);const a=i.slice(0,1),u=c.createMediaStreamSource(new MediaStream(a));return Object.defineProperty(u,"mediaStream",{value:s}),u},createNativeMediaStreamTrackAudioSourceNodeFactory=(c,s)=>(i,{mediaStreamTrack:a})=>{if(typeof i.createMediaStreamTrackSource=="function")return i.createMediaStreamTrackSource(a);const u=new MediaStream([a]),l=i.createMediaStreamSource(u);if(a.kind!=="audio")throw c();if(s(i))throw new TypeError;return l},createNativeOfflineAudioContextConstructor=c=>c===null?null:c.hasOwnProperty("OfflineAudioContext")?c.OfflineAudioContext:c.hasOwnProperty("webkitOfflineAudioContext")?c.webkitOfflineAudioContext:null,createNativeOscillatorNodeFactory=(c,s,i,a,u,l)=>(d,h)=>{const f=d.createOscillator();return assignNativeAudioNodeOptions(f,h),assignNativeAudioNodeAudioParamValue(f,h,"detune"),assignNativeAudioNodeAudioParamValue(f,h,"frequency"),h.periodicWave!==void 0?f.setPeriodicWave(h.periodicWave):assignNativeAudioNodeOption(f,h,"type"),s(i,()=>i(d))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(f),s(a,()=>a(d))||l(f,d),s(u,()=>u(d))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(f),c(d,f),f},createNativePannerNodeFactory=c=>(s,i)=>{const a=s.createPanner();return a.orientationX===void 0?c(s,i):(assignNativeAudioNodeOptions(a,i),assignNativeAudioNodeAudioParamValue(a,i,"orientationX"),assignNativeAudioNodeAudioParamValue(a,i,"orientationY"),assignNativeAudioNodeAudioParamValue(a,i,"orientationZ"),assignNativeAudioNodeAudioParamValue(a,i,"positionX"),assignNativeAudioNodeAudioParamValue(a,i,"positionY"),assignNativeAudioNodeAudioParamValue(a,i,"positionZ"),assignNativeAudioNodeOption(a,i,"coneInnerAngle"),assignNativeAudioNodeOption(a,i,"coneOuterAngle"),assignNativeAudioNodeOption(a,i,"coneOuterGain"),assignNativeAudioNodeOption(a,i,"distanceModel"),assignNativeAudioNodeOption(a,i,"maxDistance"),assignNativeAudioNodeOption(a,i,"panningModel"),assignNativeAudioNodeOption(a,i,"refDistance"),assignNativeAudioNodeOption(a,i,"rolloffFactor"),a)},createNativePannerNodeFakerFactory=(c,s,i,a,u,l,d,h,f,p)=>(g,{coneInnerAngle:m,coneOuterAngle:_,coneOuterGain:v,distanceModel:y,maxDistance:A,orientationX:T,orientationY:x,orientationZ:O,panningModel:E,positionX:b,positionY:N,positionZ:C,refDistance:w,rolloffFactor:S,...M})=>{const P=g.createPanner();if(M.channelCount>2||M.channelCountMode==="max")throw d();assignNativeAudioNodeOptions(P,M);const I={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},k=i(g,{...I,channelInterpretation:"speakers",numberOfInputs:6}),D=a(g,{...M,gain:1}),R=a(g,{...I,gain:1}),z=a(g,{...I,gain:0}),V=a(g,{...I,gain:0}),L=a(g,{...I,gain:0}),$=a(g,{...I,gain:0}),q=a(g,{...I,gain:0}),j=u(g,256,6,1),U=l(g,{...I,curve:new Float32Array([1,1]),oversample:"none"});let Z=[T,x,O],te=[b,N,C];const ne=new Float32Array(1);j.onaudioprocess=({inputBuffer:W})=>{const re=[f(W,ne,0),f(W,ne,1),f(W,ne,2)];re.some((ae,ce)=>ae!==Z[ce])&&(P.setOrientation(...re),Z=re);const oe=[f(W,ne,3),f(W,ne,4),f(W,ne,5)];oe.some((ae,ce)=>ae!==te[ce])&&(P.setPosition(...oe),te=oe)},Object.defineProperty(z.gain,"defaultValue",{get:()=>0}),Object.defineProperty(V.gain,"defaultValue",{get:()=>0}),Object.defineProperty(L.gain,"defaultValue",{get:()=>0}),Object.defineProperty($.gain,"defaultValue",{get:()=>0}),Object.defineProperty(q.gain,"defaultValue",{get:()=>0});const Y={get bufferSize(){},get channelCount(){return P.channelCount},set channelCount(W){if(W>2)throw d();D.channelCount=W,P.channelCount=W},get channelCountMode(){return P.channelCountMode},set channelCountMode(W){if(W==="max")throw d();D.channelCountMode=W,P.channelCountMode=W},get channelInterpretation(){return P.channelInterpretation},set channelInterpretation(W){D.channelInterpretation=W,P.channelInterpretation=W},get coneInnerAngle(){return P.coneInnerAngle},set coneInnerAngle(W){P.coneInnerAngle=W},get coneOuterAngle(){return P.coneOuterAngle},set coneOuterAngle(W){P.coneOuterAngle=W},get coneOuterGain(){return P.coneOuterGain},set coneOuterGain(W){if(W<0||W>1)throw s();P.coneOuterGain=W},get context(){return P.context},get distanceModel(){return P.distanceModel},set distanceModel(W){P.distanceModel=W},get inputs(){return[D]},get maxDistance(){return P.maxDistance},set maxDistance(W){if(W<0)throw new RangeError;P.maxDistance=W},get numberOfInputs(){return P.numberOfInputs},get numberOfOutputs(){return P.numberOfOutputs},get orientationX(){return R.gain},get orientationY(){return z.gain},get orientationZ(){return V.gain},get panningModel(){return P.panningModel},set panningModel(W){P.panningModel=W},get positionX(){return L.gain},get positionY(){return $.gain},get positionZ(){return q.gain},get refDistance(){return P.refDistance},set refDistance(W){if(W<0)throw new RangeError;P.refDistance=W},get rolloffFactor(){return P.rolloffFactor},set rolloffFactor(W){if(W<0)throw new RangeError;P.rolloffFactor=W},addEventListener(...W){return D.addEventListener(W[0],W[1],W[2])},dispatchEvent(...W){return D.dispatchEvent(W[0])},removeEventListener(...W){return D.removeEventListener(W[0],W[1],W[2])}};m!==Y.coneInnerAngle&&(Y.coneInnerAngle=m),_!==Y.coneOuterAngle&&(Y.coneOuterAngle=_),v!==Y.coneOuterGain&&(Y.coneOuterGain=v),y!==Y.distanceModel&&(Y.distanceModel=y),A!==Y.maxDistance&&(Y.maxDistance=A),T!==Y.orientationX.value&&(Y.orientationX.value=T),x!==Y.orientationY.value&&(Y.orientationY.value=x),O!==Y.orientationZ.value&&(Y.orientationZ.value=O),E!==Y.panningModel&&(Y.panningModel=E),b!==Y.positionX.value&&(Y.positionX.value=b),N!==Y.positionY.value&&(Y.positionY.value=N),C!==Y.positionZ.value&&(Y.positionZ.value=C),w!==Y.refDistance&&(Y.refDistance=w),S!==Y.rolloffFactor&&(Y.rolloffFactor=S),(Z[0]!==1||Z[1]!==0||Z[2]!==0)&&P.setOrientation(...Z),(te[0]!==0||te[1]!==0||te[2]!==0)&&P.setPosition(...te);const H=()=>{D.connect(P),c(D,U,0,0),U.connect(R).connect(k,0,0),U.connect(z).connect(k,0,1),U.connect(V).connect(k,0,2),U.connect(L).connect(k,0,3),U.connect($).connect(k,0,4),U.connect(q).connect(k,0,5),k.connect(j).connect(g.destination)},ee=()=>{D.disconnect(P),h(D,U,0,0),U.disconnect(R),R.disconnect(k),U.disconnect(z),z.disconnect(k),U.disconnect(V),V.disconnect(k),U.disconnect(L),L.disconnect(k),U.disconnect($),$.disconnect(k),U.disconnect(q),q.disconnect(k),k.disconnect(j),j.disconnect(g.destination)};return p(interceptConnections(Y,P),H,ee)},createNativePeriodicWaveFactory=c=>(s,{disableNormalization:i,imag:a,real:u})=>{const l=a instanceof Float32Array?a:new Float32Array(a),d=u instanceof Float32Array?u:new Float32Array(u),h=s.createPeriodicWave(d,l,{disableNormalization:i});if(Array.from(a).length<2)throw c();return h},createNativeScriptProcessorNode=(c,s,i,a)=>c.createScriptProcessor(s,i,a),createNativeStereoPannerNodeFactory=(c,s)=>(i,a)=>{const u=a.channelCountMode;if(u==="clamped-max")throw s();if(i.createStereoPanner===void 0)return c(i,a);const l=i.createStereoPanner();return assignNativeAudioNodeOptions(l,a),assignNativeAudioNodeAudioParamValue(l,a,"pan"),Object.defineProperty(l,"channelCountMode",{get:()=>u,set:d=>{if(d!==u)throw s()}}),l},createNativeStereoPannerNodeFakerFactory=(c,s,i,a,u,l)=>{const h=new Float32Array([1,1]),f=Math.PI/2,p={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},g={...p,oversample:"none"},m=(y,A,T,x)=>{const O=new Float32Array(16385),E=new Float32Array(16385);for(let M=0;M<16385;M+=1){const P=M/16384*f;O[M]=Math.cos(P),E[M]=Math.sin(P)}const b=i(y,{...p,gain:0}),N=a(y,{...g,curve:O}),C=a(y,{...g,curve:h}),w=i(y,{...p,gain:0}),S=a(y,{...g,curve:E});return{connectGraph(){A.connect(b),A.connect(C.inputs===void 0?C:C.inputs[0]),A.connect(w),C.connect(T),T.connect(N.inputs===void 0?N:N.inputs[0]),T.connect(S.inputs===void 0?S:S.inputs[0]),N.connect(b.gain),S.connect(w.gain),b.connect(x,0,0),w.connect(x,0,1)},disconnectGraph(){A.disconnect(b),A.disconnect(C.inputs===void 0?C:C.inputs[0]),A.disconnect(w),C.disconnect(T),T.disconnect(N.inputs===void 0?N:N.inputs[0]),T.disconnect(S.inputs===void 0?S:S.inputs[0]),N.disconnect(b.gain),S.disconnect(w.gain),b.disconnect(x,0,0),w.disconnect(x,0,1)}}},_=(y,A,T,x)=>{const O=new Float32Array(16385),E=new Float32Array(16385),b=new Float32Array(16385),N=new Float32Array(16385),C=Math.floor(16385/2);for(let L=0;L<16385;L+=1)if(L>C){const $=(L-C)/(16384-C)*f;O[L]=Math.cos($),E[L]=Math.sin($),b[L]=0,N[L]=1}else{const $=L/(16384-C)*f;O[L]=1,E[L]=0,b[L]=Math.cos($),N[L]=Math.sin($)}const w=s(y,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),S=i(y,{...p,gain:0}),M=a(y,{...g,curve:O}),P=i(y,{...p,gain:0}),I=a(y,{...g,curve:E}),k=a(y,{...g,curve:h}),D=i(y,{...p,gain:0}),R=a(y,{...g,curve:b}),z=i(y,{...p,gain:0}),V=a(y,{...g,curve:N});return{connectGraph(){A.connect(w),A.connect(k.inputs===void 0?k:k.inputs[0]),w.connect(S,0),w.connect(P,0),w.connect(D,1),w.connect(z,1),k.connect(T),T.connect(M.inputs===void 0?M:M.inputs[0]),T.connect(I.inputs===void 0?I:I.inputs[0]),T.connect(R.inputs===void 0?R:R.inputs[0]),T.connect(V.inputs===void 0?V:V.inputs[0]),M.connect(S.gain),I.connect(P.gain),R.connect(D.gain),V.connect(z.gain),S.connect(x,0,0),D.connect(x,0,0),P.connect(x,0,1),z.connect(x,0,1)},disconnectGraph(){A.disconnect(w),A.disconnect(k.inputs===void 0?k:k.inputs[0]),w.disconnect(S,0),w.disconnect(P,0),w.disconnect(D,1),w.disconnect(z,1),k.disconnect(T),T.disconnect(M.inputs===void 0?M:M.inputs[0]),T.disconnect(I.inputs===void 0?I:I.inputs[0]),T.disconnect(R.inputs===void 0?R:R.inputs[0]),T.disconnect(V.inputs===void 0?V:V.inputs[0]),M.disconnect(S.gain),I.disconnect(P.gain),R.disconnect(D.gain),V.disconnect(z.gain),S.disconnect(x,0,0),D.disconnect(x,0,0),P.disconnect(x,0,1),z.disconnect(x,0,1)}}},v=(y,A,T,x,O)=>{if(A===1)return m(y,T,x,O);if(A===2)return _(y,T,x,O);throw u()};return(y,{channelCount:A,channelCountMode:T,pan:x,...O})=>{if(T==="max")throw u();const E=c(y,{...O,channelCount:1,channelCountMode:T,numberOfInputs:2}),b=i(y,{...O,channelCount:A,channelCountMode:T,gain:1}),N=i(y,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:x});let{connectGraph:C,disconnectGraph:w}=v(y,A,b,N,E);Object.defineProperty(N.gain,"defaultValue",{get:()=>0}),Object.defineProperty(N.gain,"maxValue",{get:()=>1}),Object.defineProperty(N.gain,"minValue",{get:()=>-1});const S={get bufferSize(){},get channelCount(){return b.channelCount},set channelCount(k){b.channelCount!==k&&(M&&w(),{connectGraph:C,disconnectGraph:w}=v(y,k,b,N,E),M&&C()),b.channelCount=k},get channelCountMode(){return b.channelCountMode},set channelCountMode(k){if(k==="clamped-max"||k==="max")throw u();b.channelCountMode=k},get channelInterpretation(){return b.channelInterpretation},set channelInterpretation(k){b.channelInterpretation=k},get context(){return b.context},get inputs(){return[b]},get numberOfInputs(){return b.numberOfInputs},get numberOfOutputs(){return b.numberOfOutputs},get pan(){return N.gain},addEventListener(...k){return b.addEventListener(k[0],k[1],k[2])},dispatchEvent(...k){return b.dispatchEvent(k[0])},removeEventListener(...k){return b.removeEventListener(k[0],k[1],k[2])}};let M=!1;const P=()=>{C(),M=!0},I=()=>{w(),M=!1};return l(interceptConnections(S,E),P,I)}},createNativeWaveShaperNodeFactory=(c,s,i,a,u,l,d)=>(h,f)=>{const p=h.createWaveShaper();if(l!==null&&l.name==="webkitAudioContext"&&h.createGain().gain.automationRate===void 0)return i(h,f);assignNativeAudioNodeOptions(p,f);const g=f.curve===null||f.curve instanceof Float32Array?f.curve:new Float32Array(f.curve);if(g!==null&&g.length<2)throw s();assignNativeAudioNodeOption(p,{curve:g},"curve"),assignNativeAudioNodeOption(p,f,"oversample");let m=null,_=!1;return d(p,"curve",A=>()=>A.call(p),A=>T=>(A.call(p,T),_&&(a(T)&&m===null?m=c(h,p):!a(T)&&m!==null&&(m(),m=null)),T)),u(p,()=>{_=!0,a(p.curve)&&(m=c(h,p))},()=>{_=!1,m!==null&&(m(),m=null)})},createNativeWaveShaperNodeFakerFactory=(c,s,i,a,u)=>(l,{curve:d,oversample:h,...f})=>{const p=l.createWaveShaper(),g=l.createWaveShaper();assignNativeAudioNodeOptions(p,f),assignNativeAudioNodeOptions(g,f);const m=i(l,{...f,gain:1}),_=i(l,{...f,gain:-1}),v=i(l,{...f,gain:1}),y=i(l,{...f,gain:-1});let A=null,T=!1,x=null;const O={get bufferSize(){},get channelCount(){return p.channelCount},set channelCount(N){m.channelCount=N,_.channelCount=N,p.channelCount=N,v.channelCount=N,g.channelCount=N,y.channelCount=N},get channelCountMode(){return p.channelCountMode},set channelCountMode(N){m.channelCountMode=N,_.channelCountMode=N,p.channelCountMode=N,v.channelCountMode=N,g.channelCountMode=N,y.channelCountMode=N},get channelInterpretation(){return p.channelInterpretation},set channelInterpretation(N){m.channelInterpretation=N,_.channelInterpretation=N,p.channelInterpretation=N,v.channelInterpretation=N,g.channelInterpretation=N,y.channelInterpretation=N},get context(){return p.context},get curve(){return x},set curve(N){if(N!==null&&N.length<2)throw s();if(N===null)p.curve=N,g.curve=N;else{const C=N.length,w=new Float32Array(C+2-C%2),S=new Float32Array(C+2-C%2);w[0]=N[0],S[0]=-N[C-1];const M=Math.ceil((C+1)/2),P=(C+1)/2-1;for(let I=1;I<M;I+=1){const k=I/M*P,D=Math.floor(k),R=Math.ceil(k);w[I]=D===R?N[D]:(1-(k-D))*N[D]+(1-(R-k))*N[R],S[I]=D===R?-N[C-1-D]:-((1-(k-D))*N[C-1-D])-(1-(R-k))*N[C-1-R]}w[M]=C%2===1?N[M-1]:(N[M-2]+N[M-1])/2,p.curve=w,g.curve=S}x=N,T&&(a(x)&&A===null?A=c(l,m):A!==null&&(A(),A=null))},get inputs(){return[m]},get numberOfInputs(){return p.numberOfInputs},get numberOfOutputs(){return p.numberOfOutputs},get oversample(){return p.oversample},set oversample(N){p.oversample=N,g.oversample=N},addEventListener(...N){return m.addEventListener(N[0],N[1],N[2])},dispatchEvent(...N){return m.dispatchEvent(N[0])},removeEventListener(...N){return m.removeEventListener(N[0],N[1],N[2])}};d!==null&&(O.curve=d instanceof Float32Array?d:new Float32Array(d)),h!==O.oversample&&(O.oversample=h);const E=()=>{m.connect(p).connect(v),m.connect(_).connect(g).connect(y).connect(v),T=!0,a(x)&&(A=c(l,m))},b=()=>{m.disconnect(p),p.disconnect(v),m.disconnect(_),_.disconnect(g),g.disconnect(y),y.disconnect(v),T=!1,A!==null&&(A(),A=null)};return u(interceptConnections(O,v),E,b)},createNotSupportedError=()=>new DOMException("","NotSupportedError"),DEFAULT_OPTIONS$5={numberOfChannels:1},createOfflineAudioContextConstructor=(c,s,i,a,u)=>class extends c{constructor(d,h,f){let p;if(typeof d=="number"&&h!==void 0&&f!==void 0)p={length:h,numberOfChannels:d,sampleRate:f};else if(typeof d=="object")p=d;else throw new Error("The given parameters are not valid.");const{length:g,numberOfChannels:m,sampleRate:_}={...DEFAULT_OPTIONS$5,...p},v=a(m,g,_);s(testPromiseSupport,()=>testPromiseSupport(v))||v.addEventListener("statechange",(()=>{let y=0;const A=T=>{this._state==="running"&&(y>0?(v.removeEventListener("statechange",A),T.stopImmediatePropagation(),this._waitForThePromiseToSettle(T)):y+=1)};return A})()),super(v,m),this._length=g,this._nativeOfflineAudioContext=v,this._state=null}get length(){return this._nativeOfflineAudioContext.length===void 0?this._length:this._nativeOfflineAudioContext.length}get state(){return this._state===null?this._nativeOfflineAudioContext.state:this._state}startRendering(){return this._state==="running"?Promise.reject(i()):(this._state="running",u(this.destination,this._nativeOfflineAudioContext).finally(()=>{this._state=null,deactivateAudioGraph(this)}))}_waitForThePromiseToSettle(d){this._state===null?this._nativeOfflineAudioContext.dispatchEvent(d):setTimeout(()=>this._waitForThePromiseToSettle(d))}},DEFAULT_OPTIONS$4={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"},createOscillatorNodeConstructor=(c,s,i,a,u,l,d)=>class extends c{constructor(f,p){const g=u(f),m={...DEFAULT_OPTIONS$4,...p},_=i(g,m),v=l(g),y=v?a():null,A=f.sampleRate/2;super(f,!1,_,y),this._detune=s(this,v,_.detune,153600,-153600),this._frequency=s(this,v,_.frequency,A,-A),this._nativeOscillatorNode=_,this._onended=null,this._oscillatorNodeRenderer=y,this._oscillatorNodeRenderer!==null&&m.periodicWave!==void 0&&(this._oscillatorNodeRenderer.periodicWave=m.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(f){const p=typeof f=="function"?d(this,f):null;this._nativeOscillatorNode.onended=p;const g=this._nativeOscillatorNode.onended;this._onended=g!==null&&g===p?f:g}get type(){return this._nativeOscillatorNode.type}set type(f){this._nativeOscillatorNode.type=f,this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(f){this._nativeOscillatorNode.setPeriodicWave(f),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=f)}start(f=0){if(this._nativeOscillatorNode.start(f),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.start=f),this.context.state!=="closed"){setInternalStateToActive(this);const p=()=>{this._nativeOscillatorNode.removeEventListener("ended",p),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeOscillatorNode.addEventListener("ended",p)}}stop(f=0){this._nativeOscillatorNode.stop(f),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.stop=f)}},createOscillatorNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap;let d=null,h=null,f=null;const p=async(g,m)=>{let _=i(g);const v=isOwnedByContext(_,m);if(!v){const y={channelCount:_.channelCount,channelCountMode:_.channelCountMode,channelInterpretation:_.channelInterpretation,detune:_.detune.value,frequency:_.frequency.value,periodicWave:d===null?void 0:d,type:_.type};_=s(m,y),h!==null&&_.start(h),f!==null&&_.stop(f)}return l.set(m,_),v?(await c(m,g.detune,_.detune),await c(m,g.frequency,_.frequency)):(await a(m,g.detune,_.detune),await a(m,g.frequency,_.frequency)),await u(g,m,_),_};return{set periodicWave(g){d=g},set start(g){h=g},set stop(g){f=g},render(g,m){const _=l.get(m);return _!==void 0?Promise.resolve(_):p(g,m)}}},DEFAULT_OPTIONS$3={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},createPannerNodeConstructor=(c,s,i,a,u,l,d)=>class extends c{constructor(f,p){const g=u(f),m={...DEFAULT_OPTIONS$3,...p},_=i(g,m),v=l(g),y=v?a():null;super(f,!1,_,y),this._nativePannerNode=_,this._orientationX=s(this,v,_.orientationX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationY=s(this,v,_.orientationY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationZ=s(this,v,_.orientationZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionX=s(this,v,_.positionX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionY=s(this,v,_.positionY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionZ=s(this,v,_.positionZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),d(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(f){this._nativePannerNode.coneInnerAngle=f}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(f){this._nativePannerNode.coneOuterAngle=f}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(f){this._nativePannerNode.coneOuterGain=f}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(f){this._nativePannerNode.distanceModel=f}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(f){this._nativePannerNode.maxDistance=f}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(f){this._nativePannerNode.panningModel=f}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(f){this._nativePannerNode.refDistance=f}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(f){this._nativePannerNode.rolloffFactor=f}},createPannerNodeRendererFactory=(c,s,i,a,u,l,d,h,f,p)=>()=>{const g=new WeakMap;let m=null;const _=async(v,y)=>{let A=null,T=l(v);const x={channelCount:T.channelCount,channelCountMode:T.channelCountMode,channelInterpretation:T.channelInterpretation},O={...x,coneInnerAngle:T.coneInnerAngle,coneOuterAngle:T.coneOuterAngle,coneOuterGain:T.coneOuterGain,distanceModel:T.distanceModel,maxDistance:T.maxDistance,panningModel:T.panningModel,refDistance:T.refDistance,rolloffFactor:T.rolloffFactor},E=isOwnedByContext(T,y);if("bufferSize"in T)A=a(y,{...x,gain:1});else if(!E){const b={...O,orientationX:T.orientationX.value,orientationY:T.orientationY.value,orientationZ:T.orientationZ.value,positionX:T.positionX.value,positionY:T.positionY.value,positionZ:T.positionZ.value};T=u(y,b)}if(g.set(y,A===null?T:A),A!==null){if(m===null){if(d===null)throw new Error("Missing the native OfflineAudioContext constructor.");const I=new d(6,v.context.length,y.sampleRate),k=s(I,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});k.connect(I.destination),m=(async()=>{const D=await Promise.all([v.orientationX,v.orientationY,v.orientationZ,v.positionX,v.positionY,v.positionZ].map(async(R,z)=>{const V=i(I,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:z===0?1:0});return await h(I,R,V.offset),V}));for(let R=0;R<6;R+=1)D[R].connect(k,0,R),D[R].start(0);return p(I)})()}const b=await m,N=a(y,{...x,gain:1});await f(v,y,N);const C=[];for(let I=0;I<b.numberOfChannels;I+=1)C.push(b.getChannelData(I));let w=[C[0][0],C[1][0],C[2][0]],S=[C[3][0],C[4][0],C[5][0]],M=a(y,{...x,gain:1}),P=u(y,{...O,orientationX:w[0],orientationY:w[1],orientationZ:w[2],positionX:S[0],positionY:S[1],positionZ:S[2]});N.connect(M).connect(P.inputs[0]),P.connect(A);for(let I=128;I<b.length;I+=128){const k=[C[0][I],C[1][I],C[2][I]],D=[C[3][I],C[4][I],C[5][I]];if(k.some((R,z)=>R!==w[z])||D.some((R,z)=>R!==S[z])){w=k,S=D;const R=I/y.sampleRate;M.gain.setValueAtTime(0,R),M=a(y,{...x,gain:0}),P=u(y,{...O,orientationX:w[0],orientationY:w[1],orientationZ:w[2],positionX:S[0],positionY:S[1],positionZ:S[2]}),M.gain.setValueAtTime(1,R),N.connect(M).connect(P.inputs[0]),P.connect(A)}}return A}return E?(await c(y,v.orientationX,T.orientationX),await c(y,v.orientationY,T.orientationY),await c(y,v.orientationZ,T.orientationZ),await c(y,v.positionX,T.positionX),await c(y,v.positionY,T.positionY),await c(y,v.positionZ,T.positionZ)):(await h(y,v.orientationX,T.orientationX),await h(y,v.orientationY,T.orientationY),await h(y,v.orientationZ,T.orientationZ),await h(y,v.positionX,T.positionX),await h(y,v.positionY,T.positionY),await h(y,v.positionZ,T.positionZ)),isNativeAudioNodeFaker(T)?await f(v,y,T.inputs[0]):await f(v,y,T),T};return{render(v,y){const A=g.get(y);return A!==void 0?Promise.resolve(A):_(v,y)}}},DEFAULT_OPTIONS$2={disableNormalization:!1},createPeriodicWaveConstructor=(c,s,i,a)=>class fe{constructor(l,d){const h=s(l),f=a({...DEFAULT_OPTIONS$2,...d}),p=c(h,f);return i.add(p),p}static[Symbol.hasInstance](l){return l!==null&&typeof l=="object"&&Object.getPrototypeOf(l)===fe.prototype||i.has(l)}},createRenderAutomation=(c,s)=>(i,a,u)=>(c(a).replay(u),s(a,i,u)),createRenderInputsOfAudioNode=(c,s,i)=>async(a,u,l)=>{const d=c(a);await Promise.all(d.activeInputs.map((h,f)=>Array.from(h).map(async([p,g])=>{const _=await s(p).render(p,u),v=a.context.destination;!i(p)&&(a!==v||!i(a))&&_.connect(l,g,f)})).reduce((h,f)=>[...h,...f],[]))},createRenderInputsOfAudioParam=(c,s,i)=>async(a,u,l)=>{const d=s(a);await Promise.all(Array.from(d.activeInputs).map(async([h,f])=>{const g=await c(h).render(h,u);i(h)||g.connect(l,f)}))},createRenderNativeOfflineAudioContext=(c,s,i,a)=>u=>c(testPromiseSupport,()=>testPromiseSupport(u))?Promise.resolve(c(a,a)).then(l=>{if(!l){const d=i(u,512,0,1);u.oncomplete=()=>{d.onaudioprocess=null,d.disconnect()},d.onaudioprocess=()=>u.currentTime,d.connect(u.destination)}return u.startRendering()}):new Promise(l=>{const d=s(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});u.oncomplete=h=>{d.disconnect(),l(h.renderedBuffer)},d.connect(u.destination),u.startRendering()}),createSetActiveAudioWorkletNodeInputs=c=>(s,i)=>{c.set(s,i)},createSetAudioNodeTailTime=c=>(s,i)=>c.set(s,i),createStartRendering=(c,s,i,a,u,l,d,h)=>(f,p)=>i(f).render(f,p).then(()=>Promise.all(Array.from(a(p)).map(g=>i(g).render(g,p)))).then(()=>u(p)).then(g=>(typeof g.copyFromChannel!="function"?(d(g),wrapAudioBufferGetChannelDataMethod(g)):s(l,()=>l(g))||h(g),c.add(g),g)),DEFAULT_OPTIONS$1={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},createStereoPannerNodeConstructor=(c,s,i,a,u,l)=>class extends c{constructor(h,f){const p=u(h),g={...DEFAULT_OPTIONS$1,...f},m=i(p,g),_=l(p),v=_?a():null;super(h,!1,m,v),this._pan=s(this,_,m.pan)}get pan(){return this._pan}},createStereoPannerNodeRendererFactory=(c,s,i,a,u)=>()=>{const l=new WeakMap,d=async(h,f)=>{let p=i(h);const g=isOwnedByContext(p,f);if(!g){const m={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,pan:p.pan.value};p=s(f,m)}return l.set(f,p),g?await c(f,h.pan,p.pan):await a(f,h.pan,p.pan),isNativeAudioNodeFaker(p)?await u(h,f,p.inputs[0]):await u(h,f,p),p};return{render(h,f){const p=l.get(f);return p!==void 0?Promise.resolve(p):d(h,f)}}},createTestAudioBufferConstructorSupport=c=>()=>{if(c===null)return!1;try{new c({length:1,sampleRate:44100})}catch{return!1}return!0},createTestAudioWorkletProcessorPostMessageSupport=(c,s)=>async()=>{if(c===null)return!0;if(s===null)return!1;const i=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),a=new s(1,128,44100),u=URL.createObjectURL(i);let l=!1,d=!1;try{await a.audioWorklet.addModule(u);const h=new c(a,"a",{numberOfOutputs:0}),f=a.createOscillator();h.port.onmessage=()=>l=!0,h.onprocessorerror=()=>d=!0,f.connect(h),f.start(0),await a.startRendering()}catch{}finally{URL.revokeObjectURL(u)}return l&&!d},createTestOfflineAudioContextCurrentTimeSupport=(c,s)=>()=>{if(s===null)return Promise.resolve(!1);const i=new s(1,1,44100),a=c(i,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(u=>{i.oncomplete=()=>{a.disconnect(),u(i.currentTime!==0)},i.startRendering()})},createUnknownError=()=>new DOMException("","UnknownError"),DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},createWaveShaperNodeConstructor=(c,s,i,a,u,l,d)=>class extends c{constructor(f,p){const g=u(f),m={...DEFAULT_OPTIONS,...p},_=i(g,m),y=l(g)?a():null;super(f,!0,_,y),this._isCurveNullified=!1,this._nativeWaveShaperNode=_,d(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(f){if(f===null)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(f.length<2)throw s();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=f}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(f){this._nativeWaveShaperNode.oversample=f}},createWaveShaperNodeRendererFactory=(c,s,i)=>()=>{const a=new WeakMap,u=async(l,d)=>{let h=s(l);if(!isOwnedByContext(h,d)){const p={channelCount:h.channelCount,channelCountMode:h.channelCountMode,channelInterpretation:h.channelInterpretation,curve:h.curve,oversample:h.oversample};h=c(d,p)}return a.set(d,h),isNativeAudioNodeFaker(h)?await i(l,d,h.inputs[0]):await i(l,d,h),h};return{render(l,d){const h=a.get(d);return h!==void 0?Promise.resolve(h):u(l,d)}}},createWindow=()=>typeof window>"u"?null:window,createWrapAudioBufferCopyChannelMethods=(c,s)=>i=>{i.copyFromChannel=(a,u,l=0)=>{const d=c(l),h=c(u);if(h>=i.numberOfChannels)throw s();const f=i.length,p=i.getChannelData(h),g=a.length;for(let m=d<0?-d:0;m+d<f&&m<g;m+=1)a[m]=p[m+d]},i.copyToChannel=(a,u,l=0)=>{const d=c(l),h=c(u);if(h>=i.numberOfChannels)throw s();const f=i.length,p=i.getChannelData(h),g=a.length;for(let m=d<0?-d:0;m+d<f&&m<g;m+=1)p[m+d]=a[m]}},createWrapAudioBufferCopyChannelMethodsOutOfBounds=c=>s=>{s.copyFromChannel=(i=>(a,u,l=0)=>{const d=c(l),h=c(u);if(d<s.length)return i.call(s,a,h,d)})(s.copyFromChannel),s.copyToChannel=(i=>(a,u,l=0)=>{const d=c(l),h=c(u);if(d<s.length)return i.call(s,a,h,d)})(s.copyToChannel)},createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer=c=>(s,i)=>{const a=i.createBuffer(1,1,44100);s.buffer===null&&(s.buffer=a),c(s,"buffer",u=>()=>{const l=u.call(s);return l===a?null:l},u=>l=>u.call(s,l===null?a:l))},createWrapChannelMergerNode=(c,s)=>(i,a)=>{a.channelCount=1,a.channelCountMode="explicit",Object.defineProperty(a,"channelCount",{get:()=>1,set:()=>{throw c()}}),Object.defineProperty(a,"channelCountMode",{get:()=>"explicit",set:()=>{throw c()}});const u=i.createBufferSource();s(a,()=>{const h=a.numberOfInputs;for(let f=0;f<h;f+=1)u.connect(a,0,f)},()=>u.disconnect(a))},getFirstSample=(c,s,i)=>c.copyFromChannel===void 0?c.getChannelData(i)[0]:(c.copyFromChannel(s,i),s[0]),isDCCurve=c=>{if(c===null)return!1;const s=c.length;return s%2!==0?c[Math.floor(s/2)]!==0:c[s/2-1]+c[s/2]!==0},overwriteAccessors=(c,s,i,a)=>{let u=c;for(;!u.hasOwnProperty(s);)u=Object.getPrototypeOf(u);const{get:l,set:d}=Object.getOwnPropertyDescriptor(u,s);Object.defineProperty(c,s,{get:i(l),set:a(d)})},sanitizeAudioWorkletNodeOptions=c=>({...c,outputChannelCount:c.outputChannelCount!==void 0?c.outputChannelCount:c.numberOfInputs===1&&c.numberOfOutputs===1?[c.channelCount]:Array.from({length:c.numberOfOutputs},()=>1)}),sanitizeChannelSplitterOptions=c=>({...c,channelCount:c.numberOfOutputs}),sanitizePeriodicWaveOptions=c=>{const{imag:s,real:i}=c;return s===void 0?i===void 0?{...c,imag:[0,0],real:[0,0]}:{...c,imag:Array.from(i,()=>0),real:i}:i===void 0?{...c,imag:s,real:Array.from(s,()=>0)}:{...c,imag:s,real:i}},setValueAtTimeUntilPossible=(c,s,i)=>{try{c.setValueAtTime(s,i)}catch(a){if(a.code!==9)throw a;setValueAtTimeUntilPossible(c,s,i+1e-7)}},testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport=c=>{const s=c.createBufferSource();s.start();try{s.start()}catch{return!0}return!1},testAudioBufferSourceNodeStartMethodOffsetClampingSupport=c=>{const s=c.createBufferSource(),i=c.createBuffer(1,1,44100);s.buffer=i;try{s.start(0,1)}catch{return!1}return!0},testAudioBufferSourceNodeStopMethodNullifiedBufferSupport=c=>{const s=c.createBufferSource();s.start();try{s.stop()}catch{return!1}return!0},testAudioScheduledSourceNodeStartMethodNegativeParametersSupport=c=>{const s=c.createOscillator();try{s.start(-1)}catch(i){return i instanceof RangeError}return!1},testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport=c=>{const s=c.createBuffer(1,1,44100),i=c.createBufferSource();i.buffer=s,i.start(),i.stop();try{return i.stop(),!0}catch{return!1}},testAudioScheduledSourceNodeStopMethodNegativeParametersSupport=c=>{const s=c.createOscillator();try{s.stop(-1)}catch(i){return i instanceof RangeError}return!1},testAudioWorkletNodeOptionsClonability=c=>{const{port1:s,port2:i}=new MessageChannel;try{s.postMessage(c)}finally{s.close(),i.close()}},wrapAudioBufferSourceNodeStartMethodOffsetClamping=c=>{c.start=(s=>(i=0,a=0,u)=>{const l=c.buffer,d=l===null?a:Math.min(l.duration,a);l!==null&&d>l.duration-.5/c.context.sampleRate?s.call(c,i,0,0):s.call(c,i,d,u)})(c.start)},wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls=(c,s)=>{const i=s.createGain();c.connect(i);const a=(u=>()=>{u.call(c,i),c.removeEventListener("ended",a)})(c.disconnect);c.addEventListener("ended",a),interceptConnections(c,i),c.stop=(u=>{let l=!1;return(d=0)=>{if(l)try{u.call(c,d)}catch{i.gain.setValueAtTime(0,d)}else u.call(c,d),l=!0}})(c.stop)},wrapEventListener=(c,s)=>i=>{const a={value:c};return Object.defineProperties(i,{currentTarget:a,target:a}),typeof s=="function"?s.call(c,i):s.handleEvent.call(c,i)},addActiveInputConnectionToAudioNode=createAddActiveInputConnectionToAudioNode(insertElementInSet),addPassiveInputConnectionToAudioNode=createAddPassiveInputConnectionToAudioNode(insertElementInSet),deleteActiveInputConnectionToAudioNode=createDeleteActiveInputConnectionToAudioNode(pickElementFromSet),audioNodeTailTimeStore=new WeakMap,getAudioNodeTailTime=createGetAudioNodeTailTime(audioNodeTailTimeStore),cacheTestResult=createCacheTestResult(new Map,new WeakMap),window$1=createWindow(),createNativeAnalyserNode=createNativeAnalyserNodeFactory(cacheTestResult,createIndexSizeError),getAudioNodeRenderer=createGetAudioNodeRenderer(getAudioNodeConnections),renderInputsOfAudioNode=createRenderInputsOfAudioNode(getAudioNodeConnections,getAudioNodeRenderer,isPartOfACycle),createAnalyserNodeRenderer=createAnalyserNodeRendererFactory(createNativeAnalyserNode,getNativeAudioNode,renderInputsOfAudioNode),getNativeContext=createGetNativeContext(CONTEXT_STORE),nativeOfflineAudioContextConstructor=createNativeOfflineAudioContextConstructor(window$1),isNativeOfflineAudioContext=createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor),audioParamAudioNodeStore=new WeakMap,eventTargetConstructor=createEventTargetConstructor(wrapEventListener),nativeAudioContextConstructor=createNativeAudioContextConstructor(window$1),isNativeAudioContext=createIsNativeAudioContext(nativeAudioContextConstructor),isNativeAudioNode=createIsNativeAudioNode(window$1),isNativeAudioParam=createIsNativeAudioParam(window$1),nativeAudioWorkletNodeConstructor=createNativeAudioWorkletNodeConstructor(window$1),audioNodeConstructor=createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode,addPassiveInputConnectionToAudioNode,connectNativeAudioNodeToNativeAudioNode,deleteActiveInputConnectionToAudioNode,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getAudioNodeTailTime,getEventListenersOfAudioNode,getNativeAudioNode,insertElementInSet,isActiveAudioNode,isPartOfACycle,isPassiveAudioNode),cacheTestResult,createIncrementCycleCounterFactory(CYCLE_COUNTERS,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,isActiveAudioNode),createIndexSizeError,createInvalidAccessError,createNotSupportedError,createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode,CYCLE_COUNTERS,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,getNativeContext,isActiveAudioNode,isNativeOfflineAudioContext),createDetectCycles(audioParamAudioNodeStore,getAudioNodeConnections,getValueForKey),eventTargetConstructor,getNativeContext,isNativeAudioContext,isNativeAudioNode,isNativeAudioParam,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor),analyserNodeConstructor=createAnalyserNodeConstructor(audioNodeConstructor,createAnalyserNodeRenderer,createIndexSizeError,createNativeAnalyserNode,getNativeContext,isNativeOfflineAudioContext),audioBufferStore=new WeakSet,nativeAudioBufferConstructor=createNativeAudioBufferConstructor(window$1),convertNumberToUnsignedLong=createConvertNumberToUnsignedLong(new Uint32Array(1)),wrapAudioBufferCopyChannelMethods=createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong,createIndexSizeError),wrapAudioBufferCopyChannelMethodsOutOfBounds=createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong),audioBufferConstructor=createAudioBufferConstructor(audioBufferStore,cacheTestResult,createNotSupportedError,nativeAudioBufferConstructor,nativeOfflineAudioContextConstructor,createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),addSilentConnection=createAddSilentConnection(createNativeGainNode),renderInputsOfAudioParam=createRenderInputsOfAudioParam(getAudioNodeRenderer,getAudioParamConnections,isPartOfACycle),connectAudioParam=createConnectAudioParam(renderInputsOfAudioParam),createNativeAudioBufferSourceNode=createNativeAudioBufferSourceNodeFactory(addSilentConnection,cacheTestResult,testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,testAudioBufferSourceNodeStartMethodOffsetClampingSupport,testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioBufferSourceNodeStartMethodOffsetClamping,createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),renderAutomation=createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections),renderInputsOfAudioParam),createAudioBufferSourceNodeRenderer=createAudioBufferSourceNodeRendererFactory(connectAudioParam,createNativeAudioBufferSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),createAudioParam=createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),audioParamAudioNodeStore,AUDIO_PARAM_STORE,createAudioParamRenderer,createCancelAndHoldAutomationEvent,createCancelScheduledValuesAutomationEvent,createExponentialRampToValueAutomationEvent,createLinearRampToValueAutomationEvent,createSetTargetAutomationEvent,createSetValueAutomationEvent,createSetValueCurveAutomationEvent,nativeAudioContextConstructor,setValueAtTimeUntilPossible),audioBufferSourceNodeConstructor=createAudioBufferSourceNodeConstructor(audioNodeConstructor,createAudioBufferSourceNodeRenderer,createAudioParam,createInvalidStateError,createNativeAudioBufferSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),audioDestinationNodeConstructor=createAudioDestinationNodeConstructor(audioNodeConstructor,createAudioDestinationNodeRenderer,createIndexSizeError,createInvalidStateError,createNativeAudioDestinationNodeFactory(createNativeGainNode,overwriteAccessors),getNativeContext,isNativeOfflineAudioContext,renderInputsOfAudioNode),createBiquadFilterNodeRenderer=createBiquadFilterNodeRendererFactory(connectAudioParam,createNativeBiquadFilterNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),setAudioNodeTailTime=createSetAudioNodeTailTime(audioNodeTailTimeStore),biquadFilterNodeConstructor=createBiquadFilterNodeConstructor(audioNodeConstructor,createAudioParam,createBiquadFilterNodeRenderer,createInvalidAccessError,createNativeBiquadFilterNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),monitorConnections=createMonitorConnections(insertElementInSet,isNativeAudioNode),wrapChannelMergerNode=createWrapChannelMergerNode(createInvalidStateError,monitorConnections),createNativeChannelMergerNode=createNativeChannelMergerNodeFactory(nativeAudioContextConstructor,wrapChannelMergerNode),createChannelMergerNodeRenderer=createChannelMergerNodeRendererFactory(createNativeChannelMergerNode,getNativeAudioNode,renderInputsOfAudioNode),channelMergerNodeConstructor=createChannelMergerNodeConstructor(audioNodeConstructor,createChannelMergerNodeRenderer,createNativeChannelMergerNode,getNativeContext,isNativeOfflineAudioContext),createChannelSplitterNodeRenderer=createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode,getNativeAudioNode,renderInputsOfAudioNode),channelSplitterNodeConstructor=createChannelSplitterNodeConstructor(audioNodeConstructor,createChannelSplitterNodeRenderer,createNativeChannelSplitterNode,getNativeContext,isNativeOfflineAudioContext,sanitizeChannelSplitterOptions),createNativeConstantSourceNodeFaker=createNativeConstantSourceNodeFakerFactory(addSilentConnection,createNativeAudioBufferSourceNode,createNativeGainNode,monitorConnections),createNativeConstantSourceNode=createNativeConstantSourceNodeFactory(addSilentConnection,cacheTestResult,createNativeConstantSourceNodeFaker,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport),createConstantSourceNodeRenderer=createConstantSourceNodeRendererFactory(connectAudioParam,createNativeConstantSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),constantSourceNodeConstructor=createConstantSourceNodeConstructor(audioNodeConstructor,createAudioParam,createConstantSourceNodeRenderer,createNativeConstantSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createNativeConvolverNode=createNativeConvolverNodeFactory(createNotSupportedError,overwriteAccessors),createConvolverNodeRenderer=createConvolverNodeRendererFactory(createNativeConvolverNode,getNativeAudioNode,renderInputsOfAudioNode),convolverNodeConstructor=createConvolverNodeConstructor(audioNodeConstructor,createConvolverNodeRenderer,createNativeConvolverNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createDelayNodeRenderer=createDelayNodeRendererFactory(connectAudioParam,createNativeDelayNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),delayNodeConstructor=createDelayNodeConstructor(audioNodeConstructor,createAudioParam,createDelayNodeRenderer,createNativeDelayNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativeDynamicsCompressorNode=createNativeDynamicsCompressorNodeFactory(createNotSupportedError),createDynamicsCompressorNodeRenderer=createDynamicsCompressorNodeRendererFactory(connectAudioParam,createNativeDynamicsCompressorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),dynamicsCompressorNodeConstructor=createDynamicsCompressorNodeConstructor(audioNodeConstructor,createAudioParam,createDynamicsCompressorNodeRenderer,createNativeDynamicsCompressorNode,createNotSupportedError,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createGainNodeRenderer=createGainNodeRendererFactory(connectAudioParam,createNativeGainNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),gainNodeConstructor=createGainNodeConstructor(audioNodeConstructor,createAudioParam,createGainNodeRenderer,createNativeGainNode,getNativeContext,isNativeOfflineAudioContext),createNativeIIRFilterNodeFaker=createNativeIIRFilterNodeFakerFactory(createInvalidAccessError,createInvalidStateError,createNativeScriptProcessorNode,createNotSupportedError),renderNativeOfflineAudioContext=createRenderNativeOfflineAudioContext(cacheTestResult,createNativeGainNode,createNativeScriptProcessorNode,createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode,nativeOfflineAudioContextConstructor)),createIIRFilterNodeRenderer=createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderInputsOfAudioNode,renderNativeOfflineAudioContext),createNativeIIRFilterNode=createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker),iIRFilterNodeConstructor=createIIRFilterNodeConstructor(audioNodeConstructor,createNativeIIRFilterNode,createIIRFilterNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createAudioListener=createAudioListenerFactory(createAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeScriptProcessorNode,createNotSupportedError,getFirstSample,isNativeOfflineAudioContext,overwriteAccessors),unrenderedAudioWorkletNodeStore=new WeakMap,minimalBaseAudioContextConstructor=createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor,createAudioListener,eventTargetConstructor,isNativeOfflineAudioContext,unrenderedAudioWorkletNodeStore,wrapEventListener),createNativeOscillatorNode=createNativeOscillatorNodeFactory(addSilentConnection,cacheTestResult,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),createOscillatorNodeRenderer=createOscillatorNodeRendererFactory(connectAudioParam,createNativeOscillatorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),oscillatorNodeConstructor=createOscillatorNodeConstructor(audioNodeConstructor,createAudioParam,createNativeOscillatorNode,createOscillatorNodeRenderer,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createConnectedNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode),createNativeWaveShaperNodeFaker=createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeGainNode,isDCCurve,monitorConnections),createNativeWaveShaperNode=createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeWaveShaperNodeFaker,isDCCurve,monitorConnections,nativeAudioContextConstructor,overwriteAccessors),createNativePannerNodeFaker=createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode,createInvalidStateError,createNativeChannelMergerNode,createNativeGainNode,createNativeScriptProcessorNode,createNativeWaveShaperNode,createNotSupportedError,disconnectNativeAudioNodeFromNativeAudioNode,getFirstSample,monitorConnections),createNativePannerNode=createNativePannerNodeFactory(createNativePannerNodeFaker),createPannerNodeRenderer=createPannerNodeRendererFactory(connectAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeGainNode,createNativePannerNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),pannerNodeConstructor=createPannerNodeConstructor(audioNodeConstructor,createAudioParam,createNativePannerNode,createPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativePeriodicWave=createNativePeriodicWaveFactory(createIndexSizeError),periodicWaveConstructor=createPeriodicWaveConstructor(createNativePeriodicWave,getNativeContext,new WeakSet,sanitizePeriodicWaveOptions),nativeStereoPannerNodeFakerFactory=createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeGainNode,createNativeWaveShaperNode,createNotSupportedError,monitorConnections),createNativeStereoPannerNode=createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory,createNotSupportedError),createStereoPannerNodeRenderer=createStereoPannerNodeRendererFactory(connectAudioParam,createNativeStereoPannerNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),stereoPannerNodeConstructor=createStereoPannerNodeConstructor(audioNodeConstructor,createAudioParam,createNativeStereoPannerNode,createStereoPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext),createWaveShaperNodeRenderer=createWaveShaperNodeRendererFactory(createNativeWaveShaperNode,getNativeAudioNode,renderInputsOfAudioNode),waveShaperNodeConstructor=createWaveShaperNodeConstructor(audioNodeConstructor,createInvalidStateError,createNativeWaveShaperNode,createWaveShaperNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),isSecureContext=createIsSecureContext(window$1),exposeCurrentFrameAndCurrentTime=createExposeCurrentFrameAndCurrentTime(window$1),backupOfflineAudioContextStore=new WeakMap,getOrCreateBackupOfflineAudioContext=createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore,nativeOfflineAudioContextConstructor),addAudioWorkletModule=isSecureContext?createAddAudioWorkletModule(cacheTestResult,createNotSupportedError,createEvaluateSource(window$1),exposeCurrentFrameAndCurrentTime,createFetchSource(createAbortError),getNativeContext,getOrCreateBackupOfflineAudioContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,new WeakMap,new WeakMap,createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor),window$1):void 0,isNativeContext=createIsNativeContext(isNativeAudioContext,isNativeOfflineAudioContext),decodeAudioData=createDecodeAudioData(audioBufferStore,cacheTestResult,createDataCloneError,createEncodingError,new WeakSet,getNativeContext,isNativeContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,testPromiseSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),baseAudioContextConstructor=createBaseAudioContextConstructor(addAudioWorkletModule,analyserNodeConstructor,audioBufferConstructor,audioBufferSourceNodeConstructor,biquadFilterNodeConstructor,channelMergerNodeConstructor,channelSplitterNodeConstructor,constantSourceNodeConstructor,convolverNodeConstructor,decodeAudioData,delayNodeConstructor,dynamicsCompressorNodeConstructor,gainNodeConstructor,iIRFilterNodeConstructor,minimalBaseAudioContextConstructor,oscillatorNodeConstructor,pannerNodeConstructor,periodicWaveConstructor,stereoPannerNodeConstructor,waveShaperNodeConstructor),mediaElementAudioSourceNodeConstructor=createMediaElementAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaElementAudioSourceNode,getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioDestinationNodeConstructor=createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor,createNativeMediaStreamAudioDestinationNode,getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioSourceNodeConstructor=createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaStreamAudioSourceNode,getNativeContext,isNativeOfflineAudioContext),createNativeMediaStreamTrackAudioSourceNode=createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError,isNativeOfflineAudioContext),mediaStreamTrackAudioSourceNodeConstructor=createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaStreamTrackAudioSourceNode,getNativeContext),audioContextConstructor=createAudioContextConstructor(baseAudioContextConstructor,createInvalidStateError,createNotSupportedError,createUnknownError,mediaElementAudioSourceNodeConstructor,mediaStreamAudioDestinationNodeConstructor,mediaStreamAudioSourceNodeConstructor,mediaStreamTrackAudioSourceNodeConstructor,nativeAudioContextConstructor),getUnrenderedAudioWorkletNodes=createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore),addUnrenderedAudioWorkletNode=createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes),connectMultipleOutputs=createConnectMultipleOutputs(createIndexSizeError),deleteUnrenderedAudioWorkletNode=createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes),disconnectMultipleOutputs=createDisconnectMultipleOutputs(createIndexSizeError),activeAudioWorkletNodeInputsStore=new WeakMap,getActiveAudioWorkletNodeInputs=createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore,getValueForKey),createNativeAudioWorkletNodeFaker=createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs,createIndexSizeError,createInvalidStateError,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,createNativeScriptProcessorNode,createNotSupportedError,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getActiveAudioWorkletNodeInputs,monitorConnections),createNativeAudioWorkletNode=createNativeAudioWorkletNodeFactory(createInvalidStateError,createNativeAudioWorkletNodeFaker,createNativeGainNode,createNotSupportedError,monitorConnections),createAudioWorkletNodeRenderer=createAudioWorkletNodeRendererFactory(connectAudioParam,connectMultipleOutputs,createNativeAudioBufferSourceNode,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,deleteUnrenderedAudioWorkletNode,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getNativeAudioNode,nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),getBackupOfflineAudioContext=createGetBackupOfflineAudioContext(backupOfflineAudioContextStore),setActiveAudioWorkletNodeInputs=createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore),audioWorkletNodeConstructor=isSecureContext?createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode,audioNodeConstructor,createAudioParam,createAudioWorkletNodeRenderer,createNativeAudioWorkletNode,getAudioNodeConnections,getBackupOfflineAudioContext,getNativeContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,sanitizeAudioWorkletNodeOptions,setActiveAudioWorkletNodeInputs,testAudioWorkletNodeOptionsClonability,wrapEventListener):void 0,createNativeOfflineAudioContext=createCreateNativeOfflineAudioContext(createNotSupportedError,nativeOfflineAudioContextConstructor),startRendering=createStartRendering(audioBufferStore,cacheTestResult,getAudioNodeRenderer,getUnrenderedAudioWorkletNodes,renderNativeOfflineAudioContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),offlineAudioContextConstructor=createOfflineAudioContextConstructor(baseAudioContextConstructor,cacheTestResult,createInvalidStateError,createNativeOfflineAudioContext,startRendering),isAnyAudioContext=createIsAnyAudioContext(CONTEXT_STORE,isNativeAudioContext),isAnyAudioNode=createIsAnyAudioNode(AUDIO_NODE_STORE,isNativeAudioNode),isAnyAudioParam=createIsAnyAudioParam(AUDIO_PARAM_STORE,isNativeAudioParam),isAnyOfflineAudioContext=createIsAnyOfflineAudioContext(CONTEXT_STORE,isNativeOfflineAudioContext);function assert(c,s){if(!c)throw new Error(s)}function assertRange(c,s,i=1/0){if(!(s<=c&&c<=i))throw new RangeError(`Value must be within [${s}, ${i}], got: ${c}`)}function assertContextRunning(c){!c.isOffline&&c.state!=="running"&&warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')}let defaultLogger=console;function log(...c){defaultLogger.log(...c)}function warn(...c){defaultLogger.warn(...c)}function isUndef(c){return typeof c>"u"}function isDefined(c){return!isUndef(c)}function isFunction(c){return typeof c=="function"}function isNumber(c){return typeof c=="number"}function isObject(c){return Object.prototype.toString.call(c)==="[object Object]"&&c.constructor===Object}function isBoolean(c){return typeof c=="boolean"}function isArray(c){return Array.isArray(c)}function isString(c){return typeof c=="string"}function isNote(c){return isString(c)&&/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(c)}function createAudioContext(c){return new audioContextConstructor(c)}function createOfflineAudioContext(c,s,i){return new offlineAudioContextConstructor(c,s,i)}const theWindow=typeof self=="object"?self:null,hasAudioContext=theWindow&&(theWindow.hasOwnProperty("AudioContext")||theWindow.hasOwnProperty("webkitAudioContext"));function createAudioWorkletNode(c,s,i){return assert(isDefined(audioWorkletNodeConstructor),"This node only works in a secure context (https or localhost)"),new audioWorkletNodeConstructor(c,s,i)}function __decorate(c,s,i,a){var u=arguments.length,l=u<3?s:a===null?a=Object.getOwnPropertyDescriptor(s,i):a,d;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")l=Reflect.decorate(c,s,i,a);else for(var h=c.length-1;h>=0;h--)(d=c[h])&&(l=(u<3?d(l):u>3?d(s,i,l):d(s,i))||l);return u>3&&l&&Object.defineProperty(s,i,l),l}function __awaiter(c,s,i,a){function u(l){return l instanceof i?l:new i(function(d){d(l)})}return new(i||(i=Promise))(function(l,d){function h(g){try{p(a.next(g))}catch(m){d(m)}}function f(g){try{p(a.throw(g))}catch(m){d(m)}}function p(g){g.done?l(g.value):u(g.value).then(h,f)}p((a=a.apply(c,s||[])).next())})}class Ticker{constructor(s,i,a){this._callback=s,this._type=i,this._updateInterval=a,this._createClock()}_createWorker(){const s=new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{type:"text/javascript"}),i=URL.createObjectURL(s),a=new Worker(i);a.onmessage=this._callback.bind(this),this._worker=a}_createTimeout(){this._timeout=setTimeout(()=>{this._createTimeout(),this._callback()},this._updateInterval*1e3)}_createClock(){if(this._type==="worker")try{this._createWorker()}catch{this._type="timeout",this._createClock()}else this._type==="timeout"&&this._createTimeout()}_disposeClock(){this._timeout&&(clearTimeout(this._timeout),this._timeout=0),this._worker&&(this._worker.terminate(),this._worker.onmessage=null)}get updateInterval(){return this._updateInterval}set updateInterval(s){this._updateInterval=Math.max(s,128/44100),this._type==="worker"&&this._worker.postMessage(Math.max(s*1e3,1))}get type(){return this._type}set type(s){this._disposeClock(),this._type=s,this._createClock()}dispose(){this._disposeClock()}}function isAudioParam(c){return isAnyAudioParam(c)}function isAudioNode(c){return isAnyAudioNode(c)}function isOfflineAudioContext(c){return isAnyOfflineAudioContext(c)}function isAudioContext(c){return isAnyAudioContext(c)}function isAudioBuffer(c){return c instanceof AudioBuffer}function noCopy(c,s){return c==="value"||isAudioParam(s)||isAudioNode(s)||isAudioBuffer(s)}function deepMerge(c,...s){if(!s.length)return c;const i=s.shift();if(isObject(c)&&isObject(i))for(const a in i)noCopy(a,i[a])?c[a]=i[a]:isObject(i[a])?(c[a]||Object.assign(c,{[a]:{}}),deepMerge(c[a],i[a])):Object.assign(c,{[a]:i[a]});return deepMerge(c,...s)}function deepEquals(c,s){return c.length===s.length&&c.every((i,a)=>s[a]===i)}function optionsFromArguments(c,s,i=[],a){const u={},l=Array.from(s);if(isObject(l[0])&&a&&!Reflect.has(l[0],a)&&(Object.keys(l[0]).some(h=>Reflect.has(c,h))||(deepMerge(u,{[a]:l[0]}),i.splice(i.indexOf(a),1),l.shift())),l.length===1&&isObject(l[0]))deepMerge(u,l[0]);else for(let d=0;d<i.length;d++)isDefined(l[d])&&(u[i[d]]=l[d]);return deepMerge(c,u)}function getDefaultsFromInstance(c){return c.constructor.getDefaults()}function defaultArg(c,s){return isUndef(c)?s:c}function omitFromObject(c,s){return s.forEach(i=>{Reflect.has(c,i)&&delete c[i]}),c}/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */class Tone{constructor(){this.debug=!1,this._wasDisposed=!1}static getDefaults(){return{}}log(...s){(this.debug||theWindow&&this.toString()===theWindow.TONE_DEBUG_CLASS)&&log(this,...s)}dispose(){return this._wasDisposed=!0,this}get disposed(){return this._wasDisposed}toString(){return this.name}}Tone.version=version;const EPSILON=1e-6;function GT(c,s){return c>s+EPSILON}function GTE(c,s){return GT(c,s)||EQ(c,s)}function LT(c,s){return c+EPSILON<s}function EQ(c,s){return Math.abs(c-s)<EPSILON}function clamp(c,s,i){return Math.max(Math.min(c,i),s)}class Timeline extends Tone{constructor(){super(),this.name="Timeline",this._timeline=[];const s=optionsFromArguments(Timeline.getDefaults(),arguments,["memory"]);this.memory=s.memory,this.increasing=s.increasing}static getDefaults(){return{memory:1/0,increasing:!1}}get length(){return this._timeline.length}add(s){if(assert(Reflect.has(s,"time"),"Timeline: events must have a time attribute"),s.time=s.time.valueOf(),this.increasing&&this.length){const i=this._timeline[this.length-1];assert(GTE(s.time,i.time),"The time must be greater than or equal to the last scheduled time"),this._timeline.push(s)}else{const i=this._search(s.time);this._timeline.splice(i+1,0,s)}if(this.length>this.memory){const i=this.length-this.memory;this._timeline.splice(0,i)}return this}remove(s){const i=this._timeline.indexOf(s);return i!==-1&&this._timeline.splice(i,1),this}get(s,i="time"){const a=this._search(s,i);return a!==-1?this._timeline[a]:null}peek(){return this._timeline[0]}shift(){return this._timeline.shift()}getAfter(s,i="time"){const a=this._search(s,i);return a+1<this._timeline.length?this._timeline[a+1]:null}getBefore(s){const i=this._timeline.length;if(i>0&&this._timeline[i-1].time<s)return this._timeline[i-1];const a=this._search(s);return a-1>=0?this._timeline[a-1]:null}cancel(s){if(this._timeline.length>1){let i=this._search(s);if(i>=0)if(EQ(this._timeline[i].time,s)){for(let a=i;a>=0&&EQ(this._timeline[a].time,s);a--)i=a;this._timeline=this._timeline.slice(0,i)}else this._timeline=this._timeline.slice(0,i+1);else this._timeline=[]}else this._timeline.length===1&&GTE(this._timeline[0].time,s)&&(this._timeline=[]);return this}cancelBefore(s){const i=this._search(s);return i>=0&&(this._timeline=this._timeline.slice(i+1)),this}previousEvent(s){const i=this._timeline.indexOf(s);return i>0?this._timeline[i-1]:null}_search(s,i="time"){if(this._timeline.length===0)return-1;let a=0;const u=this._timeline.length;let l=u;if(u>0&&this._timeline[u-1][i]<=s)return u-1;for(;a<l;){let d=Math.floor(a+(l-a)/2);const h=this._timeline[d],f=this._timeline[d+1];if(EQ(h[i],s)){for(let p=d;p<this._timeline.length;p++){const g=this._timeline[p];if(EQ(g[i],s))d=p;else break}return d}else{if(LT(h[i],s)&&GT(f[i],s))return d;GT(h[i],s)?l=d:a=d+1}}return-1}_iterate(s,i=0,a=this._timeline.length-1){this._timeline.slice(i,a+1).forEach(s)}forEach(s){return this._iterate(s),this}forEachBefore(s,i){const a=this._search(s);return a!==-1&&this._iterate(i,0,a),this}forEachAfter(s,i){const a=this._search(s);return this._iterate(i,a+1),this}forEachBetween(s,i,a){let u=this._search(s),l=this._search(i);return u!==-1&&l!==-1?(this._timeline[u].time!==s&&(u+=1),this._timeline[l].time===i&&(l-=1),this._iterate(a,u,l)):u===-1&&this._iterate(a,0,l),this}forEachFrom(s,i){let a=this._search(s);for(;a>=0&&this._timeline[a].time>=s;)a--;return this._iterate(i,a+1),this}forEachAtTime(s,i){const a=this._search(s);if(a!==-1&&EQ(this._timeline[a].time,s)){let u=a;for(let l=a;l>=0&&EQ(this._timeline[l].time,s);l--)u=l;this._iterate(l=>{i(l)},u,a)}return this}dispose(){return super.dispose(),this._timeline=[],this}}const notifyNewContext=[];function onContextInit(c){notifyNewContext.push(c)}function initializeContext(c){notifyNewContext.forEach(s=>s(c))}const notifyCloseContext=[];function onContextClose(c){notifyCloseContext.push(c)}function closeContext(c){notifyCloseContext.forEach(s=>s(c))}class Emitter extends Tone{constructor(){super(...arguments),this.name="Emitter"}on(s,i){return s.split(/\W+/).forEach(u=>{isUndef(this._events)&&(this._events={}),this._events.hasOwnProperty(u)||(this._events[u]=[]),this._events[u].push(i)}),this}once(s,i){const a=(...u)=>{i(...u),this.off(s,a)};return this.on(s,a),this}off(s,i){return s.split(/\W+/).forEach(u=>{if(isUndef(this._events)&&(this._events={}),this._events.hasOwnProperty(s))if(isUndef(i))this._events[s]=[];else{const l=this._events[s];for(let d=l.length-1;d>=0;d--)l[d]===i&&l.splice(d,1)}}),this}emit(s,...i){if(this._events&&this._events.hasOwnProperty(s)){const a=this._events[s].slice(0);for(let u=0,l=a.length;u<l;u++)a[u].apply(this,i)}return this}static mixin(s){["on","once","off","emit"].forEach(i=>{const a=Object.getOwnPropertyDescriptor(Emitter.prototype,i);Object.defineProperty(s.prototype,i,a)})}dispose(){return super.dispose(),this._events=void 0,this}}class BaseContext extends Emitter{constructor(){super(...arguments),this.isOffline=!1}toJSON(){return{}}}class Context extends BaseContext{constructor(){super(),this.name="Context",this._constants=new Map,this._timeouts=new Timeline,this._timeoutIds=0,this._initialized=!1,this.isOffline=!1,this._workletModules=new Map;const s=optionsFromArguments(Context.getDefaults(),arguments,["context"]);s.context?this._context=s.context:this._context=createAudioContext({latencyHint:s.latencyHint}),this._ticker=new Ticker(this.emit.bind(this,"tick"),s.clockSource,s.updateInterval),this.on("tick",this._timeoutLoop.bind(this)),this._context.onstatechange=()=>{this.emit("statechange",this.state)},this._setLatencyHint(s.latencyHint),this.lookAhead=s.lookAhead}static getDefaults(){return{clockSource:"worker",latencyHint:"interactive",lookAhead:.1,updateInterval:.05}}initialize(){return this._initialized||(initializeContext(this),this._initialized=!0),this}createAnalyser(){return this._context.createAnalyser()}createOscillator(){return this._context.createOscillator()}createBufferSource(){return this._context.createBufferSource()}createBiquadFilter(){return this._context.createBiquadFilter()}createBuffer(s,i,a){return this._context.createBuffer(s,i,a)}createChannelMerger(s){return this._context.createChannelMerger(s)}createChannelSplitter(s){return this._context.createChannelSplitter(s)}createConstantSource(){return this._context.createConstantSource()}createConvolver(){return this._context.createConvolver()}createDelay(s){return this._context.createDelay(s)}createDynamicsCompressor(){return this._context.createDynamicsCompressor()}createGain(){return this._context.createGain()}createIIRFilter(s,i){return this._context.createIIRFilter(s,i)}createPanner(){return this._context.createPanner()}createPeriodicWave(s,i,a){return this._context.createPeriodicWave(s,i,a)}createStereoPanner(){return this._context.createStereoPanner()}createWaveShaper(){return this._context.createWaveShaper()}createMediaStreamSource(s){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamSource(s)}createMediaElementSource(s){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaElementSource(s)}createMediaStreamDestination(){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamDestination()}decodeAudioData(s){return this._context.decodeAudioData(s)}get currentTime(){return this._context.currentTime}get state(){return this._context.state}get sampleRate(){return this._context.sampleRate}get listener(){return this.initialize(),this._listener}set listener(s){assert(!this._initialized,"The listener cannot be set after initialization."),this._listener=s}get transport(){return this.initialize(),this._transport}set transport(s){assert(!this._initialized,"The transport cannot be set after initialization."),this._transport=s}get draw(){return this.initialize(),this._draw}set draw(s){assert(!this._initialized,"Draw cannot be set after initialization."),this._draw=s}get destination(){return this.initialize(),this._destination}set destination(s){assert(!this._initialized,"The destination cannot be set after initialization."),this._destination=s}createAudioWorkletNode(s,i){return createAudioWorkletNode(this.rawContext,s,i)}addAudioWorkletModule(s,i){return __awaiter(this,void 0,void 0,function*(){assert(isDefined(this.rawContext.audioWorklet),"AudioWorkletNode is only available in a secure context (https or localhost)"),this._workletModules.has(i)||this._workletModules.set(i,this.rawContext.audioWorklet.addModule(s)),yield this._workletModules.get(i)})}workletsAreReady(){return __awaiter(this,void 0,void 0,function*(){const s=[];this._workletModules.forEach(i=>s.push(i)),yield Promise.all(s)})}get updateInterval(){return this._ticker.updateInterval}set updateInterval(s){this._ticker.updateInterval=s}get clockSource(){return this._ticker.type}set clockSource(s){this._ticker.type=s}get latencyHint(){return this._latencyHint}_setLatencyHint(s){let i=0;if(this._latencyHint=s,isString(s))switch(s){case"interactive":i=.1;break;case"playback":i=.5;break;case"balanced":i=.25;break}this.lookAhead=i,this.updateInterval=i/2}get rawContext(){return this._context}now(){return this._context.currentTime+this.lookAhead}immediate(){return this._context.currentTime}resume(){return isAudioContext(this._context)?this._context.resume():Promise.resolve()}close(){return __awaiter(this,void 0,void 0,function*(){isAudioContext(this._context)&&(yield this._context.close()),this._initialized&&closeContext(this)})}getConstant(s){if(this._constants.has(s))return this._constants.get(s);{const i=this._context.createBuffer(1,128,this._context.sampleRate),a=i.getChannelData(0);for(let l=0;l<a.length;l++)a[l]=s;const u=this._context.createBufferSource();return u.channelCount=1,u.channelCountMode="explicit",u.buffer=i,u.loop=!0,u.start(0),this._constants.set(s,u),u}}dispose(){return super.dispose(),this._ticker.dispose(),this._timeouts.dispose(),Object.keys(this._constants).map(s=>this._constants[s].disconnect()),this}_timeoutLoop(){const s=this.now();let i=this._timeouts.peek();for(;this._timeouts.length&&i&&i.time<=s;)i.callback(),this._timeouts.shift(),i=this._timeouts.peek()}setTimeout(s,i){this._timeoutIds++;const a=this.now();return this._timeouts.add({callback:s,id:this._timeoutIds,time:a+i}),this._timeoutIds}clearTimeout(s){return this._timeouts.forEach(i=>{i.id===s&&this._timeouts.remove(i)}),this}clearInterval(s){return this.clearTimeout(s)}setInterval(s,i){const a=++this._timeoutIds,u=()=>{const l=this.now();this._timeouts.add({callback:()=>{s(),u()},id:a,time:l+i})};return u(),a}}class DummyContext extends BaseContext{constructor(){super(...arguments),this.lookAhead=0,this.latencyHint=0,this.isOffline=!1}createAnalyser(){return{}}createOscillator(){return{}}createBufferSource(){return{}}createBiquadFilter(){return{}}createBuffer(s,i,a){return{}}createChannelMerger(s){return{}}createChannelSplitter(s){return{}}createConstantSource(){return{}}createConvolver(){return{}}createDelay(s){return{}}createDynamicsCompressor(){return{}}createGain(){return{}}createIIRFilter(s,i){return{}}createPanner(){return{}}createPeriodicWave(s,i,a){return{}}createStereoPanner(){return{}}createWaveShaper(){return{}}createMediaStreamSource(s){return{}}createMediaElementSource(s){return{}}createMediaStreamDestination(){return{}}decodeAudioData(s){return Promise.resolve({})}createAudioWorkletNode(s,i){return{}}get rawContext(){return{}}addAudioWorkletModule(s,i){return __awaiter(this,void 0,void 0,function*(){return Promise.resolve()})}resume(){return Promise.resolve()}setTimeout(s,i){return 0}clearTimeout(s){return this}setInterval(s,i){return 0}clearInterval(s){return this}getConstant(s){return{}}get currentTime(){return 0}get state(){return{}}get sampleRate(){return 0}get listener(){return{}}get transport(){return{}}get draw(){return{}}set draw(s){}get destination(){return{}}set destination(s){}now(){return 0}immediate(){return 0}}function readOnly(c,s){isArray(s)?s.forEach(i=>readOnly(c,i)):Object.defineProperty(c,s,{enumerable:!0,writable:!1})}function writable(c,s){isArray(s)?s.forEach(i=>writable(c,i)):Object.defineProperty(c,s,{writable:!0})}const noOp=()=>{};class ToneAudioBuffer extends Tone{constructor(){super(),this.name="ToneAudioBuffer",this.onload=noOp;const s=optionsFromArguments(ToneAudioBuffer.getDefaults(),arguments,["url","onload","onerror"]);this.reverse=s.reverse,this.onload=s.onload,s.url&&isAudioBuffer(s.url)||s.url instanceof ToneAudioBuffer?this.set(s.url):isString(s.url)&&this.load(s.url).catch(s.onerror)}static getDefaults(){return{onerror:noOp,onload:noOp,reverse:!1}}get sampleRate(){return this._buffer?this._buffer.sampleRate:getContext().sampleRate}set(s){return s instanceof ToneAudioBuffer?s.loaded?this._buffer=s.get():s.onload=()=>{this.set(s),this.onload(this)}:this._buffer=s,this._reversed&&this._reverse(),this}get(){return this._buffer}load(s){return __awaiter(this,void 0,void 0,function*(){const i=ToneAudioBuffer.load(s).then(a=>{this.set(a),this.onload(this)});ToneAudioBuffer.downloads.push(i);try{yield i}finally{const a=ToneAudioBuffer.downloads.indexOf(i);ToneAudioBuffer.downloads.splice(a,1)}return this})}dispose(){return super.dispose(),this._buffer=void 0,this}fromArray(s){const i=isArray(s)&&s[0].length>0,a=i?s.length:1,u=i?s[0].length:s.length,l=getContext(),d=l.createBuffer(a,u,l.sampleRate),h=!i&&a===1?[s]:s;for(let f=0;f<a;f++)d.copyToChannel(h[f],f);return this._buffer=d,this}toMono(s){if(isNumber(s))this.fromArray(this.toArray(s));else{let i=new Float32Array(this.length);const a=this.numberOfChannels;for(let u=0;u<a;u++){const l=this.toArray(u);for(let d=0;d<l.length;d++)i[d]+=l[d]}i=i.map(u=>u/a),this.fromArray(i)}return this}toArray(s){if(isNumber(s))return this.getChannelData(s);if(this.numberOfChannels===1)return this.toArray(0);{const i=[];for(let a=0;a<this.numberOfChannels;a++)i[a]=this.getChannelData(a);return i}}getChannelData(s){return this._buffer?this._buffer.getChannelData(s):new Float32Array(0)}slice(s,i=this.duration){const a=Math.floor(s*this.sampleRate),u=Math.floor(i*this.sampleRate);assert(a<u,"The start time must be less than the end time");const l=u-a,d=getContext().createBuffer(this.numberOfChannels,l,this.sampleRate);for(let h=0;h<this.numberOfChannels;h++)d.copyToChannel(this.getChannelData(h).subarray(a,u),h);return new ToneAudioBuffer(d)}_reverse(){if(this.loaded)for(let s=0;s<this.numberOfChannels;s++)this.getChannelData(s).reverse();return this}get loaded(){return this.length>0}get duration(){return this._buffer?this._buffer.duration:0}get length(){return this._buffer?this._buffer.length:0}get numberOfChannels(){return this._buffer?this._buffer.numberOfChannels:0}get reverse(){return this._reversed}set reverse(s){this._reversed!==s&&(this._reversed=s,this._reverse())}static fromArray(s){return new ToneAudioBuffer().fromArray(s)}static fromUrl(s){return __awaiter(this,void 0,void 0,function*(){return yield new ToneAudioBuffer().load(s)})}static load(s){return __awaiter(this,void 0,void 0,function*(){const i=s.match(/\[([^\]\[]+\|.+)\]$/);if(i){const h=i[1].split("|");let f=h[0];for(const p of h)if(ToneAudioBuffer.supportsType(p)){f=p;break}s=s.replace(i[0],f)}const a=ToneAudioBuffer.baseUrl===""||ToneAudioBuffer.baseUrl.endsWith("/")?ToneAudioBuffer.baseUrl:ToneAudioBuffer.baseUrl+"/",u=yield fetch(a+s);if(!u.ok)throw new Error(`could not load url: ${s}`);const l=yield u.arrayBuffer();return yield getContext().decodeAudioData(l)})}static supportsType(s){const i=s.split("."),a=i[i.length-1];return document.createElement("audio").canPlayType("audio/"+a)!==""}static loaded(){return __awaiter(this,void 0,void 0,function*(){for(yield Promise.resolve();ToneAudioBuffer.downloads.length;)yield ToneAudioBuffer.downloads[0]})}}ToneAudioBuffer.baseUrl="";ToneAudioBuffer.downloads=[];class OfflineContext extends Context{constructor(){super({clockSource:"offline",context:isOfflineAudioContext(arguments[0])?arguments[0]:createOfflineAudioContext(arguments[0],arguments[1]*arguments[2],arguments[2]),lookAhead:0,updateInterval:isOfflineAudioContext(arguments[0])?128/arguments[0].sampleRate:128/arguments[2]}),this.name="OfflineContext",this._currentTime=0,this.isOffline=!0,this._duration=isOfflineAudioContext(arguments[0])?arguments[0].length/arguments[0].sampleRate:arguments[1]}now(){return this._currentTime}get currentTime(){return this._currentTime}_renderClock(s){return __awaiter(this,void 0,void 0,function*(){let i=0;for(;this._duration-this._currentTime>=0;){this.emit("tick"),this._currentTime+=128/this.sampleRate,i++;const a=Math.floor(this.sampleRate/128);s&&i%a===0&&(yield new Promise(u=>setTimeout(u,1)))}})}render(s=!0){return __awaiter(this,void 0,void 0,function*(){yield this.workletsAreReady(),yield this._renderClock(s);const i=yield this._context.startRendering();return new ToneAudioBuffer(i)})}close(){return Promise.resolve()}}const dummyContext=new DummyContext;let globalContext=dummyContext;function getContext(){return globalContext===dummyContext&&hasAudioContext&&setContext(new Context),globalContext}function setContext(c){isAudioContext(c)?globalContext=new Context(c):isOfflineAudioContext(c)?globalContext=new OfflineContext(c):globalContext=c}if(theWindow&&!theWindow.TONE_SILENCE_LOGGING){const s=` * Tone.js v${version} * `;console.log(`%c${s}`,"background: #000; color: #fff")}function dbToGain(c){return Math.pow(10,c/20)}function gainToDb(c){return 20*(Math.log(c)/Math.LN10)}function intervalToFrequencyRatio(c){return Math.pow(2,c/12)}let A4=440;function getA4(){return A4}function setA4(c){A4=c}function ftom(c){return Math.round(ftomf(c))}function ftomf(c){return 69+12*Math.log2(c/A4)}function mtof(c){return A4*Math.pow(2,(c-69)/12)}class TimeBaseClass extends Tone{constructor(s,i,a){super(),this.defaultUnits="s",this._val=i,this._units=a,this.context=s,this._expressions=this._getExpressions()}_getExpressions(){return{hz:{method:s=>this._frequencyToUnits(parseFloat(s)),regexp:/^(\d+(?:\.\d+)?)hz$/i},i:{method:s=>this._ticksToUnits(parseInt(s,10)),regexp:/^(\d+)i$/i},m:{method:s=>this._beatsToUnits(parseInt(s,10)*this._getTimeSignature()),regexp:/^(\d+)m$/i},n:{method:(s,i)=>{const a=parseInt(s,10),u=i==="."?1.5:1;return a===1?this._beatsToUnits(this._getTimeSignature())*u:this._beatsToUnits(4/a)*u},regexp:/^(\d+)n(\.?)$/i},number:{method:s=>this._expressions[this.defaultUnits].method.call(this,s),regexp:/^(\d+(?:\.\d+)?)$/},s:{method:s=>this._secondsToUnits(parseFloat(s)),regexp:/^(\d+(?:\.\d+)?)s$/},samples:{method:s=>parseInt(s,10)/this.context.sampleRate,regexp:/^(\d+)samples$/},t:{method:s=>{const i=parseInt(s,10);return this._beatsToUnits(8/(Math.floor(i)*3))},regexp:/^(\d+)t$/i},tr:{method:(s,i,a)=>{let u=0;return s&&s!=="0"&&(u+=this._beatsToUnits(this._getTimeSignature()*parseFloat(s))),i&&i!=="0"&&(u+=this._beatsToUnits(parseFloat(i))),a&&a!=="0"&&(u+=this._beatsToUnits(parseFloat(a)/4)),u},regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/}}}valueOf(){if(this._val instanceof TimeBaseClass&&this.fromType(this._val),isUndef(this._val))return this._noArg();if(isString(this._val)&&isUndef(this._units)){for(const s in this._expressions)if(this._expressions[s].regexp.test(this._val.trim())){this._units=s;break}}else if(isObject(this._val)){let s=0;for(const i in this._val)if(isDefined(this._val[i])){const a=this._val[i],u=new this.constructor(this.context,i).valueOf()*a;s+=u}return s}if(isDefined(this._units)){const s=this._expressions[this._units],i=this._val.toString().trim().match(s.regexp);return i?s.method.apply(this,i.slice(1)):s.method.call(this,this._val)}else return isString(this._val)?parseFloat(this._val):this._val}_frequencyToUnits(s){return 1/s}_beatsToUnits(s){return 60/this._getBpm()*s}_secondsToUnits(s){return s}_ticksToUnits(s){return s*this._beatsToUnits(1)/this._getPPQ()}_noArg(){return this._now()}_getBpm(){return this.context.transport.bpm.value}_getTimeSignature(){return this.context.transport.timeSignature}_getPPQ(){return this.context.transport.PPQ}fromType(s){switch(this._units=void 0,this.defaultUnits){case"s":this._val=s.toSeconds();break;case"i":this._val=s.toTicks();break;case"hz":this._val=s.toFrequency();break;case"midi":this._val=s.toMidi();break}return this}toFrequency(){return 1/this.toSeconds()}toSamples(){return this.toSeconds()*this.context.sampleRate}toMilliseconds(){return this.toSeconds()*1e3}}class TimeClass extends TimeBaseClass{constructor(){super(...arguments),this.name="TimeClass"}_getExpressions(){return Object.assign(super._getExpressions(),{now:{method:s=>this._now()+new this.constructor(this.context,s).valueOf(),regexp:/^\+(.+)/},quantize:{method:s=>{const i=new TimeClass(this.context,s).valueOf();return this._secondsToUnits(this.context.transport.nextSubdivision(i))},regexp:/^@(.+)/}})}quantize(s,i=1){const a=new this.constructor(this.context,s).valueOf(),u=this.valueOf(),h=Math.round(u/a)*a-u;return u+h*i}toNotation(){const s=this.toSeconds(),i=["1m"];for(let l=1;l<9;l++){const d=Math.pow(2,l);i.push(d+"n."),i.push(d+"n"),i.push(d+"t")}i.push("0");let a=i[0],u=new TimeClass(this.context,i[0]).toSeconds();return i.forEach(l=>{const d=new TimeClass(this.context,l).toSeconds();Math.abs(d-s)<Math.abs(u-s)&&(a=l,u=d)}),a}toBarsBeatsSixteenths(){const s=this._beatsToUnits(1);let i=this.valueOf()/s;i=parseFloat(i.toFixed(4));const a=Math.floor(i/this._getTimeSignature());let u=i%1*4;i=Math.floor(i)%this._getTimeSignature();const l=u.toString();return l.length>3&&(u=parseFloat(parseFloat(l).toFixed(3))),[a,i,u].join(":")}toTicks(){const s=this._beatsToUnits(1),i=this.valueOf()/s;return Math.round(i*this._getPPQ())}toSeconds(){return this.valueOf()}toMidi(){return ftom(this.toFrequency())}_now(){return this.context.now()}}class FrequencyClass extends TimeClass{constructor(){super(...arguments),this.name="Frequency",this.defaultUnits="hz"}static get A4(){return getA4()}static set A4(s){setA4(s)}_getExpressions(){return Object.assign({},super._getExpressions(),{midi:{regexp:/^(\d+(?:\.\d+)?midi)/,method(s){return this.defaultUnits==="midi"?s:FrequencyClass.mtof(s)}},note:{regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method(s,i){const u=noteToScaleIndex[s.toLowerCase()]+(parseInt(i,10)+1)*12;return this.defaultUnits==="midi"?u:FrequencyClass.mtof(u)}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method(s,i,a){let u=1;return s&&s!=="0"&&(u*=this._beatsToUnits(this._getTimeSignature()*parseFloat(s))),i&&i!=="0"&&(u*=this._beatsToUnits(parseFloat(i))),a&&a!=="0"&&(u*=this._beatsToUnits(parseFloat(a)/4)),u}}})}transpose(s){return new FrequencyClass(this.context,this.valueOf()*intervalToFrequencyRatio(s))}harmonize(s){return s.map(i=>this.transpose(i))}toMidi(){return ftom(this.valueOf())}toNote(){const s=this.toFrequency(),i=Math.log2(s/FrequencyClass.A4);let a=Math.round(12*i)+57;const u=Math.floor(a/12);return u<0&&(a+=-12*u),scaleIndexToNote[a%12]+u.toString()}toSeconds(){return 1/super.toSeconds()}toTicks(){const s=this._beatsToUnits(1),i=this.valueOf()/s;return Math.floor(i*this._getPPQ())}_noArg(){return 0}_frequencyToUnits(s){return s}_ticksToUnits(s){return 1/(s*60/(this._getBpm()*this._getPPQ()))}_beatsToUnits(s){return 1/super._beatsToUnits(s)}_secondsToUnits(s){return 1/s}static mtof(s){return mtof(s)}static ftom(s){return ftom(s)}}const noteToScaleIndex={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},scaleIndexToNote=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];class TransportTimeClass extends TimeClass{constructor(){super(...arguments),this.name="TransportTime"}_now(){return this.context.transport.seconds}}class ToneWithContext extends Tone{constructor(){super();const s=optionsFromArguments(ToneWithContext.getDefaults(),arguments,["context"]);this.defaultContext?this.context=this.defaultContext:this.context=s.context}static getDefaults(){return{context:getContext()}}now(){return this.context.currentTime+this.context.lookAhead}immediate(){return this.context.currentTime}get sampleTime(){return 1/this.context.sampleRate}get blockTime(){return 128/this.context.sampleRate}toSeconds(s){return new TimeClass(this.context,s).toSeconds()}toFrequency(s){return new FrequencyClass(this.context,s).toFrequency()}toTicks(s){return new TransportTimeClass(this.context,s).toTicks()}_getPartialProperties(s){const i=this.get();return Object.keys(i).forEach(a=>{isUndef(s[a])&&delete i[a]}),i}get(){const s=getDefaultsFromInstance(this);return Object.keys(s).forEach(i=>{if(Reflect.has(this,i)){const a=this[i];isDefined(a)&&isDefined(a.value)&&isDefined(a.setValueAtTime)?s[i]=a.value:a instanceof ToneWithContext?s[i]=a._getPartialProperties(s[i]):isArray(a)||isNumber(a)||isString(a)||isBoolean(a)?s[i]=a:delete s[i]}}),s}set(s){return Object.keys(s).forEach(i=>{Reflect.has(this,i)&&isDefined(this[i])&&(this[i]&&isDefined(this[i].value)&&isDefined(this[i].setValueAtTime)?this[i].value!==s[i]&&(this[i].value=s[i]):this[i]instanceof ToneWithContext?this[i].set(s[i]):this[i]=s[i])}),this}}class StateTimeline extends Timeline{constructor(s="stopped"){super(),this.name="StateTimeline",this._initial=s,this.setStateAtTime(this._initial,0)}getValueAtTime(s){const i=this.get(s);return i!==null?i.state:this._initial}setStateAtTime(s,i,a){return assertRange(i,0),this.add(Object.assign({},a,{state:s,time:i})),this}getLastState(s,i){const a=this._search(i);for(let u=a;u>=0;u--){const l=this._timeline[u];if(l.state===s)return l}}getNextState(s,i){const a=this._search(i);if(a!==-1)for(let u=a;u<this._timeline.length;u++){const l=this._timeline[u];if(l.state===s)return l}}}class Param extends ToneWithContext{constructor(){super(optionsFromArguments(Param.getDefaults(),arguments,["param","units","convert"])),this.name="Param",this.overridden=!1,this._minOutput=1e-7;const s=optionsFromArguments(Param.getDefaults(),arguments,["param","units","convert"]);for(assert(isDefined(s.param)&&(isAudioParam(s.param)||s.param instanceof Param),"param must be an AudioParam");!isAudioParam(s.param);)s.param=s.param._param;this._swappable=isDefined(s.swappable)?s.swappable:!1,this._swappable?(this.input=this.context.createGain(),this._param=s.param,this.input.connect(this._param)):this._param=this.input=s.param,this._events=new Timeline(1e3),this._initialValue=this._param.defaultValue,this.units=s.units,this.convert=s.convert,this._minValue=s.minValue,this._maxValue=s.maxValue,isDefined(s.value)&&s.value!==this._toType(this._initialValue)&&this.setValueAtTime(s.value,0)}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{convert:!0,units:"number"})}get value(){const s=this.now();return this.getValueAtTime(s)}set value(s){this.cancelScheduledValues(this.now()),this.setValueAtTime(s,this.now())}get minValue(){return isDefined(this._minValue)?this._minValue:this.units==="time"||this.units==="frequency"||this.units==="normalRange"||this.units==="positive"||this.units==="transportTime"||this.units==="ticks"||this.units==="bpm"||this.units==="hertz"||this.units==="samples"?0:this.units==="audioRange"?-1:this.units==="decibels"?-1/0:this._param.minValue}get maxValue(){return isDefined(this._maxValue)?this._maxValue:this.units==="normalRange"||this.units==="audioRange"?1:this._param.maxValue}_is(s,i){return this.units===i}_assertRange(s){return isDefined(this.maxValue)&&isDefined(this.minValue)&&assertRange(s,this._fromType(this.minValue),this._fromType(this.maxValue)),s}_fromType(s){return this.convert&&!this.overridden?this._is(s,"time")?this.toSeconds(s):this._is(s,"decibels")?dbToGain(s):this._is(s,"frequency")?this.toFrequency(s):s:this.overridden?0:s}_toType(s){return this.convert&&this.units==="decibels"?gainToDb(s):s}setValueAtTime(s,i){const a=this.toSeconds(i),u=this._fromType(s);return assert(isFinite(u)&&isFinite(a),`Invalid argument(s) to setValueAtTime: ${JSON.stringify(s)}, ${JSON.stringify(i)}`),this._assertRange(u),this.log(this.units,"setValueAtTime",s,a),this._events.add({time:a,type:"setValueAtTime",value:u}),this._param.setValueAtTime(u,a),this}getValueAtTime(s){const i=Math.max(this.toSeconds(s),0),a=this._events.getAfter(i),u=this._events.get(i);let l=this._initialValue;if(u===null)l=this._initialValue;else if(u.type==="setTargetAtTime"&&(a===null||a.type==="setValueAtTime")){const d=this._events.getBefore(u.time);let h;d===null?h=this._initialValue:h=d.value,u.type==="setTargetAtTime"&&(l=this._exponentialApproach(u.time,h,u.value,u.constant,i))}else if(a===null)l=u.value;else if(a.type==="linearRampToValueAtTime"||a.type==="exponentialRampToValueAtTime"){let d=u.value;if(u.type==="setTargetAtTime"){const h=this._events.getBefore(u.time);h===null?d=this._initialValue:d=h.value}a.type==="linearRampToValueAtTime"?l=this._linearInterpolate(u.time,d,a.time,a.value,i):l=this._exponentialInterpolate(u.time,d,a.time,a.value,i)}else l=u.value;return this._toType(l)}setRampPoint(s){s=this.toSeconds(s);let i=this.getValueAtTime(s);return this.cancelAndHoldAtTime(s),this._fromType(i)===0&&(i=this._toType(this._minOutput)),this.setValueAtTime(i,s),this}linearRampToValueAtTime(s,i){const a=this._fromType(s),u=this.toSeconds(i);return assert(isFinite(a)&&isFinite(u),`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(s)}, ${JSON.stringify(i)}`),this._assertRange(a),this._events.add({time:u,type:"linearRampToValueAtTime",value:a}),this.log(this.units,"linearRampToValueAtTime",s,u),this._param.linearRampToValueAtTime(a,u),this}exponentialRampToValueAtTime(s,i){let a=this._fromType(s);a=EQ(a,0)?this._minOutput:a,this._assertRange(a);const u=this.toSeconds(i);return assert(isFinite(a)&&isFinite(u),`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(s)}, ${JSON.stringify(i)}`),this._events.add({time:u,type:"exponentialRampToValueAtTime",value:a}),this.log(this.units,"exponentialRampToValueAtTime",s,u),this._param.exponentialRampToValueAtTime(a,u),this}exponentialRampTo(s,i,a){return a=this.toSeconds(a),this.setRampPoint(a),this.exponentialRampToValueAtTime(s,a+this.toSeconds(i)),this}linearRampTo(s,i,a){return a=this.toSeconds(a),this.setRampPoint(a),this.linearRampToValueAtTime(s,a+this.toSeconds(i)),this}targetRampTo(s,i,a){return a=this.toSeconds(a),this.setRampPoint(a),this.exponentialApproachValueAtTime(s,a,i),this}exponentialApproachValueAtTime(s,i,a){i=this.toSeconds(i),a=this.toSeconds(a);const u=Math.log(a+1)/Math.log(200);return this.setTargetAtTime(s,i,u),this.cancelAndHoldAtTime(i+a*.9),this.linearRampToValueAtTime(s,i+a),this}setTargetAtTime(s,i,a){const u=this._fromType(s);assert(isFinite(a)&&a>0,"timeConstant must be a number greater than 0");const l=this.toSeconds(i);return this._assertRange(u),assert(isFinite(u)&&isFinite(l),`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(s)}, ${JSON.stringify(i)}`),this._events.add({constant:a,time:l,type:"setTargetAtTime",value:u}),this.log(this.units,"setTargetAtTime",s,l,a),this._param.setTargetAtTime(u,l,a),this}setValueCurveAtTime(s,i,a,u=1){a=this.toSeconds(a),i=this.toSeconds(i);const l=this._fromType(s[0])*u;this.setValueAtTime(this._toType(l),i);const d=a/(s.length-1);for(let h=1;h<s.length;h++){const f=this._fromType(s[h])*u;this.linearRampToValueAtTime(this._toType(f),i+h*d)}return this}cancelScheduledValues(s){const i=this.toSeconds(s);return assert(isFinite(i),`Invalid argument to cancelScheduledValues: ${JSON.stringify(s)}`),this._events.cancel(i),this._param.cancelScheduledValues(i),this.log(this.units,"cancelScheduledValues",i),this}cancelAndHoldAtTime(s){const i=this.toSeconds(s),a=this._fromType(this.getValueAtTime(i));assert(isFinite(i),`Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(s)}`),this.log(this.units,"cancelAndHoldAtTime",i,"value="+a);const u=this._events.get(i),l=this._events.getAfter(i);return u&&EQ(u.time,i)?l?(this._param.cancelScheduledValues(l.time),this._events.cancel(l.time)):(this._param.cancelAndHoldAtTime(i),this._events.cancel(i+this.sampleTime)):l&&(this._param.cancelScheduledValues(l.time),this._events.cancel(l.time),l.type==="linearRampToValueAtTime"?this.linearRampToValueAtTime(this._toType(a),i):l.type==="exponentialRampToValueAtTime"&&this.exponentialRampToValueAtTime(this._toType(a),i)),this._events.add({time:i,type:"setValueAtTime",value:a}),this._param.setValueAtTime(a,i),this}rampTo(s,i=.1,a){return this.units==="frequency"||this.units==="bpm"||this.units==="decibels"?this.exponentialRampTo(s,i,a):this.linearRampTo(s,i,a),this}apply(s){const i=this.context.currentTime;s.setValueAtTime(this.getValueAtTime(i),i);const a=this._events.get(i);if(a&&a.type==="setTargetAtTime"){const u=this._events.getAfter(a.time),l=u?u.time:i+2,d=(l-i)/10;for(let h=i;h<l;h+=d)s.linearRampToValueAtTime(this.getValueAtTime(h),h)}return this._events.forEachAfter(this.context.currentTime,u=>{u.type==="cancelScheduledValues"?s.cancelScheduledValues(u.time):u.type==="setTargetAtTime"?s.setTargetAtTime(u.value,u.time,u.constant):s[u.type](u.value,u.time)}),this}setParam(s){assert(this._swappable,"The Param must be assigned as 'swappable' in the constructor");const i=this.input;return i.disconnect(this._param),this.apply(s),this._param=s,i.connect(this._param),this}dispose(){return super.dispose(),this._events.dispose(),this}get defaultValue(){return this._toType(this._param.defaultValue)}_exponentialApproach(s,i,a,u,l){return a+(i-a)*Math.exp(-(l-s)/u)}_linearInterpolate(s,i,a,u,l){return i+(u-i)*((l-s)/(a-s))}_exponentialInterpolate(s,i,a,u,l){return i*Math.pow(u/i,(l-s)/(a-s))}}class ToneAudioNode extends ToneWithContext{constructor(){super(...arguments),this.name="ToneAudioNode",this._internalChannels=[]}get numberOfInputs(){return isDefined(this.input)?isAudioParam(this.input)||this.input instanceof Param?1:this.input.numberOfInputs:0}get numberOfOutputs(){return isDefined(this.output)?this.output.numberOfOutputs:0}_isAudioNode(s){return isDefined(s)&&(s instanceof ToneAudioNode||isAudioNode(s))}_getInternalNodes(){const s=this._internalChannels.slice(0);return this._isAudioNode(this.input)&&s.push(this.input),this._isAudioNode(this.output)&&this.input!==this.output&&s.push(this.output),s}_setChannelProperties(s){this._getInternalNodes().forEach(a=>{a.channelCount=s.channelCount,a.channelCountMode=s.channelCountMode,a.channelInterpretation=s.channelInterpretation})}_getChannelProperties(){const s=this._getInternalNodes();assert(s.length>0,"ToneAudioNode does not have any internal nodes");const i=s[0];return{channelCount:i.channelCount,channelCountMode:i.channelCountMode,channelInterpretation:i.channelInterpretation}}get channelCount(){return this._getChannelProperties().channelCount}set channelCount(s){const i=this._getChannelProperties();this._setChannelProperties(Object.assign(i,{channelCount:s}))}get channelCountMode(){return this._getChannelProperties().channelCountMode}set channelCountMode(s){const i=this._getChannelProperties();this._setChannelProperties(Object.assign(i,{channelCountMode:s}))}get channelInterpretation(){return this._getChannelProperties().channelInterpretation}set channelInterpretation(s){const i=this._getChannelProperties();this._setChannelProperties(Object.assign(i,{channelInterpretation:s}))}connect(s,i=0,a=0){return connect(this,s,i,a),this}toDestination(){return this.connect(this.context.destination),this}toMaster(){return warn("toMaster() has been renamed toDestination()"),this.toDestination()}disconnect(s,i=0,a=0){return disconnect(this,s,i,a),this}chain(...s){return connectSeries(this,...s),this}fan(...s){return s.forEach(i=>this.connect(i)),this}dispose(){return super.dispose(),isDefined(this.input)&&(this.input instanceof ToneAudioNode?this.input.dispose():isAudioNode(this.input)&&this.input.disconnect()),isDefined(this.output)&&(this.output instanceof ToneAudioNode?this.output.dispose():isAudioNode(this.output)&&this.output.disconnect()),this._internalChannels=[],this}}function connectSeries(...c){const s=c.shift();c.reduce((i,a)=>(i instanceof ToneAudioNode?i.connect(a):isAudioNode(i)&&connect(i,a),a),s)}function connect(c,s,i=0,a=0){for(assert(isDefined(c),"Cannot connect from undefined node"),assert(isDefined(s),"Cannot connect to undefined node"),(s instanceof ToneAudioNode||isAudioNode(s))&&assert(s.numberOfInputs>0,"Cannot connect to node with no inputs"),assert(c.numberOfOutputs>0,"Cannot connect from node with no outputs");s instanceof ToneAudioNode||s instanceof Param;)isDefined(s.input)&&(s=s.input);for(;c instanceof ToneAudioNode;)isDefined(c.output)&&(c=c.output);isAudioParam(s)?c.connect(s,i):c.connect(s,i,a)}function disconnect(c,s,i=0,a=0){if(isDefined(s))for(;s instanceof ToneAudioNode;)s=s.input;for(;!isAudioNode(c);)isDefined(c.output)&&(c=c.output);isAudioParam(s)?c.disconnect(s,i):isAudioNode(s)?c.disconnect(s,i,a):c.disconnect()}class Gain extends ToneAudioNode{constructor(){super(optionsFromArguments(Gain.getDefaults(),arguments,["gain","units"])),this.name="Gain",this._gainNode=this.context.createGain(),this.input=this._gainNode,this.output=this._gainNode;const s=optionsFromArguments(Gain.getDefaults(),arguments,["gain","units"]);this.gain=new Param({context:this.context,convert:s.convert,param:this._gainNode.gain,units:s.units,value:s.gain,minValue:s.minValue,maxValue:s.maxValue}),readOnly(this,"gain")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{convert:!0,gain:1,units:"gain"})}dispose(){return super.dispose(),this._gainNode.disconnect(),this.gain.dispose(),this}}class OneShotSource extends ToneAudioNode{constructor(s){super(s),this.onended=noOp,this._startTime=-1,this._stopTime=-1,this._timeout=-1,this.output=new Gain({context:this.context,gain:0}),this._gainNode=this.output,this.getStateAtTime=function(i){const a=this.toSeconds(i);return this._startTime!==-1&&a>=this._startTime&&(this._stopTime===-1||a<=this._stopTime)?"started":"stopped"},this._fadeIn=s.fadeIn,this._fadeOut=s.fadeOut,this._curve=s.curve,this.onended=s.onended}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{curve:"linear",fadeIn:0,fadeOut:0,onended:noOp})}_startGain(s,i=1){assert(this._startTime===-1,"Source cannot be started more than once");const a=this.toSeconds(this._fadeIn);return this._startTime=s+a,this._startTime=Math.max(this._startTime,this.context.currentTime),a>0?(this._gainNode.gain.setValueAtTime(0,s),this._curve==="linear"?this._gainNode.gain.linearRampToValueAtTime(i,s+a):this._gainNode.gain.exponentialApproachValueAtTime(i,s,a)):this._gainNode.gain.setValueAtTime(i,s),this}stop(s){return this.log("stop",s),this._stopGain(this.toSeconds(s)),this}_stopGain(s){assert(this._startTime!==-1,"'start' must be called before 'stop'"),this.cancelStop();const i=this.toSeconds(this._fadeOut);return this._stopTime=this.toSeconds(s)+i,this._stopTime=Math.max(this._stopTime,this.context.currentTime),i>0?this._curve==="linear"?this._gainNode.gain.linearRampTo(0,i,s):this._gainNode.gain.targetRampTo(0,i,s):(this._gainNode.gain.cancelAndHoldAtTime(s),this._gainNode.gain.setValueAtTime(0,s)),this.context.clearTimeout(this._timeout),this._timeout=this.context.setTimeout(()=>{const a=this._curve==="exponential"?i*2:0;this._stopSource(this.now()+a),this._onended()},this._stopTime-this.context.currentTime),this}_onended(){if(this.onended!==noOp&&(this.onended(this),this.onended=noOp,!this.context.isOffline)){const s=()=>this.dispose();typeof window.requestIdleCallback<"u"?window.requestIdleCallback(s):setTimeout(s,1e3)}}get state(){return this.getStateAtTime(this.now())}cancelStop(){return this.log("cancelStop"),assert(this._startTime!==-1,"Source is not started"),this._gainNode.gain.cancelScheduledValues(this._startTime+this.sampleTime),this.context.clearTimeout(this._timeout),this._stopTime=-1,this}dispose(){return super.dispose(),this._gainNode.disconnect(),this}}class ToneConstantSource extends OneShotSource{constructor(){super(optionsFromArguments(ToneConstantSource.getDefaults(),arguments,["offset"])),this.name="ToneConstantSource",this._source=this.context.createConstantSource();const s=optionsFromArguments(ToneConstantSource.getDefaults(),arguments,["offset"]);connect(this._source,this._gainNode),this.offset=new Param({context:this.context,convert:s.convert,param:this._source.offset,units:s.units,value:s.offset,minValue:s.minValue,maxValue:s.maxValue})}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{convert:!0,offset:1,units:"number"})}start(s){const i=this.toSeconds(s);return this.log("start",i),this._startGain(i),this._source.start(i),this}_stopSource(s){this._source.stop(s)}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._source.disconnect(),this.offset.dispose(),this}}class Signal extends ToneAudioNode{constructor(){super(optionsFromArguments(Signal.getDefaults(),arguments,["value","units"])),this.name="Signal",this.override=!0;const s=optionsFromArguments(Signal.getDefaults(),arguments,["value","units"]);this.output=this._constantSource=new ToneConstantSource({context:this.context,convert:s.convert,offset:s.value,units:s.units,minValue:s.minValue,maxValue:s.maxValue}),this._constantSource.start(0),this.input=this._param=this._constantSource.offset}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{convert:!0,units:"number",value:0})}connect(s,i=0,a=0){return connectSignal(this,s,i,a),this}dispose(){return super.dispose(),this._param.dispose(),this._constantSource.dispose(),this}setValueAtTime(s,i){return this._param.setValueAtTime(s,i),this}getValueAtTime(s){return this._param.getValueAtTime(s)}setRampPoint(s){return this._param.setRampPoint(s),this}linearRampToValueAtTime(s,i){return this._param.linearRampToValueAtTime(s,i),this}exponentialRampToValueAtTime(s,i){return this._param.exponentialRampToValueAtTime(s,i),this}exponentialRampTo(s,i,a){return this._param.exponentialRampTo(s,i,a),this}linearRampTo(s,i,a){return this._param.linearRampTo(s,i,a),this}targetRampTo(s,i,a){return this._param.targetRampTo(s,i,a),this}exponentialApproachValueAtTime(s,i,a){return this._param.exponentialApproachValueAtTime(s,i,a),this}setTargetAtTime(s,i,a){return this._param.setTargetAtTime(s,i,a),this}setValueCurveAtTime(s,i,a,u){return this._param.setValueCurveAtTime(s,i,a,u),this}cancelScheduledValues(s){return this._param.cancelScheduledValues(s),this}cancelAndHoldAtTime(s){return this._param.cancelAndHoldAtTime(s),this}rampTo(s,i,a){return this._param.rampTo(s,i,a),this}get value(){return this._param.value}set value(s){this._param.value=s}get convert(){return this._param.convert}set convert(s){this._param.convert=s}get units(){return this._param.units}get overridden(){return this._param.overridden}set overridden(s){this._param.overridden=s}get maxValue(){return this._param.maxValue}get minValue(){return this._param.minValue}apply(s){return this._param.apply(s),this}}function connectSignal(c,s,i,a){(s instanceof Param||isAudioParam(s)||s instanceof Signal&&s.override)&&(s.cancelScheduledValues(0),s.setValueAtTime(0,0),s instanceof Signal&&(s.overridden=!0)),connect(c,s,i,a)}class TickParam extends Param{constructor(){super(optionsFromArguments(TickParam.getDefaults(),arguments,["value"])),this.name="TickParam",this._events=new Timeline(1/0),this._multiplier=1;const s=optionsFromArguments(TickParam.getDefaults(),arguments,["value"]);this._multiplier=s.multiplier,this._events.cancel(0),this._events.add({ticks:0,time:0,type:"setValueAtTime",value:this._fromType(s.value)}),this.setValueAtTime(s.value,0)}static getDefaults(){return Object.assign(Param.getDefaults(),{multiplier:1,units:"hertz",value:1})}setTargetAtTime(s,i,a){i=this.toSeconds(i),this.setRampPoint(i);const u=this._fromType(s),l=this._events.get(i),d=Math.round(Math.max(1/a,1));for(let h=0;h<=d;h++){const f=a*h+i,p=this._exponentialApproach(l.time,l.value,u,a,f);this.linearRampToValueAtTime(this._toType(p),f)}return this}setValueAtTime(s,i){const a=this.toSeconds(i);super.setValueAtTime(s,i);const u=this._events.get(a),l=this._events.previousEvent(u),d=this._getTicksUntilEvent(l,a);return u.ticks=Math.max(d,0),this}linearRampToValueAtTime(s,i){const a=this.toSeconds(i);super.linearRampToValueAtTime(s,i);const u=this._events.get(a),l=this._events.previousEvent(u),d=this._getTicksUntilEvent(l,a);return u.ticks=Math.max(d,0),this}exponentialRampToValueAtTime(s,i){i=this.toSeconds(i);const a=this._fromType(s),u=this._events.get(i),l=Math.round(Math.max((i-u.time)*10,1)),d=(i-u.time)/l;for(let h=0;h<=l;h++){const f=d*h+u.time,p=this._exponentialInterpolate(u.time,u.value,i,a,f);this.linearRampToValueAtTime(this._toType(p),f)}return this}_getTicksUntilEvent(s,i){if(s===null)s={ticks:0,time:0,type:"setValueAtTime",value:0};else if(isUndef(s.ticks)){const d=this._events.previousEvent(s);s.ticks=this._getTicksUntilEvent(d,s.time)}const a=this._fromType(this.getValueAtTime(s.time));let u=this._fromType(this.getValueAtTime(i));const l=this._events.get(i);return l&&l.time===i&&l.type==="setValueAtTime"&&(u=this._fromType(this.getValueAtTime(i-this.sampleTime))),.5*(i-s.time)*(a+u)+s.ticks}getTicksAtTime(s){const i=this.toSeconds(s),a=this._events.get(i);return Math.max(this._getTicksUntilEvent(a,i),0)}getDurationOfTicks(s,i){const a=this.toSeconds(i),u=this.getTicksAtTime(i);return this.getTimeOfTick(u+s)-a}getTimeOfTick(s){const i=this._events.get(s,"ticks"),a=this._events.getAfter(s,"ticks");if(i&&i.ticks===s)return i.time;if(i&&a&&a.type==="linearRampToValueAtTime"&&i.value!==a.value){const u=this._fromType(this.getValueAtTime(i.time)),d=(this._fromType(this.getValueAtTime(a.time))-u)/(a.time-i.time),h=Math.sqrt(Math.pow(u,2)-2*d*(i.ticks-s)),f=(-u+h)/d,p=(-u-h)/d;return(f>0?f:p)+i.time}else return i?i.value===0?1/0:i.time+(s-i.ticks)/i.value:s/this._initialValue}ticksToTime(s,i){return this.getDurationOfTicks(s,i)}timeToTicks(s,i){const a=this.toSeconds(i),u=this.toSeconds(s),l=this.getTicksAtTime(a);return this.getTicksAtTime(a+u)-l}_fromType(s){return this.units==="bpm"&&this.multiplier?1/(60/s/this.multiplier):super._fromType(s)}_toType(s){return this.units==="bpm"&&this.multiplier?s/this.multiplier*60:super._toType(s)}get multiplier(){return this._multiplier}set multiplier(s){const i=this.value;this._multiplier=s,this.cancelScheduledValues(0),this.setValueAtTime(i,0)}}class TickSignal extends Signal{constructor(){super(optionsFromArguments(TickSignal.getDefaults(),arguments,["value"])),this.name="TickSignal";const s=optionsFromArguments(TickSignal.getDefaults(),arguments,["value"]);this.input=this._param=new TickParam({context:this.context,convert:s.convert,multiplier:s.multiplier,param:this._constantSource.offset,units:s.units,value:s.value})}static getDefaults(){return Object.assign(Signal.getDefaults(),{multiplier:1,units:"hertz",value:1})}ticksToTime(s,i){return this._param.ticksToTime(s,i)}timeToTicks(s,i){return this._param.timeToTicks(s,i)}getTimeOfTick(s){return this._param.getTimeOfTick(s)}getDurationOfTicks(s,i){return this._param.getDurationOfTicks(s,i)}getTicksAtTime(s){return this._param.getTicksAtTime(s)}get multiplier(){return this._param.multiplier}set multiplier(s){this._param.multiplier=s}dispose(){return super.dispose(),this._param.dispose(),this}}class TickSource extends ToneWithContext{constructor(){super(optionsFromArguments(TickSource.getDefaults(),arguments,["frequency"])),this.name="TickSource",this._state=new StateTimeline,this._tickOffset=new Timeline;const s=optionsFromArguments(TickSource.getDefaults(),arguments,["frequency"]);this.frequency=new TickSignal({context:this.context,units:s.units,value:s.frequency}),readOnly(this,"frequency"),this._state.setStateAtTime("stopped",0),this.setTicksAtTime(0,0)}static getDefaults(){return Object.assign({frequency:1,units:"hertz"},ToneWithContext.getDefaults())}get state(){return this.getStateAtTime(this.now())}start(s,i){const a=this.toSeconds(s);return this._state.getValueAtTime(a)!=="started"&&(this._state.setStateAtTime("started",a),isDefined(i)&&this.setTicksAtTime(i,a)),this}stop(s){const i=this.toSeconds(s);if(this._state.getValueAtTime(i)==="stopped"){const a=this._state.get(i);a&&a.time>0&&(this._tickOffset.cancel(a.time),this._state.cancel(a.time))}return this._state.cancel(i),this._state.setStateAtTime("stopped",i),this.setTicksAtTime(0,i),this}pause(s){const i=this.toSeconds(s);return this._state.getValueAtTime(i)==="started"&&this._state.setStateAtTime("paused",i),this}cancel(s){return s=this.toSeconds(s),this._state.cancel(s),this._tickOffset.cancel(s),this}getTicksAtTime(s){const i=this.toSeconds(s),a=this._state.getLastState("stopped",i),u={state:"paused",time:i};this._state.add(u);let l=a,d=0;return this._state.forEachBetween(a.time,i+this.sampleTime,h=>{let f=l.time;const p=this._tickOffset.get(h.time);p&&p.time>=l.time&&(d=p.ticks,f=p.time),l.state==="started"&&h.state!=="started"&&(d+=this.frequency.getTicksAtTime(h.time)-this.frequency.getTicksAtTime(f)),l=h}),this._state.remove(u),d}get ticks(){return this.getTicksAtTime(this.now())}set ticks(s){this.setTicksAtTime(s,this.now())}get seconds(){return this.getSecondsAtTime(this.now())}set seconds(s){const i=this.now(),a=this.frequency.timeToTicks(s,i);this.setTicksAtTime(a,i)}getSecondsAtTime(s){s=this.toSeconds(s);const i=this._state.getLastState("stopped",s),a={state:"paused",time:s};this._state.add(a);let u=i,l=0;return this._state.forEachBetween(i.time,s+this.sampleTime,d=>{let h=u.time;const f=this._tickOffset.get(d.time);f&&f.time>=u.time&&(l=f.seconds,h=f.time),u.state==="started"&&d.state!=="started"&&(l+=d.time-h),u=d}),this._state.remove(a),l}setTicksAtTime(s,i){return i=this.toSeconds(i),this._tickOffset.cancel(i),this._tickOffset.add({seconds:this.frequency.getDurationOfTicks(s,i),ticks:s,time:i}),this}getStateAtTime(s){return s=this.toSeconds(s),this._state.getValueAtTime(s)}getTimeOfTick(s,i=this.now()){const a=this._tickOffset.get(i),u=this._state.get(i),l=Math.max(a.time,u.time),d=this.frequency.getTicksAtTime(l)+s-a.ticks;return this.frequency.getTimeOfTick(d)}forEachTickBetween(s,i,a){let u=this._state.get(s);this._state.forEachBetween(s,i,d=>{u&&u.state==="started"&&d.state!=="started"&&this.forEachTickBetween(Math.max(u.time,s),d.time-this.sampleTime,a),u=d});let l=null;if(u&&u.state==="started"){const d=Math.max(u.time,s),h=this.frequency.getTicksAtTime(d),f=this.frequency.getTicksAtTime(u.time),p=h-f;let g=Math.ceil(p)-p;g=EQ(g,1)?0:g;let m=this.frequency.getTimeOfTick(h+g);for(;m<i;){try{a(m,Math.round(this.getTicksAtTime(m)))}catch(_){l=_;break}m+=this.frequency.getDurationOfTicks(1,m)}}if(l)throw l;return this}dispose(){return super.dispose(),this._state.dispose(),this._tickOffset.dispose(),this.frequency.dispose(),this}}class Clock extends ToneWithContext{constructor(){super(optionsFromArguments(Clock.getDefaults(),arguments,["callback","frequency"])),this.name="Clock",this.callback=noOp,this._lastUpdate=0,this._state=new StateTimeline("stopped"),this._boundLoop=this._loop.bind(this);const s=optionsFromArguments(Clock.getDefaults(),arguments,["callback","frequency"]);this.callback=s.callback,this._tickSource=new TickSource({context:this.context,frequency:s.frequency,units:s.units}),this._lastUpdate=0,this.frequency=this._tickSource.frequency,readOnly(this,"frequency"),this._state.setStateAtTime("stopped",0),this.context.on("tick",this._boundLoop)}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{callback:noOp,frequency:1,units:"hertz"})}get state(){return this._state.getValueAtTime(this.now())}start(s,i){assertContextRunning(this.context);const a=this.toSeconds(s);return this.log("start",a),this._state.getValueAtTime(a)!=="started"&&(this._state.setStateAtTime("started",a),this._tickSource.start(a,i),a<this._lastUpdate&&this.emit("start",a,i)),this}stop(s){const i=this.toSeconds(s);return this.log("stop",i),this._state.cancel(i),this._state.setStateAtTime("stopped",i),this._tickSource.stop(i),i<this._lastUpdate&&this.emit("stop",i),this}pause(s){const i=this.toSeconds(s);return this._state.getValueAtTime(i)==="started"&&(this._state.setStateAtTime("paused",i),this._tickSource.pause(i),i<this._lastUpdate&&this.emit("pause",i)),this}get ticks(){return Math.ceil(this.getTicksAtTime(this.now()))}set ticks(s){this._tickSource.ticks=s}get seconds(){return this._tickSource.seconds}set seconds(s){this._tickSource.seconds=s}getSecondsAtTime(s){return this._tickSource.getSecondsAtTime(s)}setTicksAtTime(s,i){return this._tickSource.setTicksAtTime(s,i),this}getTimeOfTick(s,i=this.now()){return this._tickSource.getTimeOfTick(s,i)}getTicksAtTime(s){return this._tickSource.getTicksAtTime(s)}nextTickTime(s,i){const a=this.toSeconds(i),u=this.getTicksAtTime(a);return this._tickSource.getTimeOfTick(u+s,a)}_loop(){const s=this._lastUpdate,i=this.now();this._lastUpdate=i,this.log("loop",s,i),s!==i&&(this._state.forEachBetween(s,i,a=>{switch(a.state){case"started":const u=this._tickSource.getTicksAtTime(a.time);this.emit("start",a.time,u);break;case"stopped":a.time!==0&&this.emit("stop",a.time);break;case"paused":this.emit("pause",a.time);break}}),this._tickSource.forEachTickBetween(s,i,(a,u)=>{this.callback(a,u)}))}getStateAtTime(s){const i=this.toSeconds(s);return this._state.getValueAtTime(i)}dispose(){return super.dispose(),this.context.off("tick",this._boundLoop),this._tickSource.dispose(),this._state.dispose(),this}}Emitter.mixin(Clock);class ToneAudioBuffers extends Tone{constructor(){super(),this.name="ToneAudioBuffers",this._buffers=new Map,this._loadingCount=0;const s=optionsFromArguments(ToneAudioBuffers.getDefaults(),arguments,["urls","onload","baseUrl"],"urls");this.baseUrl=s.baseUrl,Object.keys(s.urls).forEach(i=>{this._loadingCount++;const a=s.urls[i];this.add(i,a,this._bufferLoaded.bind(this,s.onload),s.onerror)})}static getDefaults(){return{baseUrl:"",onerror:noOp,onload:noOp,urls:{}}}has(s){return this._buffers.has(s.toString())}get(s){return assert(this.has(s),`ToneAudioBuffers has no buffer named: ${s}`),this._buffers.get(s.toString())}_bufferLoaded(s){this._loadingCount--,this._loadingCount===0&&s&&s()}get loaded(){return Array.from(this._buffers).every(([s,i])=>i.loaded)}add(s,i,a=noOp,u=noOp){return isString(i)?this._buffers.set(s.toString(),new ToneAudioBuffer(this.baseUrl+i,a,u)):this._buffers.set(s.toString(),new ToneAudioBuffer(i,a,u)),this}dispose(){return super.dispose(),this._buffers.forEach(s=>s.dispose()),this._buffers.clear(),this}}class TicksClass extends TransportTimeClass{constructor(){super(...arguments),this.name="Ticks",this.defaultUnits="i"}_now(){return this.context.transport.ticks}_beatsToUnits(s){return this._getPPQ()*s}_secondsToUnits(s){return Math.floor(s/(60/this._getBpm())*this._getPPQ())}_ticksToUnits(s){return s}toTicks(){return this.valueOf()}toSeconds(){return this.valueOf()/this._getPPQ()*(60/this._getBpm())}}class Draw extends ToneWithContext{constructor(){super(...arguments),this.name="Draw",this.expiration=.25,this.anticipation=.008,this._events=new Timeline,this._boundDrawLoop=this._drawLoop.bind(this),this._animationFrame=-1}schedule(s,i){return this._events.add({callback:s,time:this.toSeconds(i)}),this._events.length===1&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop)),this}cancel(s){return this._events.cancel(this.toSeconds(s)),this}_drawLoop(){const s=this.context.currentTime;for(;this._events.length&&this._events.peek().time-this.anticipation<=s;){const i=this._events.shift();i&&s-i.time<=this.expiration&&i.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){return super.dispose(),this._events.dispose(),cancelAnimationFrame(this._animationFrame),this}}onContextInit(c=>{c.draw=new Draw({context:c})});onContextClose(c=>{c.draw.dispose()});class IntervalTimeline extends Tone{constructor(){super(...arguments),this.name="IntervalTimeline",this._root=null,this._length=0}add(s){assert(isDefined(s.time),"Events must have a time property"),assert(isDefined(s.duration),"Events must have a duration parameter"),s.time=s.time.valueOf();let i=new IntervalNode(s.time,s.time+s.duration,s);for(this._root===null?this._root=i:this._root.insert(i),this._length++;i!==null;)i.updateHeight(),i.updateMax(),this._rebalance(i),i=i.parent;return this}remove(s){if(this._root!==null){const i=[];this._root.search(s.time,i);for(const a of i)if(a.event===s){this._removeNode(a),this._length--;break}}return this}get length(){return this._length}cancel(s){return this.forEachFrom(s,i=>this.remove(i)),this}_setRoot(s){this._root=s,this._root!==null&&(this._root.parent=null)}_replaceNodeInParent(s,i){s.parent!==null?(s.isLeftChild()?s.parent.left=i:s.parent.right=i,this._rebalance(s.parent)):this._setRoot(i)}_removeNode(s){if(s.left===null&&s.right===null)this._replaceNodeInParent(s,null);else if(s.right===null)this._replaceNodeInParent(s,s.left);else if(s.left===null)this._replaceNodeInParent(s,s.right);else{const i=s.getBalance();let a,u=null;if(i>0)if(s.left.right===null)a=s.left,a.right=s.right,u=a;else{for(a=s.left.right;a.right!==null;)a=a.right;a.parent&&(a.parent.right=a.left,u=a.parent,a.left=s.left,a.right=s.right)}else if(s.right.left===null)a=s.right,a.left=s.left,u=a;else{for(a=s.right.left;a.left!==null;)a=a.left;a.parent&&(a.parent.left=a.right,u=a.parent,a.left=s.left,a.right=s.right)}s.parent!==null?s.isLeftChild()?s.parent.left=a:s.parent.right=a:this._setRoot(a),u&&this._rebalance(u)}s.dispose()}_rotateLeft(s){const i=s.parent,a=s.isLeftChild(),u=s.right;u&&(s.right=u.left,u.left=s),i!==null?a?i.left=u:i.right=u:this._setRoot(u)}_rotateRight(s){const i=s.parent,a=s.isLeftChild(),u=s.left;u&&(s.left=u.right,u.right=s),i!==null?a?i.left=u:i.right=u:this._setRoot(u)}_rebalance(s){const i=s.getBalance();i>1&&s.left?s.left.getBalance()<0?this._rotateLeft(s.left):this._rotateRight(s):i<-1&&s.right&&(s.right.getBalance()>0?this._rotateRight(s.right):this._rotateLeft(s))}get(s){if(this._root!==null){const i=[];if(this._root.search(s,i),i.length>0){let a=i[0];for(let u=1;u<i.length;u++)i[u].low>a.low&&(a=i[u]);return a.event}}return null}forEach(s){if(this._root!==null){const i=[];this._root.traverse(a=>i.push(a)),i.forEach(a=>{a.event&&s(a.event)})}return this}forEachAtTime(s,i){if(this._root!==null){const a=[];this._root.search(s,a),a.forEach(u=>{u.event&&i(u.event)})}return this}forEachFrom(s,i){if(this._root!==null){const a=[];this._root.searchAfter(s,a),a.forEach(u=>{u.event&&i(u.event)})}return this}dispose(){return super.dispose(),this._root!==null&&this._root.traverse(s=>s.dispose()),this._root=null,this}}class IntervalNode{constructor(s,i,a){this._left=null,this._right=null,this.parent=null,this.height=0,this.event=a,this.low=s,this.high=i,this.max=this.high}insert(s){s.low<=this.low?this.left===null?this.left=s:this.left.insert(s):this.right===null?this.right=s:this.right.insert(s)}search(s,i){s>this.max||(this.left!==null&&this.left.search(s,i),this.low<=s&&this.high>s&&i.push(this),!(this.low>s)&&this.right!==null&&this.right.search(s,i))}searchAfter(s,i){this.low>=s&&(i.push(this),this.left!==null&&this.left.searchAfter(s,i)),this.right!==null&&this.right.searchAfter(s,i)}traverse(s){s(this),this.left!==null&&this.left.traverse(s),this.right!==null&&this.right.traverse(s)}updateHeight(){this.left!==null&&this.right!==null?this.height=Math.max(this.left.height,this.right.height)+1:this.right!==null?this.height=this.right.height+1:this.left!==null?this.height=this.left.height+1:this.height=0}updateMax(){this.max=this.high,this.left!==null&&(this.max=Math.max(this.max,this.left.max)),this.right!==null&&(this.max=Math.max(this.max,this.right.max))}getBalance(){let s=0;return this.left!==null&&this.right!==null?s=this.left.height-this.right.height:this.left!==null?s=this.left.height+1:this.right!==null&&(s=-(this.right.height+1)),s}isLeftChild(){return this.parent!==null&&this.parent.left===this}get left(){return this._left}set left(s){this._left=s,s!==null&&(s.parent=this),this.updateHeight(),this.updateMax()}get right(){return this._right}set right(s){this._right=s,s!==null&&(s.parent=this),this.updateHeight(),this.updateMax()}dispose(){this.parent=null,this._left=null,this._right=null,this.event=null}}class Volume extends ToneAudioNode{constructor(){super(optionsFromArguments(Volume.getDefaults(),arguments,["volume"])),this.name="Volume";const s=optionsFromArguments(Volume.getDefaults(),arguments,["volume"]);this.input=this.output=new Gain({context:this.context,gain:s.volume,units:"decibels"}),this.volume=this.output.gain,readOnly(this,"volume"),this._unmutedVolume=s.volume,this.mute=s.mute}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,volume:0})}get mute(){return this.volume.value===-1/0}set mute(s){!this.mute&&s?(this._unmutedVolume=this.volume.value,this.volume.value=-1/0):this.mute&&!s&&(this.volume.value=this._unmutedVolume)}dispose(){return super.dispose(),this.input.dispose(),this.volume.dispose(),this}}class Destination extends ToneAudioNode{constructor(){super(optionsFromArguments(Destination.getDefaults(),arguments)),this.name="Destination",this.input=new Volume({context:this.context}),this.output=new Gain({context:this.context}),this.volume=this.input.volume;const s=optionsFromArguments(Destination.getDefaults(),arguments);connectSeries(this.input,this.output,this.context.rawContext.destination),this.mute=s.mute,this._internalChannels=[this.input,this.context.rawContext.destination,this.output]}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,volume:0})}get mute(){return this.input.mute}set mute(s){this.input.mute=s}chain(...s){return this.input.disconnect(),s.unshift(this.input),s.push(this.output),connectSeries(...s),this}get maxChannelCount(){return this.context.rawContext.destination.maxChannelCount}dispose(){return super.dispose(),this.volume.dispose(),this}}onContextInit(c=>{c.destination=new Destination({context:c})});onContextClose(c=>{c.destination.dispose()});class TimelineValue extends Tone{constructor(s){super(),this.name="TimelineValue",this._timeline=new Timeline({memory:10}),this._initialValue=s}set(s,i){return this._timeline.add({value:s,time:i}),this}get(s){const i=this._timeline.get(s);return i?i.value:this._initialValue}}class TransportEvent{constructor(s,i){this.id=TransportEvent._eventId++;const a=Object.assign(TransportEvent.getDefaults(),i);this.transport=s,this.callback=a.callback,this._once=a.once,this.time=a.time}static getDefaults(){return{callback:noOp,once:!1,time:0}}invoke(s){this.callback&&(this.callback(s),this._once&&this.transport.clear(this.id))}dispose(){return this.callback=void 0,this}}TransportEvent._eventId=0;class TransportRepeatEvent extends TransportEvent{constructor(s,i){super(s,i),this._currentId=-1,this._nextId=-1,this._nextTick=this.time,this._boundRestart=this._restart.bind(this);const a=Object.assign(TransportRepeatEvent.getDefaults(),i);this.duration=new TicksClass(s.context,a.duration).valueOf(),this._interval=new TicksClass(s.context,a.interval).valueOf(),this._nextTick=a.time,this.transport.on("start",this._boundRestart),this.transport.on("loopStart",this._boundRestart),this.context=this.transport.context,this._restart()}static getDefaults(){return Object.assign({},TransportEvent.getDefaults(),{duration:1/0,interval:1,once:!1})}invoke(s){this._createEvents(s),super.invoke(s)}_createEvents(s){const i=this.transport.getTicksAtTime(s);i>=this.time&&i>=this._nextTick&&this._nextTick+this._interval<this.time+this.duration&&(this._nextTick+=this._interval,this._currentId=this._nextId,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds()))}_restart(s){this.transport.clear(this._currentId),this.transport.clear(this._nextId),this._nextTick=this.time;const i=this.transport.getTicksAtTime(s);i>this.time&&(this._nextTick=this.time+Math.ceil((i-this.time)/this._interval)*this._interval),this._currentId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds()),this._nextTick+=this._interval,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds())}dispose(){return super.dispose(),this.transport.clear(this._currentId),this.transport.clear(this._nextId),this.transport.off("start",this._boundRestart),this.transport.off("loopStart",this._boundRestart),this}}class Transport extends ToneWithContext{constructor(){super(optionsFromArguments(Transport.getDefaults(),arguments)),this.name="Transport",this._loop=new TimelineValue(!1),this._loopStart=0,this._loopEnd=0,this._scheduledEvents={},this._timeline=new Timeline,this._repeatedEvents=new IntervalTimeline,this._syncedSignals=[],this._swingAmount=0;const s=optionsFromArguments(Transport.getDefaults(),arguments);this._ppq=s.ppq,this._clock=new Clock({callback:this._processTick.bind(this),context:this.context,frequency:0,units:"bpm"}),this._bindClockEvents(),this.bpm=this._clock.frequency,this._clock.frequency.multiplier=s.ppq,this.bpm.setValueAtTime(s.bpm,0),readOnly(this,"bpm"),this._timeSignature=s.timeSignature,this._swingTicks=s.ppq/2}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{bpm:120,loopEnd:"4m",loopStart:0,ppq:192,swing:0,swingSubdivision:"8n",timeSignature:4})}_processTick(s,i){if(this._loop.get(s)&&i>=this._loopEnd&&(this.emit("loopEnd",s),this._clock.setTicksAtTime(this._loopStart,s),i=this._loopStart,this.emit("loopStart",s,this._clock.getSecondsAtTime(s)),this.emit("loop",s)),this._swingAmount>0&&i%this._ppq!==0&&i%(this._swingTicks*2)!==0){const a=i%(this._swingTicks*2)/(this._swingTicks*2),u=Math.sin(a*Math.PI)*this._swingAmount;s+=new TicksClass(this.context,this._swingTicks*2/3).toSeconds()*u}this._timeline.forEachAtTime(i,a=>a.invoke(s))}schedule(s,i){const a=new TransportEvent(this,{callback:s,time:new TransportTimeClass(this.context,i).toTicks()});return this._addEvent(a,this._timeline)}scheduleRepeat(s,i,a,u=1/0){const l=new TransportRepeatEvent(this,{callback:s,duration:new TimeClass(this.context,u).toTicks(),interval:new TimeClass(this.context,i).toTicks(),time:new TransportTimeClass(this.context,a).toTicks()});return this._addEvent(l,this._repeatedEvents)}scheduleOnce(s,i){const a=new TransportEvent(this,{callback:s,once:!0,time:new TransportTimeClass(this.context,i).toTicks()});return this._addEvent(a,this._timeline)}clear(s){if(this._scheduledEvents.hasOwnProperty(s)){const i=this._scheduledEvents[s.toString()];i.timeline.remove(i.event),i.event.dispose(),delete this._scheduledEvents[s.toString()]}return this}_addEvent(s,i){return this._scheduledEvents[s.id.toString()]={event:s,timeline:i},i.add(s),s.id}cancel(s=0){const i=this.toTicks(s);return this._timeline.forEachFrom(i,a=>this.clear(a.id)),this._repeatedEvents.forEachFrom(i,a=>this.clear(a.id)),this}_bindClockEvents(){this._clock.on("start",(s,i)=>{i=new TicksClass(this.context,i).toSeconds(),this.emit("start",s,i)}),this._clock.on("stop",s=>{this.emit("stop",s)}),this._clock.on("pause",s=>{this.emit("pause",s)})}get state(){return this._clock.getStateAtTime(this.now())}start(s,i){let a;return isDefined(i)&&(a=this.toTicks(i)),this._clock.start(s,a),this}stop(s){return this._clock.stop(s),this}pause(s){return this._clock.pause(s),this}toggle(s){return s=this.toSeconds(s),this._clock.getStateAtTime(s)!=="started"?this.start(s):this.stop(s),this}get timeSignature(){return this._timeSignature}set timeSignature(s){isArray(s)&&(s=s[0]/s[1]*4),this._timeSignature=s}get loopStart(){return new TimeClass(this.context,this._loopStart,"i").toSeconds()}set loopStart(s){this._loopStart=this.toTicks(s)}get loopEnd(){return new TimeClass(this.context,this._loopEnd,"i").toSeconds()}set loopEnd(s){this._loopEnd=this.toTicks(s)}get loop(){return this._loop.get(this.now())}set loop(s){this._loop.set(s,this.now())}setLoopPoints(s,i){return this.loopStart=s,this.loopEnd=i,this}get swing(){return this._swingAmount}set swing(s){this._swingAmount=s}get swingSubdivision(){return new TicksClass(this.context,this._swingTicks).toNotation()}set swingSubdivision(s){this._swingTicks=this.toTicks(s)}get position(){const s=this.now(),i=this._clock.getTicksAtTime(s);return new TicksClass(this.context,i).toBarsBeatsSixteenths()}set position(s){const i=this.toTicks(s);this.ticks=i}get seconds(){return this._clock.seconds}set seconds(s){const i=this.now(),a=this._clock.frequency.timeToTicks(s,i);this.ticks=a}get progress(){if(this.loop){const s=this.now();return(this._clock.getTicksAtTime(s)-this._loopStart)/(this._loopEnd-this._loopStart)}else return 0}get ticks(){return this._clock.ticks}set ticks(s){if(this._clock.ticks!==s){const i=this.now();if(this.state==="started"){const a=this._clock.getTicksAtTime(i),u=this._clock.frequency.getDurationOfTicks(Math.ceil(a)-a,i),l=i+u;this.emit("stop",l),this._clock.setTicksAtTime(s,l),this.emit("start",l,this._clock.getSecondsAtTime(l))}else this._clock.setTicksAtTime(s,i)}}getTicksAtTime(s){return Math.round(this._clock.getTicksAtTime(s))}getSecondsAtTime(s){return this._clock.getSecondsAtTime(s)}get PPQ(){return this._clock.frequency.multiplier}set PPQ(s){this._clock.frequency.multiplier=s}nextSubdivision(s){if(s=this.toTicks(s),this.state!=="started")return 0;{const i=this.now(),a=this.getTicksAtTime(i),u=s-a%s;return this._clock.nextTickTime(u,i)}}syncSignal(s,i){if(!i){const u=this.now();if(s.getValueAtTime(u)!==0){const d=1/(60/this.bpm.getValueAtTime(u)/this.PPQ);i=s.getValueAtTime(u)/d}else i=0}const a=new Gain(i);return this.bpm.connect(a),a.connect(s._param),this._syncedSignals.push({initial:s.value,ratio:a,signal:s}),s.value=0,this}unsyncSignal(s){for(let i=this._syncedSignals.length-1;i>=0;i--){const a=this._syncedSignals[i];a.signal===s&&(a.ratio.dispose(),a.signal.value=a.initial,this._syncedSignals.splice(i,1))}return this}dispose(){return super.dispose(),this._clock.dispose(),writable(this,"bpm"),this._timeline.dispose(),this._repeatedEvents.dispose(),this}}Emitter.mixin(Transport);onContextInit(c=>{c.transport=new Transport({context:c})});onContextClose(c=>{c.transport.dispose()});class Source extends ToneAudioNode{constructor(s){super(s),this.input=void 0,this._state=new StateTimeline("stopped"),this._synced=!1,this._scheduled=[],this._syncedStart=noOp,this._syncedStop=noOp,this._state.memory=100,this._state.increasing=!0,this._volume=this.output=new Volume({context:this.context,mute:s.mute,volume:s.volume}),this.volume=this._volume.volume,readOnly(this,"volume"),this.onstop=s.onstop}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,onstop:noOp,volume:0})}get state(){return this._synced?this.context.transport.state==="started"?this._state.getValueAtTime(this.context.transport.seconds):"stopped":this._state.getValueAtTime(this.now())}get mute(){return this._volume.mute}set mute(s){this._volume.mute=s}_clampToCurrentTime(s){return this._synced?s:Math.max(s,this.context.currentTime)}start(s,i,a){let u=isUndef(s)&&this._synced?this.context.transport.seconds:this.toSeconds(s);if(u=this._clampToCurrentTime(u),!this._synced&&this._state.getValueAtTime(u)==="started")assert(GT(u,this._state.get(u).time),"Start time must be strictly greater than previous start time"),this._state.cancel(u),this._state.setStateAtTime("started",u),this.log("restart",u),this.restart(u,i,a);else if(this.log("start",u),this._state.setStateAtTime("started",u),this._synced){const l=this._state.get(u);l&&(l.offset=this.toSeconds(defaultArg(i,0)),l.duration=a?this.toSeconds(a):void 0);const d=this.context.transport.schedule(h=>{this._start(h,i,a)},u);this._scheduled.push(d),this.context.transport.state==="started"&&this.context.transport.getSecondsAtTime(this.immediate())>u&&this._syncedStart(this.now(),this.context.transport.seconds)}else assertContextRunning(this.context),this._start(u,i,a);return this}stop(s){let i=isUndef(s)&&this._synced?this.context.transport.seconds:this.toSeconds(s);if(i=this._clampToCurrentTime(i),this._state.getValueAtTime(i)==="started"||isDefined(this._state.getNextState("started",i))){if(this.log("stop",i),!this._synced)this._stop(i);else{const a=this.context.transport.schedule(this._stop.bind(this),i);this._scheduled.push(a)}this._state.cancel(i),this._state.setStateAtTime("stopped",i)}return this}restart(s,i,a){return s=this.toSeconds(s),this._state.getValueAtTime(s)==="started"&&(this._state.cancel(s),this._restart(s,i,a)),this}sync(){return this._synced||(this._synced=!0,this._syncedStart=(s,i)=>{if(i>0){const a=this._state.get(i);if(a&&a.state==="started"&&a.time!==i){const u=i-this.toSeconds(a.time);let l;a.duration&&(l=this.toSeconds(a.duration)-u),this._start(s,this.toSeconds(a.offset)+u,l)}}},this._syncedStop=s=>{const i=this.context.transport.getSecondsAtTime(Math.max(s-this.sampleTime,0));this._state.getValueAtTime(i)==="started"&&this._stop(s)},this.context.transport.on("start",this._syncedStart),this.context.transport.on("loopStart",this._syncedStart),this.context.transport.on("stop",this._syncedStop),this.context.transport.on("pause",this._syncedStop),this.context.transport.on("loopEnd",this._syncedStop)),this}unsync(){return this._synced&&(this.context.transport.off("stop",this._syncedStop),this.context.transport.off("pause",this._syncedStop),this.context.transport.off("loopEnd",this._syncedStop),this.context.transport.off("start",this._syncedStart),this.context.transport.off("loopStart",this._syncedStart)),this._synced=!1,this._scheduled.forEach(s=>this.context.transport.clear(s)),this._scheduled=[],this._state.cancel(0),this._stop(0),this}dispose(){return super.dispose(),this.onstop=noOp,this.unsync(),this._volume.dispose(),this._state.dispose(),this}}class ToneBufferSource extends OneShotSource{constructor(){super(optionsFromArguments(ToneBufferSource.getDefaults(),arguments,["url","onload"])),this.name="ToneBufferSource",this._source=this.context.createBufferSource(),this._internalChannels=[this._source],this._sourceStarted=!1,this._sourceStopped=!1;const s=optionsFromArguments(ToneBufferSource.getDefaults(),arguments,["url","onload"]);connect(this._source,this._gainNode),this._source.onended=()=>this._stopSource(),this.playbackRate=new Param({context:this.context,param:this._source.playbackRate,units:"positive",value:s.playbackRate}),this.loop=s.loop,this.loopStart=s.loopStart,this.loopEnd=s.loopEnd,this._buffer=new ToneAudioBuffer(s.url,s.onload,s.onerror),this._internalChannels.push(this._source)}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{url:new ToneAudioBuffer,loop:!1,loopEnd:0,loopStart:0,onload:noOp,onerror:noOp,playbackRate:1})}get fadeIn(){return this._fadeIn}set fadeIn(s){this._fadeIn=s}get fadeOut(){return this._fadeOut}set fadeOut(s){this._fadeOut=s}get curve(){return this._curve}set curve(s){this._curve=s}start(s,i,a,u=1){assert(this.buffer.loaded,"buffer is either not set or not loaded");const l=this.toSeconds(s);this._startGain(l,u),this.loop?i=defaultArg(i,this.loopStart):i=defaultArg(i,0);let d=Math.max(this.toSeconds(i),0);if(this.loop){const h=this.toSeconds(this.loopEnd)||this.buffer.duration,f=this.toSeconds(this.loopStart),p=h-f;GTE(d,h)&&(d=(d-f)%p+f),EQ(d,this.buffer.duration)&&(d=0)}if(this._source.buffer=this.buffer.get(),this._source.loopEnd=this.toSeconds(this.loopEnd)||this.buffer.duration,LT(d,this.buffer.duration)&&(this._sourceStarted=!0,this._source.start(l,d)),isDefined(a)){let h=this.toSeconds(a);h=Math.max(h,0),this.stop(l+h)}return this}_stopSource(s){!this._sourceStopped&&this._sourceStarted&&(this._sourceStopped=!0,this._source.stop(this.toSeconds(s)),this._onended())}get loopStart(){return this._source.loopStart}set loopStart(s){this._source.loopStart=this.toSeconds(s)}get loopEnd(){return this._source.loopEnd}set loopEnd(s){this._source.loopEnd=this.toSeconds(s)}get buffer(){return this._buffer}set buffer(s){this._buffer.set(s)}get loop(){return this._source.loop}set loop(s){this._source.loop=s,this._sourceStarted&&this.cancelStop()}dispose(){return super.dispose(),this._source.onended=null,this._source.disconnect(),this._buffer.dispose(),this.playbackRate.dispose(),this}}class Noise extends Source{constructor(){super(optionsFromArguments(Noise.getDefaults(),arguments,["type"])),this.name="Noise",this._source=null;const s=optionsFromArguments(Noise.getDefaults(),arguments,["type"]);this._playbackRate=s.playbackRate,this.type=s.type,this._fadeIn=s.fadeIn,this._fadeOut=s.fadeOut}static getDefaults(){return Object.assign(Source.getDefaults(),{fadeIn:0,fadeOut:0,playbackRate:1,type:"white"})}get type(){return this._type}set type(s){if(assert(s in _noiseBuffers,"Noise: invalid type: "+s),this._type!==s&&(this._type=s,this.state==="started")){const i=this.now();this._stop(i),this._start(i)}}get playbackRate(){return this._playbackRate}set playbackRate(s){this._playbackRate=s,this._source&&(this._source.playbackRate.value=s)}_start(s){const i=_noiseBuffers[this._type];this._source=new ToneBufferSource({url:i,context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,loop:!0,onended:()=>this.onstop(this),playbackRate:this._playbackRate}).connect(this.output),this._source.start(this.toSeconds(s),Math.random()*(i.duration-.001))}_stop(s){this._source&&(this._source.stop(this.toSeconds(s)),this._source=null)}get fadeIn(){return this._fadeIn}set fadeIn(s){this._fadeIn=s,this._source&&(this._source.fadeIn=this._fadeIn)}get fadeOut(){return this._fadeOut}set fadeOut(s){this._fadeOut=s,this._source&&(this._source.fadeOut=this._fadeOut)}_restart(s){this._stop(s),this._start(s)}dispose(){return super.dispose(),this._source&&this._source.disconnect(),this}}const BUFFER_LENGTH=44100*5,NUM_CHANNELS=2,_noiseCache={brown:null,pink:null,white:null},_noiseBuffers={get brown(){if(!_noiseCache.brown){const c=[];for(let s=0;s<NUM_CHANNELS;s++){const i=new Float32Array(BUFFER_LENGTH);c[s]=i;let a=0;for(let u=0;u<BUFFER_LENGTH;u++){const l=Math.random()*2-1;i[u]=(a+.02*l)/1.02,a=i[u],i[u]*=3.5}}_noiseCache.brown=new ToneAudioBuffer().fromArray(c)}return _noiseCache.brown},get pink(){if(!_noiseCache.pink){const c=[];for(let s=0;s<NUM_CHANNELS;s++){const i=new Float32Array(BUFFER_LENGTH);c[s]=i;let a,u,l,d,h,f,p;a=u=l=d=h=f=p=0;for(let g=0;g<BUFFER_LENGTH;g++){const m=Math.random()*2-1;a=.99886*a+m*.0555179,u=.99332*u+m*.0750759,l=.969*l+m*.153852,d=.8665*d+m*.3104856,h=.55*h+m*.5329522,f=-.7616*f-m*.016898,i[g]=a+u+l+d+h+f+p+m*.5362,i[g]*=.11,p=m*.115926}}_noiseCache.pink=new ToneAudioBuffer().fromArray(c)}return _noiseCache.pink},get white(){if(!_noiseCache.white){const c=[];for(let s=0;s<NUM_CHANNELS;s++){const i=new Float32Array(BUFFER_LENGTH);c[s]=i;for(let a=0;a<BUFFER_LENGTH;a++)i[a]=Math.random()*2-1}_noiseCache.white=new ToneAudioBuffer().fromArray(c)}return _noiseCache.white}};function generateWaveform(c,s){return __awaiter(this,void 0,void 0,function*(){const i=s/c.context.sampleRate,a=new OfflineContext(1,i,c.context.sampleRate);return new c.constructor(Object.assign(c.get(),{frequency:2/i,detune:0,context:a})).toDestination().start(0),(yield a.render()).getChannelData(0)})}class ToneOscillatorNode extends OneShotSource{constructor(){super(optionsFromArguments(ToneOscillatorNode.getDefaults(),arguments,["frequency","type"])),this.name="ToneOscillatorNode",this._oscillator=this.context.createOscillator(),this._internalChannels=[this._oscillator];const s=optionsFromArguments(ToneOscillatorNode.getDefaults(),arguments,["frequency","type"]);connect(this._oscillator,this._gainNode),this.type=s.type,this.frequency=new Param({context:this.context,param:this._oscillator.frequency,units:"frequency",value:s.frequency}),this.detune=new Param({context:this.context,param:this._oscillator.detune,units:"cents",value:s.detune}),readOnly(this,["frequency","detune"])}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{detune:0,frequency:440,type:"sine"})}start(s){const i=this.toSeconds(s);return this.log("start",i),this._startGain(i),this._oscillator.start(i),this}_stopSource(s){this._oscillator.stop(s)}setPeriodicWave(s){return this._oscillator.setPeriodicWave(s),this}get type(){return this._oscillator.type}set type(s){this._oscillator.type=s}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._oscillator.disconnect(),this.frequency.dispose(),this.detune.dispose(),this}}class Oscillator extends Source{constructor(){super(optionsFromArguments(Oscillator.getDefaults(),arguments,["frequency","type"])),this.name="Oscillator",this._oscillator=null;const s=optionsFromArguments(Oscillator.getDefaults(),arguments,["frequency","type"]);this.frequency=new Signal({context:this.context,units:"frequency",value:s.frequency}),readOnly(this,"frequency"),this.detune=new Signal({context:this.context,units:"cents",value:s.detune}),readOnly(this,"detune"),this._partials=s.partials,this._partialCount=s.partialCount,this._type=s.type,s.partialCount&&s.type!=="custom"&&(this._type=this.baseType+s.partialCount.toString()),this.phase=s.phase}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,partialCount:0,partials:[],phase:0,type:"sine"})}_start(s){const i=this.toSeconds(s),a=new ToneOscillatorNode({context:this.context,onended:()=>this.onstop(this)});this._oscillator=a,this._wave?this._oscillator.setPeriodicWave(this._wave):this._oscillator.type=this._type,this._oscillator.connect(this.output),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.start(i)}_stop(s){const i=this.toSeconds(s);this._oscillator&&this._oscillator.stop(i)}_restart(s){const i=this.toSeconds(s);return this.log("restart",i),this._oscillator&&this._oscillator.cancelStop(),this._state.cancel(i),this}syncFrequency(){return this.context.transport.syncSignal(this.frequency),this}unsyncFrequency(){return this.context.transport.unsyncSignal(this.frequency),this}_getCachedPeriodicWave(){if(this._type==="custom")return Oscillator._periodicWaveCache.find(i=>i.phase===this._phase&&deepEquals(i.partials,this._partials));{const s=Oscillator._periodicWaveCache.find(i=>i.type===this._type&&i.phase===this._phase);return this._partialCount=s?s.partialCount:this._partialCount,s}}get type(){return this._type}set type(s){this._type=s;const i=["sine","square","sawtooth","triangle"].indexOf(s)!==-1;if(this._phase===0&&i)this._wave=void 0,this._partialCount=0,this._oscillator!==null&&(this._oscillator.type=s);else{const a=this._getCachedPeriodicWave();if(isDefined(a)){const{partials:u,wave:l}=a;this._wave=l,this._partials=u,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave)}else{const[u,l]=this._getRealImaginary(s,this._phase),d=this.context.createPeriodicWave(u,l);this._wave=d,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave),Oscillator._periodicWaveCache.push({imag:l,partialCount:this._partialCount,partials:this._partials,phase:this._phase,real:u,type:this._type,wave:this._wave}),Oscillator._periodicWaveCache.length>100&&Oscillator._periodicWaveCache.shift()}}}get baseType(){return this._type.replace(this.partialCount.toString(),"")}set baseType(s){this.partialCount&&this._type!=="custom"&&s!=="custom"?this.type=s+this.partialCount:this.type=s}get partialCount(){return this._partialCount}set partialCount(s){assertRange(s,0);let i=this._type;const a=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);if(a&&(i=a[1]),this._type!=="custom")s===0?this.type=i:this.type=i+s.toString();else{const u=new Float32Array(s);this._partials.forEach((l,d)=>u[d]=l),this._partials=Array.from(u),this.type=this._type}}_getRealImaginary(s,i){let u=2048;const l=new Float32Array(u),d=new Float32Array(u);let h=1;if(s==="custom"){if(h=this._partials.length+1,this._partialCount=this._partials.length,u=h,this._partials.length===0)return[l,d]}else{const f=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(s);f?(h=parseInt(f[2],10)+1,this._partialCount=parseInt(f[2],10),s=f[1],h=Math.max(h,2),u=h):this._partialCount=0,this._partials=[]}for(let f=1;f<u;++f){const p=2/(f*Math.PI);let g;switch(s){case"sine":g=f<=h?1:0,this._partials[f-1]=g;break;case"square":g=f&1?2*p:0,this._partials[f-1]=g;break;case"sawtooth":g=p*(f&1?1:-1),this._partials[f-1]=g;break;case"triangle":f&1?g=2*(p*p)*(f-1>>1&1?-1:1):g=0,this._partials[f-1]=g;break;case"custom":g=this._partials[f-1];break;default:throw new TypeError("Oscillator: invalid type: "+s)}g!==0?(l[f]=-g*Math.sin(i*f),d[f]=g*Math.cos(i*f)):(l[f]=0,d[f]=0)}return[l,d]}_inverseFFT(s,i,a){let u=0;const l=s.length;for(let d=0;d<l;d++)u+=s[d]*Math.cos(d*a)+i[d]*Math.sin(d*a);return u}getInitialValue(){const[s,i]=this._getRealImaginary(this._type,0);let a=0;const u=Math.PI*2,l=32;for(let d=0;d<l;d++)a=Math.max(this._inverseFFT(s,i,d/l*u),a);return clamp(-this._inverseFFT(s,i,this._phase)/a,-1,1)}get partials(){return this._partials.slice(0,this.partialCount)}set partials(s){this._partials=s,this._partialCount=this._partials.length,s.length&&(this.type="custom")}get phase(){return this._phase*(180/Math.PI)}set phase(s){this._phase=s*Math.PI/180,this.type=this._type}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this._oscillator!==null&&this._oscillator.dispose(),this._wave=void 0,this.frequency.dispose(),this.detune.dispose(),this}}Oscillator._periodicWaveCache=[];class SignalOperator extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(),arguments,["context"])))}connect(s,i=0,a=0){return connectSignal(this,s,i,a),this}}class WaveShaper extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(),arguments,["mapping","length"]))),this.name="WaveShaper",this._shaper=this.context.createWaveShaper(),this.input=this._shaper,this.output=this._shaper;const s=optionsFromArguments(WaveShaper.getDefaults(),arguments,["mapping","length"]);isArray(s.mapping)||s.mapping instanceof Float32Array?this.curve=Float32Array.from(s.mapping):isFunction(s.mapping)&&this.setMap(s.mapping,s.length)}static getDefaults(){return Object.assign(Signal.getDefaults(),{length:1024})}setMap(s,i=1024){const a=new Float32Array(i);for(let u=0,l=i;u<l;u++){const d=u/(l-1)*2-1;a[u]=s(d,u)}return this.curve=a,this}get curve(){return this._shaper.curve}set curve(s){this._shaper.curve=s}get oversample(){return this._shaper.oversample}set oversample(s){const i=["none","2x","4x"].some(a=>a.includes(s));assert(i,"oversampling must be either 'none', '2x', or '4x'"),this._shaper.oversample=s}dispose(){return super.dispose(),this._shaper.disconnect(),this}}class AudioToGain extends SignalOperator{constructor(){super(...arguments),this.name="AudioToGain",this._norm=new WaveShaper({context:this.context,mapping:s=>(s+1)/2}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Multiply extends Signal{constructor(){super(Object.assign(optionsFromArguments(Multiply.getDefaults(),arguments,["value"]))),this.name="Multiply",this.override=!1;const s=optionsFromArguments(Multiply.getDefaults(),arguments,["value"]);this._mult=this.input=this.output=new Gain({context:this.context,minValue:s.minValue,maxValue:s.maxValue}),this.factor=this._param=this._mult.gain,this.factor.setValueAtTime(s.value,0)}static getDefaults(){return Object.assign(Signal.getDefaults(),{value:0})}dispose(){return super.dispose(),this._mult.dispose(),this}}class AMOscillator extends Source{constructor(){super(optionsFromArguments(AMOscillator.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="AMOscillator",this._modulationScale=new AudioToGain({context:this.context}),this._modulationNode=new Gain({context:this.context});const s=optionsFromArguments(AMOscillator.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new Oscillator({context:this.context,detune:s.detune,frequency:s.frequency,onstop:()=>this.onstop(this),phase:s.phase,type:s.type}),this.frequency=this._carrier.frequency,this.detune=this._carrier.detune,this._modulator=new Oscillator({context:this.context,phase:s.phase,type:s.modulationType}),this.harmonicity=new Multiply({context:this.context,units:"positive",value:s.harmonicity}),this.frequency.chain(this.harmonicity,this._modulator.frequency),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output),readOnly(this,["frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{harmonicity:1,modulationType:"square"})}_start(s){this._modulator.start(s),this._carrier.start(s)}_stop(s){this._modulator.stop(s),this._carrier.stop(s)}_restart(s){this._modulator.restart(s),this._carrier.restart(s)}get type(){return this._carrier.type}set type(s){this._carrier.type=s}get baseType(){return this._carrier.baseType}set baseType(s){this._carrier.baseType=s}get partialCount(){return this._carrier.partialCount}set partialCount(s){this._carrier.partialCount=s}get modulationType(){return this._modulator.type}set modulationType(s){this._modulator.type=s}get phase(){return this._carrier.phase}set phase(s){this._carrier.phase=s,this._modulator.phase=s}get partials(){return this._carrier.partials}set partials(s){this._carrier.partials=s}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this._modulationScale.dispose(),this}}class FMOscillator extends Source{constructor(){super(optionsFromArguments(FMOscillator.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="FMOscillator",this._modulationNode=new Gain({context:this.context,gain:0});const s=optionsFromArguments(FMOscillator.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new Oscillator({context:this.context,detune:s.detune,frequency:0,onstop:()=>this.onstop(this),phase:s.phase,type:s.type}),this.detune=this._carrier.detune,this.frequency=new Signal({context:this.context,units:"frequency",value:s.frequency}),this._modulator=new Oscillator({context:this.context,phase:s.phase,type:s.modulationType}),this.harmonicity=new Multiply({context:this.context,units:"positive",value:s.harmonicity}),this.modulationIndex=new Multiply({context:this.context,units:"positive",value:s.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output),this.detune.connect(this._modulator.detune),readOnly(this,["modulationIndex","frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{harmonicity:1,modulationIndex:2,modulationType:"square"})}_start(s){this._modulator.start(s),this._carrier.start(s)}_stop(s){this._modulator.stop(s),this._carrier.stop(s)}_restart(s){return this._modulator.restart(s),this._carrier.restart(s),this}get type(){return this._carrier.type}set type(s){this._carrier.type=s}get baseType(){return this._carrier.baseType}set baseType(s){this._carrier.baseType=s}get partialCount(){return this._carrier.partialCount}set partialCount(s){this._carrier.partialCount=s}get modulationType(){return this._modulator.type}set modulationType(s){this._modulator.type=s}get phase(){return this._carrier.phase}set phase(s){this._carrier.phase=s,this._modulator.phase=s}get partials(){return this._carrier.partials}set partials(s){this._carrier.partials=s}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this.frequency.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this.modulationIndex.dispose(),this}}class PulseOscillator extends Source{constructor(){super(optionsFromArguments(PulseOscillator.getDefaults(),arguments,["frequency","width"])),this.name="PulseOscillator",this._widthGate=new Gain({context:this.context,gain:0}),this._thresh=new WaveShaper({context:this.context,mapping:i=>i<=0?-1:1});const s=optionsFromArguments(PulseOscillator.getDefaults(),arguments,["frequency","width"]);this.width=new Signal({context:this.context,units:"audioRange",value:s.width}),this._triangle=new Oscillator({context:this.context,detune:s.detune,frequency:s.frequency,onstop:()=>this.onstop(this),phase:s.phase,type:"triangle"}),this.frequency=this._triangle.frequency,this.detune=this._triangle.detune,this._triangle.chain(this._thresh,this.output),this.width.chain(this._widthGate,this._thresh),readOnly(this,["width","frequency","detune"])}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,phase:0,type:"pulse",width:.2})}_start(s){s=this.toSeconds(s),this._triangle.start(s),this._widthGate.gain.setValueAtTime(1,s)}_stop(s){s=this.toSeconds(s),this._triangle.stop(s),this._widthGate.gain.cancelScheduledValues(s),this._widthGate.gain.setValueAtTime(0,s)}_restart(s){this._triangle.restart(s),this._widthGate.gain.cancelScheduledValues(s),this._widthGate.gain.setValueAtTime(1,s)}get phase(){return this._triangle.phase}set phase(s){this._triangle.phase=s}get type(){return"pulse"}get baseType(){return"pulse"}get partials(){return[]}get partialCount(){return 0}set carrierType(s){this._triangle.type=s}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this._triangle.dispose(),this.width.dispose(),this._widthGate.dispose(),this._thresh.dispose(),this}}class FatOscillator extends Source{constructor(){super(optionsFromArguments(FatOscillator.getDefaults(),arguments,["frequency","type","spread"])),this.name="FatOscillator",this._oscillators=[];const s=optionsFromArguments(FatOscillator.getDefaults(),arguments,["frequency","type","spread"]);this.frequency=new Signal({context:this.context,units:"frequency",value:s.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:s.detune}),this._spread=s.spread,this._type=s.type,this._phase=s.phase,this._partials=s.partials,this._partialCount=s.partialCount,this.count=s.count,readOnly(this,["frequency","detune"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{count:3,spread:20,type:"sawtooth"})}_start(s){s=this.toSeconds(s),this._forEach(i=>i.start(s))}_stop(s){s=this.toSeconds(s),this._forEach(i=>i.stop(s))}_restart(s){this._forEach(i=>i.restart(s))}_forEach(s){for(let i=0;i<this._oscillators.length;i++)s(this._oscillators[i],i)}get type(){return this._type}set type(s){this._type=s,this._forEach(i=>i.type=s)}get spread(){return this._spread}set spread(s){if(this._spread=s,this._oscillators.length>1){const i=-s/2,a=s/(this._oscillators.length-1);this._forEach((u,l)=>u.detune.value=i+a*l)}}get count(){return this._oscillators.length}set count(s){if(assertRange(s,1),this._oscillators.length!==s){this._forEach(i=>i.dispose()),this._oscillators=[];for(let i=0;i<s;i++){const a=new Oscillator({context:this.context,volume:-6-s*1.1,type:this._type,phase:this._phase+i/s*360,partialCount:this._partialCount,onstop:i===0?()=>this.onstop(this):noOp});this.type==="custom"&&(a.partials=this._partials),this.frequency.connect(a.frequency),this.detune.connect(a.detune),a.detune.overridden=!1,a.connect(this.output),this._oscillators[i]=a}this.spread=this._spread,this.state==="started"&&this._forEach(i=>i.start())}}get phase(){return this._phase}set phase(s){this._phase=s,this._forEach((i,a)=>i.phase=this._phase+a/this.count*360)}get baseType(){return this._oscillators[0].baseType}set baseType(s){this._forEach(i=>i.baseType=s),this._type=this._oscillators[0].type}get partials(){return this._oscillators[0].partials}set partials(s){this._partials=s,this._partialCount=this._partials.length,s.length&&(this._type="custom",this._forEach(i=>i.partials=s))}get partialCount(){return this._oscillators[0].partialCount}set partialCount(s){this._partialCount=s,this._forEach(i=>i.partialCount=s),this._type=this._oscillators[0].type}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this._forEach(s=>s.dispose()),this}}class PWMOscillator extends Source{constructor(){super(optionsFromArguments(PWMOscillator.getDefaults(),arguments,["frequency","modulationFrequency"])),this.name="PWMOscillator",this.sourceType="pwm",this._scale=new Multiply({context:this.context,value:2});const s=optionsFromArguments(PWMOscillator.getDefaults(),arguments,["frequency","modulationFrequency"]);this._pulse=new PulseOscillator({context:this.context,frequency:s.modulationFrequency}),this._pulse.carrierType="sine",this.modulationFrequency=this._pulse.frequency,this._modulator=new Oscillator({context:this.context,detune:s.detune,frequency:s.frequency,onstop:()=>this.onstop(this),phase:s.phase}),this.frequency=this._modulator.frequency,this.detune=this._modulator.detune,this._modulator.chain(this._scale,this._pulse.width),this._pulse.connect(this.output),readOnly(this,["modulationFrequency","frequency","detune"])}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,modulationFrequency:.4,phase:0,type:"pwm"})}_start(s){s=this.toSeconds(s),this._modulator.start(s),this._pulse.start(s)}_stop(s){s=this.toSeconds(s),this._modulator.stop(s),this._pulse.stop(s)}_restart(s){this._modulator.restart(s),this._pulse.restart(s)}get type(){return"pwm"}get baseType(){return"pwm"}get partials(){return[]}get partialCount(){return 0}get phase(){return this._modulator.phase}set phase(s){this._modulator.phase=s}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this._pulse.dispose(),this._scale.dispose(),this._modulator.dispose(),this}}const OmniOscillatorSourceMap={am:AMOscillator,fat:FatOscillator,fm:FMOscillator,oscillator:Oscillator,pulse:PulseOscillator,pwm:PWMOscillator};class OmniOscillator extends Source{constructor(){super(optionsFromArguments(OmniOscillator.getDefaults(),arguments,["frequency","type"])),this.name="OmniOscillator";const s=optionsFromArguments(OmniOscillator.getDefaults(),arguments,["frequency","type"]);this.frequency=new Signal({context:this.context,units:"frequency",value:s.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:s.detune}),readOnly(this,["frequency","detune"]),this.set(s)}static getDefaults(){return Object.assign(Oscillator.getDefaults(),FMOscillator.getDefaults(),AMOscillator.getDefaults(),FatOscillator.getDefaults(),PulseOscillator.getDefaults(),PWMOscillator.getDefaults())}_start(s){this._oscillator.start(s)}_stop(s){this._oscillator.stop(s)}_restart(s){return this._oscillator.restart(s),this}get type(){let s="";return["am","fm","fat"].some(i=>this._sourceType===i)&&(s=this._sourceType),s+this._oscillator.type}set type(s){s.substr(0,2)==="fm"?(this._createNewOscillator("fm"),this._oscillator=this._oscillator,this._oscillator.type=s.substr(2)):s.substr(0,2)==="am"?(this._createNewOscillator("am"),this._oscillator=this._oscillator,this._oscillator.type=s.substr(2)):s.substr(0,3)==="fat"?(this._createNewOscillator("fat"),this._oscillator=this._oscillator,this._oscillator.type=s.substr(3)):s==="pwm"?(this._createNewOscillator("pwm"),this._oscillator=this._oscillator):s==="pulse"?this._createNewOscillator("pulse"):(this._createNewOscillator("oscillator"),this._oscillator=this._oscillator,this._oscillator.type=s)}get partials(){return this._oscillator.partials}set partials(s){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partials=s)}get partialCount(){return this._oscillator.partialCount}set partialCount(s){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partialCount=s)}set(s){return Reflect.has(s,"type")&&s.type&&(this.type=s.type),super.set(s),this}_createNewOscillator(s){if(s!==this._sourceType){this._sourceType=s;const i=OmniOscillatorSourceMap[s],a=this.now();if(this._oscillator){const u=this._oscillator;u.stop(a),this.context.setTimeout(()=>u.dispose(),this.blockTime)}this._oscillator=new i({context:this.context}),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.connect(this.output),this._oscillator.onstop=()=>this.onstop(this),this.state==="started"&&this._oscillator.start(a)}}get phase(){return this._oscillator.phase}set phase(s){this._oscillator.phase=s}get sourceType(){return this._sourceType}set sourceType(s){let i="sine";this._oscillator.type!=="pwm"&&this._oscillator.type!=="pulse"&&(i=this._oscillator.type),s==="fm"?this.type="fm"+i:s==="am"?this.type="am"+i:s==="fat"?this.type="fat"+i:s==="oscillator"?this.type=i:s==="pulse"?this.type="pulse":s==="pwm"&&(this.type="pwm")}_getOscType(s,i){return s instanceof OmniOscillatorSourceMap[i]}get baseType(){return this._oscillator.baseType}set baseType(s){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&s!=="pulse"&&s!=="pwm"&&(this._oscillator.baseType=s)}get width(){if(this._getOscType(this._oscillator,"pulse"))return this._oscillator.width}get count(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.count}set count(s){this._getOscType(this._oscillator,"fat")&&isNumber(s)&&(this._oscillator.count=s)}get spread(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.spread}set spread(s){this._getOscType(this._oscillator,"fat")&&isNumber(s)&&(this._oscillator.spread=s)}get modulationType(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.modulationType}set modulationType(s){(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))&&isString(s)&&(this._oscillator.modulationType=s)}get modulationIndex(){if(this._getOscType(this._oscillator,"fm"))return this._oscillator.modulationIndex}get harmonicity(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.harmonicity}get modulationFrequency(){if(this._getOscType(this._oscillator,"pwm"))return this._oscillator.modulationFrequency}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,s)})}dispose(){return super.dispose(),this.detune.dispose(),this.frequency.dispose(),this._oscillator.dispose(),this}}class Add extends Signal{constructor(){super(Object.assign(optionsFromArguments(Add.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Add",this._sum=new Gain({context:this.context}),this.input=this._sum,this.output=this._sum,this.addend=this._param,connectSeries(this._constantSource,this._sum)}static getDefaults(){return Object.assign(Signal.getDefaults(),{value:0})}dispose(){return super.dispose(),this._sum.dispose(),this}}class Scale extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(Scale.getDefaults(),arguments,["min","max"]))),this.name="Scale";const s=optionsFromArguments(Scale.getDefaults(),arguments,["min","max"]);this._mult=this.input=new Multiply({context:this.context,value:s.max-s.min}),this._add=this.output=new Add({context:this.context,value:s.min}),this._min=s.min,this._max=s.max,this.input.connect(this.output)}static getDefaults(){return Object.assign(SignalOperator.getDefaults(),{max:1,min:0})}get min(){return this._min}set min(s){this._min=s,this._setRange()}get max(){return this._max}set max(s){this._max=s,this._setRange()}_setRange(){this._add.value=this._min,this._mult.value=this._max-this._min}dispose(){return super.dispose(),this._add.dispose(),this._mult.dispose(),this}}class Zero extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(Zero.getDefaults(),arguments))),this.name="Zero",this._gain=new Gain({context:this.context}),this.output=this._gain,this.input=void 0,connect(this.context.getConstant(0),this._gain)}dispose(){return super.dispose(),disconnect(this.context.getConstant(0),this._gain),this}}class LFO extends ToneAudioNode{constructor(){super(optionsFromArguments(LFO.getDefaults(),arguments,["frequency","min","max"])),this.name="LFO",this._stoppedValue=0,this._units="number",this.convert=!0,this._fromType=Param.prototype._fromType,this._toType=Param.prototype._toType,this._is=Param.prototype._is,this._clampValue=Param.prototype._clampValue;const s=optionsFromArguments(LFO.getDefaults(),arguments,["frequency","min","max"]);this._oscillator=new Oscillator(s),this.frequency=this._oscillator.frequency,this._amplitudeGain=new Gain({context:this.context,gain:s.amplitude,units:"normalRange"}),this.amplitude=this._amplitudeGain.gain,this._stoppedSignal=new Signal({context:this.context,units:"audioRange",value:0}),this._zeros=new Zero({context:this.context}),this._a2g=new AudioToGain({context:this.context}),this._scaler=this.output=new Scale({context:this.context,max:s.max,min:s.min}),this.units=s.units,this.min=s.min,this.max=s.max,this._oscillator.chain(this._amplitudeGain,this._a2g,this._scaler),this._zeros.connect(this._a2g),this._stoppedSignal.connect(this._a2g),readOnly(this,["amplitude","frequency"]),this.phase=s.phase}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{amplitude:1,frequency:"4n",max:1,min:0,type:"sine",units:"number"})}start(s){return s=this.toSeconds(s),this._stoppedSignal.setValueAtTime(0,s),this._oscillator.start(s),this}stop(s){return s=this.toSeconds(s),this._stoppedSignal.setValueAtTime(this._stoppedValue,s),this._oscillator.stop(s),this}sync(){return this._oscillator.sync(),this._oscillator.syncFrequency(),this}unsync(){return this._oscillator.unsync(),this._oscillator.unsyncFrequency(),this}_setStoppedValue(){this._stoppedValue=this._oscillator.getInitialValue(),this._stoppedSignal.value=this._stoppedValue}get min(){return this._toType(this._scaler.min)}set min(s){s=this._fromType(s),this._scaler.min=s}get max(){return this._toType(this._scaler.max)}set max(s){s=this._fromType(s),this._scaler.max=s}get type(){return this._oscillator.type}set type(s){this._oscillator.type=s,this._setStoppedValue()}get partials(){return this._oscillator.partials}set partials(s){this._oscillator.partials=s,this._setStoppedValue()}get phase(){return this._oscillator.phase}set phase(s){this._oscillator.phase=s,this._setStoppedValue()}get units(){return this._units}set units(s){const i=this.min,a=this.max;this._units=s,this.min=i,this.max=a}get state(){return this._oscillator.state}connect(s,i,a){return(s instanceof Param||s instanceof Signal)&&(this.convert=s.convert,this.units=s.units),connectSignal(this,s,i,a),this}dispose(){return super.dispose(),this._oscillator.dispose(),this._stoppedSignal.dispose(),this._zeros.dispose(),this._scaler.dispose(),this._a2g.dispose(),this._amplitudeGain.dispose(),this.amplitude.dispose(),this}}function range(c,s=1/0){const i=new WeakMap;return function(a,u){Reflect.defineProperty(a,u,{configurable:!0,enumerable:!0,get:function(){return i.get(this)},set:function(l){assertRange(l,c,s),i.set(this,l)}})}}function timeRange(c,s=1/0){const i=new WeakMap;return function(a,u){Reflect.defineProperty(a,u,{configurable:!0,enumerable:!0,get:function(){return i.get(this)},set:function(l){assertRange(this.toSeconds(l),c,s),i.set(this,l)}})}}let Player$1=class he extends Source{constructor(){super(optionsFromArguments(he.getDefaults(),arguments,["url","onload"])),this.name="Player",this._activeSources=new Set;const s=optionsFromArguments(he.getDefaults(),arguments,["url","onload"]);this._buffer=new ToneAudioBuffer({onload:this._onload.bind(this,s.onload),onerror:s.onerror,reverse:s.reverse,url:s.url}),this.autostart=s.autostart,this._loop=s.loop,this._loopStart=s.loopStart,this._loopEnd=s.loopEnd,this._playbackRate=s.playbackRate,this.fadeIn=s.fadeIn,this.fadeOut=s.fadeOut}static getDefaults(){return Object.assign(Source.getDefaults(),{autostart:!1,fadeIn:0,fadeOut:0,loop:!1,loopEnd:0,loopStart:0,onload:noOp,onerror:noOp,playbackRate:1,reverse:!1})}load(s){return __awaiter(this,void 0,void 0,function*(){return yield this._buffer.load(s),this._onload(),this})}_onload(s=noOp){s(),this.autostart&&this.start()}_onSourceEnd(s){this.onstop(this),this._activeSources.delete(s),this._activeSources.size===0&&!this._synced&&this._state.getValueAtTime(this.now())==="started"&&(this._state.cancel(this.now()),this._state.setStateAtTime("stopped",this.now()))}start(s,i,a){return super.start(s,i,a),this}_start(s,i,a){this._loop?i=defaultArg(i,this._loopStart):i=defaultArg(i,0);const u=this.toSeconds(i),l=a;a=defaultArg(a,Math.max(this._buffer.duration-u,0));let d=this.toSeconds(a);d=d/this._playbackRate,s=this.toSeconds(s);const h=new ToneBufferSource({url:this._buffer,context:this.context,fadeIn:this.fadeIn,fadeOut:this.fadeOut,loop:this._loop,loopEnd:this._loopEnd,loopStart:this._loopStart,onended:this._onSourceEnd.bind(this),playbackRate:this._playbackRate}).connect(this.output);!this._loop&&!this._synced&&(this._state.cancel(s+d),this._state.setStateAtTime("stopped",s+d,{implicitEnd:!0})),this._activeSources.add(h),this._loop&&isUndef(l)?h.start(s,u):h.start(s,u,d-this.toSeconds(this.fadeOut))}_stop(s){const i=this.toSeconds(s);this._activeSources.forEach(a=>a.stop(i))}restart(s,i,a){return super.restart(s,i,a),this}_restart(s,i,a){this._stop(s),this._start(s,i,a)}seek(s,i){const a=this.toSeconds(i);if(this._state.getValueAtTime(a)==="started"){const u=this.toSeconds(s);this._stop(a),this._start(a,u)}return this}setLoopPoints(s,i){return this.loopStart=s,this.loopEnd=i,this}get loopStart(){return this._loopStart}set loopStart(s){this._loopStart=s,this.buffer.loaded&&assertRange(this.toSeconds(s),0,this.buffer.duration),this._activeSources.forEach(i=>{i.loopStart=s})}get loopEnd(){return this._loopEnd}set loopEnd(s){this._loopEnd=s,this.buffer.loaded&&assertRange(this.toSeconds(s),0,this.buffer.duration),this._activeSources.forEach(i=>{i.loopEnd=s})}get buffer(){return this._buffer}set buffer(s){this._buffer.set(s)}get loop(){return this._loop}set loop(s){if(this._loop!==s&&(this._loop=s,this._activeSources.forEach(i=>{i.loop=s}),s)){const i=this._state.getNextState("stopped",this.now());i&&this._state.cancel(i.time)}}get playbackRate(){return this._playbackRate}set playbackRate(s){this._playbackRate=s;const i=this.now(),a=this._state.getNextState("stopped",i);a&&a.implicitEnd&&(this._state.cancel(a.time),this._activeSources.forEach(u=>u.cancelStop())),this._activeSources.forEach(u=>{u.playbackRate.setValueAtTime(s,i)})}get reverse(){return this._buffer.reverse}set reverse(s){this._buffer.reverse=s}get loaded(){return this._buffer.loaded}dispose(){return super.dispose(),this._activeSources.forEach(s=>s.dispose()),this._activeSources.clear(),this._buffer.dispose(),this}};__decorate([timeRange(0)],Player$1.prototype,"fadeIn",void 0);__decorate([timeRange(0)],Player$1.prototype,"fadeOut",void 0);class GainToAudio extends SignalOperator{constructor(){super(...arguments),this.name="GainToAudio",this._norm=new WaveShaper({context:this.context,mapping:s=>Math.abs(s)*2-1}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Envelope extends ToneAudioNode{constructor(){super(optionsFromArguments(Envelope.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="Envelope",this._sig=new Signal({context:this.context,value:0}),this.output=this._sig,this.input=void 0;const s=optionsFromArguments(Envelope.getDefaults(),arguments,["attack","decay","sustain","release"]);this.attack=s.attack,this.decay=s.decay,this.sustain=s.sustain,this.release=s.release,this.attackCurve=s.attackCurve,this.releaseCurve=s.releaseCurve,this.decayCurve=s.decayCurve}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{attack:.01,attackCurve:"linear",decay:.1,decayCurve:"exponential",release:1,releaseCurve:"exponential",sustain:.5})}get value(){return this.getValueAtTime(this.now())}_getCurve(s,i){if(isString(s))return s;{let a;for(a in EnvelopeCurves)if(EnvelopeCurves[a][i]===s)return a;return s}}_setCurve(s,i,a){if(isString(a)&&Reflect.has(EnvelopeCurves,a)){const u=EnvelopeCurves[a];isObject(u)?s!=="_decayCurve"&&(this[s]=u[i]):this[s]=u}else if(isArray(a)&&s!=="_decayCurve")this[s]=a;else throw new Error("Envelope: invalid curve: "+a)}get attackCurve(){return this._getCurve(this._attackCurve,"In")}set attackCurve(s){this._setCurve("_attackCurve","In",s)}get releaseCurve(){return this._getCurve(this._releaseCurve,"Out")}set releaseCurve(s){this._setCurve("_releaseCurve","Out",s)}get decayCurve(){return this._decayCurve}set decayCurve(s){assert(["linear","exponential"].some(i=>i===s),`Invalid envelope curve: ${s}`),this._decayCurve=s}triggerAttack(s,i=1){this.log("triggerAttack",s,i),s=this.toSeconds(s);let u=this.toSeconds(this.attack);const l=this.toSeconds(this.decay),d=this.getValueAtTime(s);if(d>0){const h=1/u;u=(1-d)/h}if(u<this.sampleTime)this._sig.cancelScheduledValues(s),this._sig.setValueAtTime(i,s);else if(this._attackCurve==="linear")this._sig.linearRampTo(i,u,s);else if(this._attackCurve==="exponential")this._sig.targetRampTo(i,u,s);else{this._sig.cancelAndHoldAtTime(s);let h=this._attackCurve;for(let f=1;f<h.length;f++)if(h[f-1]<=d&&d<=h[f]){h=this._attackCurve.slice(f),h[0]=d;break}this._sig.setValueCurveAtTime(h,s,u,i)}if(l&&this.sustain<1){const h=i*this.sustain,f=s+u;this.log("decay",f),this._decayCurve==="linear"?this._sig.linearRampToValueAtTime(h,l+f):this._sig.exponentialApproachValueAtTime(h,f,l)}return this}triggerRelease(s){this.log("triggerRelease",s),s=this.toSeconds(s);const i=this.getValueAtTime(s);if(i>0){const a=this.toSeconds(this.release);a<this.sampleTime?this._sig.setValueAtTime(0,s):this._releaseCurve==="linear"?this._sig.linearRampTo(0,a,s):this._releaseCurve==="exponential"?this._sig.targetRampTo(0,a,s):(assert(isArray(this._releaseCurve),"releaseCurve must be either 'linear', 'exponential' or an array"),this._sig.cancelAndHoldAtTime(s),this._sig.setValueCurveAtTime(this._releaseCurve,s,a,i))}return this}getValueAtTime(s){return this._sig.getValueAtTime(s)}triggerAttackRelease(s,i,a=1){return i=this.toSeconds(i),this.triggerAttack(i,a),this.triggerRelease(i+this.toSeconds(s)),this}cancel(s){return this._sig.cancelScheduledValues(this.toSeconds(s)),this}connect(s,i=0,a=0){return connectSignal(this,s,i,a),this}asArray(s=1024){return __awaiter(this,void 0,void 0,function*(){const i=s/this.context.sampleRate,a=new OfflineContext(1,i,this.context.sampleRate),u=this.toSeconds(this.attack)+this.toSeconds(this.decay),l=u+this.toSeconds(this.release),d=l*.1,h=l+d,f=new this.constructor(Object.assign(this.get(),{attack:i*this.toSeconds(this.attack)/h,decay:i*this.toSeconds(this.decay)/h,release:i*this.toSeconds(this.release)/h,context:a}));return f._sig.toDestination(),f.triggerAttackRelease(i*(u+d)/h,0),(yield a.render()).getChannelData(0)})}dispose(){return super.dispose(),this._sig.dispose(),this}}__decorate([timeRange(0)],Envelope.prototype,"attack",void 0);__decorate([timeRange(0)],Envelope.prototype,"decay",void 0);__decorate([range(0,1)],Envelope.prototype,"sustain",void 0);__decorate([timeRange(0)],Envelope.prototype,"release",void 0);const EnvelopeCurves=(()=>{let s,i;const a=[];for(s=0;s<128;s++)a[s]=Math.sin(s/(128-1)*(Math.PI/2));const u=[],l=6.4;for(s=0;s<128-1;s++){i=s/(128-1);const _=Math.sin(i*(Math.PI*2)*l-Math.PI/2)+1;u[s]=_/10+i*.83}u[128-1]=1;const d=[],h=5;for(s=0;s<128;s++)d[s]=Math.ceil(s/(128-1)*h)/h;const f=[];for(s=0;s<128;s++)i=s/(128-1),f[s]=.5*(1-Math.cos(Math.PI*i));const p=[];for(s=0;s<128;s++){i=s/(128-1);const _=Math.pow(i,3)*4+.2,v=Math.cos(_*Math.PI*2*i);p[s]=Math.abs(v*(1-i))}function g(_){const v=new Array(_.length);for(let y=0;y<_.length;y++)v[y]=1-_[y];return v}function m(_){return _.slice(0).reverse()}return{bounce:{In:g(p),Out:p},cosine:{In:a,Out:m(a)},exponential:"exponential",linear:"linear",ripple:{In:u,Out:g(u)},sine:{In:f,Out:g(f)},step:{In:d,Out:g(d)}}})();class Instrument extends ToneAudioNode{constructor(){super(optionsFromArguments(Instrument.getDefaults(),arguments)),this._scheduledEvents=[],this._synced=!1,this._original_triggerAttack=this.triggerAttack,this._original_triggerRelease=this.triggerRelease;const s=optionsFromArguments(Instrument.getDefaults(),arguments);this._volume=this.output=new Volume({context:this.context,volume:s.volume}),this.volume=this._volume.volume,readOnly(this,"volume")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{volume:0})}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",0)),this}_syncState(){let s=!1;return this._synced||(this._synced=!0,s=!0),s}_syncMethod(s,i){const a=this["_original_"+s]=this[s];this[s]=(...u)=>{const l=u[i],d=this.context.transport.schedule(h=>{u[i]=h,a.apply(this,u)},l);this._scheduledEvents.push(d)}}unsync(){return this._scheduledEvents.forEach(s=>this.context.transport.clear(s)),this._scheduledEvents=[],this._synced&&(this._synced=!1,this.triggerAttack=this._original_triggerAttack,this.triggerRelease=this._original_triggerRelease),this}triggerAttackRelease(s,i,a,u){const l=this.toSeconds(a),d=this.toSeconds(i);return this.triggerAttack(s,l,u),this.triggerRelease(l+d),this}dispose(){return super.dispose(),this._volume.dispose(),this.unsync(),this._scheduledEvents=[],this}}class Monophonic extends Instrument{constructor(){super(optionsFromArguments(Monophonic.getDefaults(),arguments));const s=optionsFromArguments(Monophonic.getDefaults(),arguments);this.portamento=s.portamento,this.onsilence=s.onsilence}static getDefaults(){return Object.assign(Instrument.getDefaults(),{detune:0,onsilence:noOp,portamento:0})}triggerAttack(s,i,a=1){this.log("triggerAttack",s,i,a);const u=this.toSeconds(i);return this._triggerEnvelopeAttack(u,a),this.setNote(s,u),this}triggerRelease(s){this.log("triggerRelease",s);const i=this.toSeconds(s);return this._triggerEnvelopeRelease(i),this}setNote(s,i){const a=this.toSeconds(i),u=s instanceof FrequencyClass?s.toFrequency():s;if(this.portamento>0&&this.getLevelAtTime(a)>.05){const l=this.toSeconds(this.portamento);this.frequency.exponentialRampTo(u,l,a)}else this.frequency.setValueAtTime(u,a);return this}}__decorate([timeRange(0)],Monophonic.prototype,"portamento",void 0);class AmplitudeEnvelope extends Envelope{constructor(){super(optionsFromArguments(AmplitudeEnvelope.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="AmplitudeEnvelope",this._gainNode=new Gain({context:this.context,gain:0}),this.output=this._gainNode,this.input=this._gainNode,this._sig.connect(this._gainNode.gain),this.output=this._gainNode,this.input=this._gainNode}dispose(){return super.dispose(),this._gainNode.dispose(),this}}class Synth extends Monophonic{constructor(){super(optionsFromArguments(Synth.getDefaults(),arguments)),this.name="Synth";const s=optionsFromArguments(Synth.getDefaults(),arguments);this.oscillator=new OmniOscillator(Object.assign({context:this.context,detune:s.detune,onstop:()=>this.onsilence(this)},s.oscillator)),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.envelope=new AmplitudeEnvelope(Object.assign({context:this.context},s.envelope)),this.oscillator.chain(this.envelope,this.output),readOnly(this,["oscillator","frequency","detune","envelope"])}static getDefaults(){return Object.assign(Monophonic.getDefaults(),{envelope:Object.assign(omitFromObject(Envelope.getDefaults(),Object.keys(ToneAudioNode.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.3}),oscillator:Object.assign(omitFromObject(OmniOscillator.getDefaults(),[...Object.keys(Source.getDefaults()),"frequency","detune"]),{type:"triangle"})})}_triggerEnvelopeAttack(s,i){if(this.envelope.triggerAttack(s,i),this.oscillator.start(s),this.envelope.sustain===0){const a=this.toSeconds(this.envelope.attack),u=this.toSeconds(this.envelope.decay);this.oscillator.stop(s+a+u)}}_triggerEnvelopeRelease(s){this.envelope.triggerRelease(s),this.oscillator.stop(s+this.toSeconds(this.envelope.release))}getLevelAtTime(s){return s=this.toSeconds(s),this.envelope.getValueAtTime(s)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this}}class BiquadFilter extends ToneAudioNode{constructor(){super(optionsFromArguments(BiquadFilter.getDefaults(),arguments,["frequency","type"])),this.name="BiquadFilter";const s=optionsFromArguments(BiquadFilter.getDefaults(),arguments,["frequency","type"]);this._filter=this.context.createBiquadFilter(),this.input=this.output=this._filter,this.Q=new Param({context:this.context,units:"number",value:s.Q,param:this._filter.Q}),this.frequency=new Param({context:this.context,units:"frequency",value:s.frequency,param:this._filter.frequency}),this.detune=new Param({context:this.context,units:"cents",value:s.detune,param:this._filter.detune}),this.gain=new Param({context:this.context,units:"decibels",convert:!1,value:s.gain,param:this._filter.gain}),this.type=s.type}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{Q:1,type:"lowpass",frequency:350,detune:0,gain:0})}get type(){return this._filter.type}set type(s){assert(["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(s)!==-1,`Invalid filter type: ${s}`),this._filter.type=s}getFrequencyResponse(s=128){const i=new Float32Array(s);for(let d=0;d<s;d++){const f=Math.pow(d/s,2)*(2e4-20)+20;i[d]=f}const a=new Float32Array(s),u=new Float32Array(s),l=this.context.createBiquadFilter();return l.type=this.type,l.Q.value=this.Q.value,l.frequency.value=this.frequency.value,l.gain.value=this.gain.value,l.getFrequencyResponse(i,a,u),a}dispose(){return super.dispose(),this._filter.disconnect(),this.Q.dispose(),this.frequency.dispose(),this.gain.dispose(),this.detune.dispose(),this}}class Filter extends ToneAudioNode{constructor(){super(optionsFromArguments(Filter.getDefaults(),arguments,["frequency","type","rolloff"])),this.name="Filter",this.input=new Gain({context:this.context}),this.output=new Gain({context:this.context}),this._filters=[];const s=optionsFromArguments(Filter.getDefaults(),arguments,["frequency","type","rolloff"]);this._filters=[],this.Q=new Signal({context:this.context,units:"positive",value:s.Q}),this.frequency=new Signal({context:this.context,units:"frequency",value:s.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:s.detune}),this.gain=new Signal({context:this.context,units:"decibels",convert:!1,value:s.gain}),this._type=s.type,this.rolloff=s.rolloff,readOnly(this,["detune","frequency","gain","Q"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{Q:1,detune:0,frequency:350,gain:0,rolloff:-12,type:"lowpass"})}get type(){return this._type}set type(s){assert(["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(s)!==-1,`Invalid filter type: ${s}`),this._type=s,this._filters.forEach(a=>a.type=s)}get rolloff(){return this._rolloff}set rolloff(s){const i=isNumber(s)?s:parseInt(s,10),a=[-12,-24,-48,-96];let u=a.indexOf(i);assert(u!==-1,`rolloff can only be ${a.join(", ")}`),u+=1,this._rolloff=i,this.input.disconnect(),this._filters.forEach(l=>l.disconnect()),this._filters=new Array(u);for(let l=0;l<u;l++){const d=new BiquadFilter({context:this.context});d.type=this._type,this.frequency.connect(d.frequency),this.detune.connect(d.detune),this.Q.connect(d.Q),this.gain.connect(d.gain),this._filters[l]=d}this._internalChannels=this._filters,connectSeries(this.input,...this._internalChannels,this.output)}getFrequencyResponse(s=128){const i=new BiquadFilter({frequency:this.frequency.value,gain:this.gain.value,Q:this.Q.value,type:this._type,detune:this.detune.value}),a=new Float32Array(s).map(()=>1);return this._filters.forEach(()=>{i.getFrequencyResponse(s).forEach((l,d)=>a[d]*=l)}),i.dispose(),a}dispose(){return super.dispose(),this._filters.forEach(s=>{s.dispose()}),writable(this,["detune","frequency","gain","Q"]),this.frequency.dispose(),this.Q.dispose(),this.detune.dispose(),this.gain.dispose(),this}}class MembraneSynth extends Synth{constructor(){super(optionsFromArguments(MembraneSynth.getDefaults(),arguments)),this.name="MembraneSynth",this.portamento=0;const s=optionsFromArguments(MembraneSynth.getDefaults(),arguments);this.pitchDecay=s.pitchDecay,this.octaves=s.octaves,readOnly(this,["oscillator","envelope"])}static getDefaults(){return deepMerge(Monophonic.getDefaults(),Synth.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(s,i){const a=this.toSeconds(i),u=this.toFrequency(s instanceof FrequencyClass?s.toFrequency():s),l=u*this.octaves;return this.oscillator.frequency.setValueAtTime(l,a),this.oscillator.frequency.exponentialRampToValueAtTime(u,a+this.toSeconds(this.pitchDecay)),this}dispose(){return super.dispose(),this}}__decorate([range(0)],MembraneSynth.prototype,"octaves",void 0);__decorate([timeRange(0)],MembraneSynth.prototype,"pitchDecay",void 0);const workletContext=new Set;function addToWorklet(c){workletContext.add(c)}function registerProcessor(c,s){const i=`registerProcessor("${c}", ${s})`;workletContext.add(i)}const toneAudioWorkletProcessor=`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;addToWorklet(toneAudioWorkletProcessor);const singleIOProcess=`
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;addToWorklet(singleIOProcess);const delayLine=`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;addToWorklet(delayLine);const workletName$1="feedback-comb-filter",feedbackCombFilter=`
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;registerProcessor(workletName$1,feedbackCombFilter);class Sampler extends Instrument{constructor(){super(optionsFromArguments(Sampler.getDefaults(),arguments,["urls","onload","baseUrl"],"urls")),this.name="Sampler",this._activeSources=new Map;const s=optionsFromArguments(Sampler.getDefaults(),arguments,["urls","onload","baseUrl"],"urls"),i={};Object.keys(s.urls).forEach(a=>{const u=parseInt(a,10);if(assert(isNote(a)||isNumber(u)&&isFinite(u),`url key is neither a note or midi pitch: ${a}`),isNote(a)){const l=new FrequencyClass(this.context,a).toMidi();i[l]=s.urls[a]}else isNumber(u)&&isFinite(u)&&(i[u]=s.urls[u])}),this._buffers=new ToneAudioBuffers({urls:i,onload:s.onload,baseUrl:s.baseUrl,onerror:s.onerror}),this.attack=s.attack,this.release=s.release,this.curve=s.curve,this._buffers.loaded&&Promise.resolve().then(s.onload)}static getDefaults(){return Object.assign(Instrument.getDefaults(),{attack:0,baseUrl:"",curve:"exponential",onload:noOp,onerror:noOp,release:.1,urls:{}})}_findClosest(s){let a=0;for(;a<96;){if(this._buffers.has(s+a))return-a;if(this._buffers.has(s-a))return a;a++}throw new Error(`No available buffers for note: ${s}`)}triggerAttack(s,i,a=1){return this.log("triggerAttack",s,i,a),Array.isArray(s)||(s=[s]),s.forEach(u=>{const l=ftomf(new FrequencyClass(this.context,u).toFrequency()),d=Math.round(l),h=l-d,f=this._findClosest(d),p=d-f,g=this._buffers.get(p),m=intervalToFrequencyRatio(f+h),_=new ToneBufferSource({url:g,context:this.context,curve:this.curve,fadeIn:this.attack,fadeOut:this.release,playbackRate:m}).connect(this.output);_.start(i,0,g.duration/m,a),isArray(this._activeSources.get(d))||this._activeSources.set(d,[]),this._activeSources.get(d).push(_),_.onended=()=>{if(this._activeSources&&this._activeSources.has(d)){const v=this._activeSources.get(d),y=v.indexOf(_);y!==-1&&v.splice(y,1)}}}),this}triggerRelease(s,i){return this.log("triggerRelease",s,i),Array.isArray(s)||(s=[s]),s.forEach(a=>{const u=new FrequencyClass(this.context,a).toMidi();if(this._activeSources.has(u)&&this._activeSources.get(u).length){const l=this._activeSources.get(u);i=this.toSeconds(i),l.forEach(d=>{d.stop(i)}),this._activeSources.set(u,[])}}),this}releaseAll(s){const i=this.toSeconds(s);return this._activeSources.forEach(a=>{for(;a.length;)a.shift().stop(i)}),this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1)),this}triggerAttackRelease(s,i,a,u=1){const l=this.toSeconds(a);return this.triggerAttack(s,l,u),isArray(i)?(assert(isArray(s),"notes must be an array when duration is array"),s.forEach((d,h)=>{const f=i[Math.min(h,i.length-1)];this.triggerRelease(d,l+this.toSeconds(f))})):this.triggerRelease(s,l+this.toSeconds(i)),this}add(s,i,a){if(assert(isNote(s)||isFinite(s),`note must be a pitch or midi: ${s}`),isNote(s)){const u=new FrequencyClass(this.context,s).toMidi();this._buffers.add(u,i,a)}else this._buffers.add(s,i,a);return this}get loaded(){return this._buffers.loaded}dispose(){return super.dispose(),this._buffers.dispose(),this._activeSources.forEach(s=>{s.forEach(i=>i.dispose())}),this._activeSources.clear(),this}}__decorate([timeRange(0)],Sampler.prototype,"attack",void 0);__decorate([timeRange(0)],Sampler.prototype,"release",void 0);class CrossFade extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(CrossFade.getDefaults(),arguments,["fade"]))),this.name="CrossFade",this._panner=this.context.createStereoPanner(),this._split=this.context.createChannelSplitter(2),this._g2a=new GainToAudio({context:this.context}),this.a=new Gain({context:this.context,gain:0}),this.b=new Gain({context:this.context,gain:0}),this.output=new Gain({context:this.context}),this._internalChannels=[this.a,this.b];const s=optionsFromArguments(CrossFade.getDefaults(),arguments,["fade"]);this.fade=new Signal({context:this.context,units:"normalRange",value:s.fade}),readOnly(this,"fade"),this.context.getConstant(1).connect(this._panner),this._panner.connect(this._split),this._panner.channelCount=1,this._panner.channelCountMode="explicit",connect(this._split,this.a.gain,0),connect(this._split,this.b.gain,1),this.fade.chain(this._g2a,this._panner.pan),this.a.connect(this.output),this.b.connect(this.output)}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{fade:.5})}dispose(){return super.dispose(),this.a.dispose(),this.b.dispose(),this.output.dispose(),this.fade.dispose(),this._g2a.dispose(),this._panner.disconnect(),this._split.disconnect(),this}}class Effect extends ToneAudioNode{constructor(s){super(s),this.name="Effect",this._dryWet=new CrossFade({context:this.context}),this.wet=this._dryWet.fade,this.effectSend=new Gain({context:this.context}),this.effectReturn=new Gain({context:this.context}),this.input=new Gain({context:this.context}),this.output=this._dryWet,this.input.fan(this._dryWet.a,this.effectSend),this.effectReturn.connect(this._dryWet.b),this.wet.setValueAtTime(s.wet,0),this._internalChannels=[this.effectReturn,this.effectSend],readOnly(this,"wet")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{wet:1})}connectEffect(s){return this._internalChannels.push(s),this.effectSend.chain(s,this.effectReturn),this}dispose(){return super.dispose(),this._dryWet.dispose(),this.effectSend.dispose(),this.effectReturn.dispose(),this.wet.dispose(),this}}class LFOEffect extends Effect{constructor(s){super(s),this.name="LFOEffect",this._lfo=new LFO({context:this.context,frequency:s.frequency,amplitude:s.depth}),this.depth=this._lfo.amplitude,this.frequency=this._lfo.frequency,this.type=s.type,readOnly(this,["frequency","depth"])}static getDefaults(){return Object.assign(Effect.getDefaults(),{frequency:1,type:"sine",depth:1})}start(s){return this._lfo.start(s),this}stop(s){return this._lfo.stop(s),this}sync(){return this._lfo.sync(),this}unsync(){return this._lfo.unsync(),this}get type(){return this._lfo.type}set type(s){this._lfo.type=s}dispose(){return super.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class AutoFilter extends LFOEffect{constructor(){super(optionsFromArguments(AutoFilter.getDefaults(),arguments,["frequency","baseFrequency","octaves"])),this.name="AutoFilter";const s=optionsFromArguments(AutoFilter.getDefaults(),arguments,["frequency","baseFrequency","octaves"]);this.filter=new Filter(Object.assign(s.filter,{context:this.context})),this.connectEffect(this.filter),this._lfo.connect(this.filter.frequency),this.octaves=s.octaves,this.baseFrequency=s.baseFrequency}static getDefaults(){return Object.assign(LFOEffect.getDefaults(),{baseFrequency:200,octaves:2.6,filter:{type:"lowpass",rolloff:-12,Q:1}})}get baseFrequency(){return this._lfo.min}set baseFrequency(s){this._lfo.min=this.toFrequency(s),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(s){this._octaves=s,this._lfo.max=this._lfo.min*Math.pow(2,s)}dispose(){return super.dispose(),this.filter.dispose(),this}}class Panner extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(Panner.getDefaults(),arguments,["pan"]))),this.name="Panner",this._panner=this.context.createStereoPanner(),this.input=this._panner,this.output=this._panner;const s=optionsFromArguments(Panner.getDefaults(),arguments,["pan"]);this.pan=new Param({context:this.context,param:this._panner.pan,value:s.pan,minValue:-1,maxValue:1}),this._panner.channelCount=s.channelCount,this._panner.channelCountMode="explicit",readOnly(this,"pan")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{pan:0,channelCount:1})}dispose(){return super.dispose(),this._panner.disconnect(),this.pan.dispose(),this}}const workletName="bit-crusher",bitCrusherWorklet=`
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;registerProcessor(workletName,bitCrusherWorklet);class Solo extends ToneAudioNode{constructor(){super(optionsFromArguments(Solo.getDefaults(),arguments,["solo"])),this.name="Solo";const s=optionsFromArguments(Solo.getDefaults(),arguments,["solo"]);this.input=this.output=new Gain({context:this.context}),Solo._allSolos.has(this.context)||Solo._allSolos.set(this.context,new Set),Solo._allSolos.get(this.context).add(this),this.solo=s.solo}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{solo:!1})}get solo(){return this._isSoloed()}set solo(s){s?this._addSolo():this._removeSolo(),Solo._allSolos.get(this.context).forEach(i=>i._updateSolo())}get muted(){return this.input.gain.value===0}_addSolo(){Solo._soloed.has(this.context)||Solo._soloed.set(this.context,new Set),Solo._soloed.get(this.context).add(this)}_removeSolo(){Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).delete(this)}_isSoloed(){return Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).has(this)}_noSolos(){return!Solo._soloed.has(this.context)||Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).size===0}_updateSolo(){this._isSoloed()?this.input.gain.value=1:this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){return super.dispose(),Solo._allSolos.get(this.context).delete(this),this._removeSolo(),this}}Solo._allSolos=new Map;Solo._soloed=new Map;class PanVol extends ToneAudioNode{constructor(){super(optionsFromArguments(PanVol.getDefaults(),arguments,["pan","volume"])),this.name="PanVol";const s=optionsFromArguments(PanVol.getDefaults(),arguments,["pan","volume"]);this._panner=this.input=new Panner({context:this.context,pan:s.pan,channelCount:s.channelCount}),this.pan=this._panner.pan,this._volume=this.output=new Volume({context:this.context,volume:s.volume}),this.volume=this._volume.volume,this._panner.connect(this._volume),this.mute=s.mute,readOnly(this,["pan","volume"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(s){this._volume.mute=s}dispose(){return super.dispose(),this._panner.dispose(),this.pan.dispose(),this._volume.dispose(),this.volume.dispose(),this}}class Channel extends ToneAudioNode{constructor(){super(optionsFromArguments(Channel.getDefaults(),arguments,["volume","pan"])),this.name="Channel";const s=optionsFromArguments(Channel.getDefaults(),arguments,["volume","pan"]);this._solo=this.input=new Solo({solo:s.solo,context:this.context}),this._panVol=this.output=new PanVol({context:this.context,pan:s.pan,volume:s.volume,mute:s.mute,channelCount:s.channelCount}),this.pan=this._panVol.pan,this.volume=this._panVol.volume,this._solo.connect(this._panVol),readOnly(this,["pan","volume"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{pan:0,volume:0,mute:!1,solo:!1,channelCount:1})}get solo(){return this._solo.solo}set solo(s){this._solo.solo=s}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(s){this._panVol.mute=s}_getBus(s){return Channel.buses.has(s)||Channel.buses.set(s,new Gain({context:this.context})),Channel.buses.get(s)}send(s,i=0){const a=this._getBus(s),u=new Gain({context:this.context,units:"decibels",gain:i});return this.connect(u),u.connect(a),u}receive(s){return this._getBus(s).connect(this),this}dispose(){return super.dispose(),this._panVol.dispose(),this.pan.dispose(),this.volume.dispose(),this._solo.dispose(),this}}Channel.buses=new Map;class Listener extends ToneAudioNode{constructor(){super(...arguments),this.name="Listener",this.positionX=new Param({context:this.context,param:this.context.rawContext.listener.positionX}),this.positionY=new Param({context:this.context,param:this.context.rawContext.listener.positionY}),this.positionZ=new Param({context:this.context,param:this.context.rawContext.listener.positionZ}),this.forwardX=new Param({context:this.context,param:this.context.rawContext.listener.forwardX}),this.forwardY=new Param({context:this.context,param:this.context.rawContext.listener.forwardY}),this.forwardZ=new Param({context:this.context,param:this.context.rawContext.listener.forwardZ}),this.upX=new Param({context:this.context,param:this.context.rawContext.listener.upX}),this.upY=new Param({context:this.context,param:this.context.rawContext.listener.upY}),this.upZ=new Param({context:this.context,param:this.context.rawContext.listener.upZ})}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{positionX:0,positionY:0,positionZ:0,forwardX:0,forwardY:0,forwardZ:-1,upX:0,upY:1,upZ:0})}dispose(){return super.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this.forwardX.dispose(),this.forwardY.dispose(),this.forwardZ.dispose(),this.upX.dispose(),this.upY.dispose(),this.upZ.dispose(),this}}onContextInit(c=>{c.listener=new Listener({context:c})});onContextClose(c=>{c.listener.dispose()});getContext().transport;getContext().destination;getContext().destination;getContext().listener;getContext().draw;getContext();class Controller{constructor(s,i,a){F(this,"transformMatrix");F(this,"position");F(this,"velocity");F(this,"forward");F(this,"up");F(this,"right");F(this,"rotation");F(this,"noise");this.keyboard=s,this.mouse=i,this.touchController=a,this.transformMatrix=create$3(),this.position=fromValues$1(0,0,-300),this.velocity=fromValues$1(0,0,0),this.rotation=create(),this.forward=create$2(),this.right=create$2(),this.up=fromValues$1(0,1,0),this.noise=null}init(){this.noise=new Noise("pink");const s=new AutoFilter({frequency:"4n",baseFrequency:200,depth:0}).toDestination().start();this.noise.connect(s)}update(s){const i=this.keyboard.keydown("shift")?20:5;zero(this.velocity),this.keyboard.keydown("w")&&(sub(this.velocity,this.velocity,this.forward),add(this.velocity,this.velocity,this.up)),this.keyboard.keydown("s")&&add(this.velocity,this.velocity,this.forward),this.keyboard.keydown("a")&&sub(this.velocity,this.velocity,this.right),this.keyboard.keydown("d")&&add(this.velocity,this.velocity,this.right),this.keyboard.keydown("r")&&add(this.velocity,this.velocity,this.up),this.keyboard.keydown("f")&&sub(this.velocity,this.velocity,this.up),scale(this.velocity,this.velocity,i),length(this.velocity)>0?this.noise!==null&&this.noise.state:this.noise!=null&&this.noise.state,this.keyboard.keydown("q")&&rotateZ(this.rotation,this.rotation,toRadian(1)),this.keyboard.keydown("e")&&rotateZ(this.rotation,this.rotation,toRadian(-1));const a=fromValues$1(2e6,100,100),u=sub(create$2(),this.position,a);normalize$2(u,u);const l=rotationTo(create(),scale(create$2(),this.up,1),scale(create$2(),u,1));multiply$1(l,l,this.rotation),slerp(this.rotation,this.rotation,l,.01*s),rotateY(this.rotation,this.rotation,toRadian(-(this.mouse.position.x+this.touchController.position.x)*.08)),identity(this.transformMatrix);const d=fromQuat(create$3(),this.rotation);translate(this.transformMatrix,this.transformMatrix,this.position),translate(this.transformMatrix,this.transformMatrix,scale(u,u,100)),mul(this.transformMatrix,this.transformMatrix,d),normalize$2(this.right,this.transformMatrix.slice(0,3)),normalize$2(this.up,this.transformMatrix.slice(4,7)),normalize$2(this.forward,this.transformMatrix.slice(8,11))}getTransformMatrix(){return this.transformMatrix}}class Keyboard{constructor(){F(this,"keys");F(this,"bufferKeys");F(this,"lastKeys");this.keys=new Map,this.bufferKeys=new Map,this.lastKeys=new Map}init(){const s=a=>{a.preventDefault(),this.bufferKeys.set(a.key.toLowerCase(),!0)},i=({key:a})=>{this.bufferKeys.delete(a.toLowerCase())};document.addEventListener("keydown",s),document.addEventListener("keyup",i)}update(){this.lastKeys=new Map(this.keys),this.keys=new Map(this.bufferKeys)}keydown(s){return this.keys.get(s)===!0}keyup(s){return this.keys.get(s)!==!0}keypress(s){return this.keys.get(s)===!0&&this.lastKeys.get(s)!==!0}}const VertexShader=`struct Uniforms {\r
  modelViewProjectionMatrix : mat4x4<f32>,\r
  stride: i32,\r
  position: vec3<f32>\r
};\r
\r
@binding(0) @group(0) var<uniform> uniforms : Uniforms;\r
\r
struct Lights\r
{\r
  position: vec3<f32>,\r
  diffuse: vec3<f32>\r
};\r
\r
fn lambert(N: vec3<f32>, L: vec3<f32>) -> f32\r
{\r
  var nrmN = normalize(N);\r
  var nrmL = normalize(L);\r
  var result = dot(nrmN, nrmL);\r
  return max(result, 0.0);\r
}\r
\r
struct VertexOutput {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) fragPosition: vec4<f32>,\r
  @location(1) normal: vec3<f32>,\r
  @location(2) color: vec3<f32>,\r
};\r
\r
@vertex\r
fn main(@location(0) position : vec4<f32>,\r
        @location(1) normal : vec4<f32>) -> VertexOutput {\r
\r
  var light: Lights;\r
  light.position = normalize(-position.xyz);\r
  light.diffuse = vec3<f32>(1.0, 1.0, 1.0);\r
\r
  var output : VertexOutput;\r
  output.Position = uniforms.modelViewProjectionMatrix * position;\r
  output.normal = normal.xyz;\r
\r
  var result = vec3<f32>(0.4, 0.4, 0.4) + light.diffuse * lambert(normal.xyz, light.position);\r
\r
  output.fragPosition = position;\r
  output.color = result;\r
  return output;\r
}\r
`,FragmentShader=`struct Uniforms {
  modelViewProjectionMatrix : mat4x4<f32>,
  stride: i32,
  position: vec3<f32>,
  time: f32,
};
@binding(0) @group(0) var<uniform> uniforms : Uniforms;
@binding(1) @group(0) var<storage, read> corners : array<u32, 32768>;

#import density

fn getTriPlanarBlend(_wNorm: vec3<f32>) -> vec3<f32> {
	// in wNorm is the world-space normal of the fragment
	var blending = abs( _wNorm );
  blending.x = max(blending.x, 0.00001);
  blending.y = max(blending.y, 0.00001);
  blending.z = max(blending.z, 0.00001);
	blending = normalize(blending); // Force weights to sum to 1.0
	let b = (blending.x + blending.y + blending.z);
	blending = blending / b;
	return blending;
}

const normalRepeat = 0.01;

const lower = 20.0;
const upper = 49.0;
const diff = 29.0;

fn getFade(y: f32) -> f32 {
  if (y < lower) {
    return 1.0;
  }
  return max(((diff - (min(y, upper) - lower)) / diff), 0.1);
}

fn rand(co: vec2<f32>) -> f32 {
    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }
fn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise2(P: vec2<f32>) -> f32 {
  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);
  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);
  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation
  let ix = Pi.xzxz;
  let iy = Pi.yyww;
  let fx = Pf.xzxz;
  let fy = Pf.yyww;
  let i = permute4(permute4(ix) + iy);
  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...
  let gy = abs(gx) - 0.5;
  let tx = floor(gx + 0.5);
  gx = gx - tx;
  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);
  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);
  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);
  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);
  let norm = 1.79284291400159 - 0.85373472095314 *
      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 = g00 * norm.x;
  g01 = g01 * norm.y;
  g10 = g10 * norm.z;
  g11 = g11 * norm.w;
  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));
  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));
  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));
  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));
  let fade_xy = fade2(Pf.xy);
  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));
  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

fn random2(p: vec2<f32>) -> vec2<f32> {
    return fract(sin(vec2<f32>(dot(p,vec2<f32>(127.1,311.7)),dot(p,vec2<f32>(269.5,183.3))))*43758.5453);
}

fn cellular(co: vec2<f32>) -> vec3<f32> {
    var color = vec3<f32>(.0);
    let position = co * 1.;

    // Tile the space
    let i_st = floor(position);
    let f_st = fract(position);

    var m_dist = 1.;  // minimum distance

    for (var y= -1; y <= 1; y++) {
        for (var x= -1; x <= 1; x++) {
            // Neighbor place in the grid
            let neighbor = vec2<f32>(f32(x),f32(y));

            // Random position from current + neighbor place in the grid
            let p = random2(i_st + neighbor);

			// Vector between the pixel and the point
            let diff = neighbor + p - f_st;

            // Distance to the point
            let dist = length(diff);

            // Keep the closer distance
            m_dist = min(m_dist, dist);
        }
    }

    // Draw the min distance (distance field)
    color = color + m_dist;

    return color;
}

fn samp(co: vec2<f32>, material: u32) -> vec3<f32> {
  if (material == MATERIAL_ROCK) {
    // Stone
    let cell =  cellular(co * 20.0);
    let n = (1.0 + sin((co.x + perlinNoise2(co * 5.0) / 2.0) * 50.0)) / 2.0;
    let color = mix(vec3<f32>(0.3, 0.3, 0.3), vec3<f32>(0.4,0.4,0.4),(n * 0.4 + cell * 0.6));
    return color;
  }

  if (material == MATERIAL_WOOD) {
    // Wood
    let v = fract((perlinNoise2(co * vec2<f32>(10.0, 0.2))*0.5+0.5)*5.0) + perlinNoise2(co * vec2<f32>(100.0,20.0))*0.2;

    return mix(vec3<f32>(0.19, 0.13, 0.06), vec3<f32>(0.52, 0.32, 0.19), v);
  }

  if (material == MATERIAL_FIRE) {
    let low = vec3<f32>(234.0/255.0, 91.0/255.0, 13.0/255.0);
    let high = vec3<f32>(228.0/255.0, 2.0/255.0, 47.0/255.0);

    let offset = co + vec2(sin(uniforms.time / 1000.0) * 500.0, cos(uniforms.time / 1000.0) * 500.0);
    let offset2 = co + vec2(cos(uniforms.time / 1000.0) * 500.0, sin(-uniforms.time / 1000.0) * 500.0);

    let samp = mix(low, high, perlinNoise2(offset / 500.0));
    let samp2 = mix(low, high, perlinNoise2(offset2 / 500.0));

    return mix(samp, samp2, 0.5);
  }

  return vec3<f32>(1.0, 0.0, 0.0);
}

fn findMaterial(pos: vec3<f32>, normal: vec3<f32>) -> u32 {
  var i = 0;
	loop {
	  let density = calculateDensity(pos - normal * f32(i * uniforms.stride));

    if (i > 10) {
      return MATERIAL_AIR;
    }

		if (density.density <= 0) {
		  return density.material;
		}

		continuing {
			i = i + 1;
		}
	}
}

const lightIterations = 10.0;

fn hasLight(p: vec3<f32>) -> f32 {
  let direction = normalize(-p);
  var i = 0.0;


  loop {
    let position = p + direction * pow(2, i);
    let density = getDensity(position);

    if (density < 0) {
      return 0.5;
      // return mix(0.2, 1.0, 1.0 - i / lightIterations);
    }

    if (i > lightIterations) {
      return 1;
    }

    continuing {
      i = i + 1;
    }
  }
}

@fragment
fn main(@location(0) vPos: vec4<f32>,
        @location(1) vNormal: vec3<f32>,
        @location(2) color: vec3<f32>) -> @location(0) vec4<f32> {
  //let fade = getFade(vPos.y);
  let blending = getTriPlanarBlend(vNormal);
  let material = findMaterial(vPos.xyz, normalize(vNormal.xyz));

  let xaxis = samp(vPos.yz * normalRepeat, material);
  let yaxis = samp(vPos.xz * normalRepeat, material);
  let zaxis = samp(vPos.xy * normalRepeat, material);
	var tex = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;

  if (material == MATERIAL_FIRE) {
    return vec4(tex, 1.0);
  }
  //let cell = vec3<u32>(vPos.xyz - uniforms.position / f32(uniforms.stride));
  //let foo = corners[cell.x * 32 * 32 + cell.y * 32 + cell.z];
  return vec4<f32>(tex * color, 1.0);
  //return vec4<f32>(tex * color * max(0.0, hasLight(vPos.xyz + vNormal.xyz * 10.0)), 1.0);
}
`;class VoxelObject{constructor(s,i,a,u,l,d){F(this,"position");F(this,"stride");F(this,"cornersBuffer");F(this,"vertexBuffer");F(this,"indexCount");F(this,"indexBuffer");F(this,"uniformBuffer");F(this,"uniformBindGroup");F(this,"pipeline");this.index=i,this.consistency=d,this.position=s,this.stride=a,this.pipeline=l;const h=new Float32Array([]);this.vertexBuffer=u.createBuffer({size:h.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(h),this.vertexBuffer.unmap(),this.indexCount=12*3,this.indexBuffer=u.createBuffer({size:this.indexCount*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint16Array(this.indexBuffer.getMappedRange()).set([]),this.indexBuffer.unmap(),this.cornersBuffer=u.createBuffer({size:32*32*32*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!1});const f=4*16+4*4+4*4;this.uniformBuffer=u.createBuffer({size:f,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=u.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.cornersBuffer}}]})}setCorners(s,i){const a=s.createBuffer({size:32768*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0}),u=new Uint32Array(a.getMappedRange());for(let d=0;d<i.length;d++)u[d]=i[d];a.unmap();const l=this.cornersBuffer;this.cornersBuffer=a,this.uniformBindGroup=s.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.cornersBuffer}}]}),l.destroy()}setVertexBuffer(s,i,a){const u=s.createBuffer({size:i.length*10*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),l=new Float32Array(u.getMappedRange());for(let h=0;h<i.length;h+=3)l.set(i.slice(h,h+3),h/3*10),l.set([1],h/3*10+3),l.set(a.slice(h,h+3),h/3*10+4),l.set([1],h/3*10+8);u.unmap();const d=this.vertexBuffer;this.vertexBuffer=u,d.destroy()}setIndexBuffer(s,i){const a=s.createBuffer({size:i.length*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(a.getMappedRange()).set(i),a.unmap();const l=this.indexBuffer;this.indexBuffer=a,l.destroy(),this.indexCount=i.length}getTransformationMatrix(s){const i=create$3();translate(i,i,this.position);const a=create$3();return multiply$2(a,s,i),a}update(s,i,a){const u=this.getTransformationMatrix(i);s.queue.writeBuffer(this.uniformBuffer,0,u.buffer,u.byteOffset,u.byteLength);const l=new Int32Array(1);l[0]=this.stride,s.queue.writeBuffer(this.uniformBuffer,u.byteLength,l.buffer,l.byteOffset,l.byteLength),s.queue.writeBuffer(this.uniformBuffer,4*16+4*4,this.position.buffer,this.position.byteOffset,this.position.byteLength);const d=new Float32Array(1);d[0]=a,s.queue.writeBuffer(this.uniformBuffer,4*16+4*4+4*3,d.buffer,d.byteOffset,d.byteLength)}draw(s){s.setBindGroup(0,this.uniformBindGroup),s.setVertexBuffer(0,this.vertexBuffer),s.setIndexBuffer(this.indexBuffer,"uint16"),s.drawIndexed(this.indexCount)}}const DensityShader=`const freq = 0.001;

const MATERIAL_AIR = 0u;
const MATERIAL_ROCK = 1u;
const MATERIAL_WOOD = 2u;
const MATERIAL_FIRE = 3u;

struct Density {
  density: f32,
  material: u32
}

struct Augmentations {
  count: u32,
  augmentations: array<Augmentation>
}

struct Augmentation {
  position: vec3<f32>,
  size: f32,
  attributes: u32
}

@binding(0) @group(1) var<storage, read> augmentations: Augmentations;

fn subtract(base: Density, sub: f32) -> Density {
  return Density(max(base.density, sub), base.material);
}

fn add(base: Density, add: f32, material: u32) -> Density {
  if (add <= 0) {
    return Density(add, material);
  }
  return base;
}

fn Box(worldPosition: vec3<f32>, origin: vec3<f32>, halfDimensions: vec3<f32>) -> f32
{
	let local_pos: vec3<f32> = worldPosition - origin;
	let pos: vec3<f32> = local_pos;

	let d: vec3<f32> = vec3<f32>(abs(pos.x), abs(pos.y), abs(pos.z)) - halfDimensions;
	let m: f32 = max(d.x, max(d.y, d.z));
	return clamp(min(m, length(max(d, vec3<f32>(0.0, 0.0, 0.0)))), -100.0, 100.0);
}

fn Torus(worldPosition: vec3<f32>, origin: vec3<f32>, t: vec3<f32>) -> f32
{
	let p: vec3<f32> = worldPosition - origin;

  let q: vec2<f32> = vec2<f32>(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

fn Sphere(worldPosition: vec3<f32>, origin: vec3<f32>, radius: f32) -> f32
{
	return clamp(length(worldPosition - origin) - radius, -100.0, 100.0);
}

fn FractalNoise21(octaves: i32, frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32
{
	let SCALE: f32 = 1.0 / 128.0;
	var p: vec3<f32> = position * SCALE;
	var nois: f32 = 0.0;

	var amplitude: f32 = 1.0;
	p = p * frequency;

	var i: i32 = 0;
	loop {
		if (i >= octaves) { break; }

		nois = nois + perlinNoise3(p) * amplitude;
		p = p * lacunarity;
		amplitude = amplitude * persistence;

		continuing {
			i = i + 1;
		}
	}

	return nois;
}

fn FractalNoise2(frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32
{
	let SCALE: f32 = 1.0 / 128.0;
	var p: vec3<f32> = position * SCALE;
	var nois: f32 = 0.0;

	var amplitude: f32 = 1.0;
	p = p * frequency;

	nois = nois + perlinNoise3(p) * amplitude;
	p = p * lacunarity;
	amplitude = amplitude * persistence;

	return nois;
}

fn permute41(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }
fn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }
fn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise3(P: vec3<f32>) -> f32 {
  var Pi0 : vec3<f32> = floor(P); // Integer part for indexing
  var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1
  Pi0 = Pi0 % vec3<f32>(289.);
  Pi1 = Pi1 % vec3<f32>(289.);
  let Pf0 = fract(P); // Fractional part for interpolation
  let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.
  let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  let iy = vec4<f32>(Pi0.yy, Pi1.yy);
  let iz0 = Pi0.zzzz;
  let iz1 = Pi1.zzzz;

  let ixy = permute41(permute41(ix) + iy);
  let ixy0 = permute41(ixy + iz0);
  let ixy1 = permute41(ixy + iz1);

  var gx0: vec4<f32> = ixy0 / 7.;
  var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;
  gx0 = fract(gx0);
  var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);
  var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));
  gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);
  gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);

  var gx1: vec4<f32> = ixy1 / 7.;
  var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;
  gx1 = fract(gx1);
  var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);
  var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));
  gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);
  gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);

  var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);
  var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);
  var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);
  var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);
  var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);
  var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);
  var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);
  var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);

  let norm0 = taylorInvSqrt4(
      vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 = g000 * norm0.x;
  g010 = g010 * norm0.y;
  g100 = g100 * norm0.z;
  g110 = g110 * norm0.w;
  let norm1 = taylorInvSqrt4(
      vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 = g001 * norm1.x;
  g011 = g011 * norm1.y;
  g101 = g101 * norm1.z;
  g111 = g111 * norm1.w;

  let n000 = dot(g000, Pf0);
  let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));
  let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));
  let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));
  let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));
  let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));
  let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));
  let n111 = dot(g111, Pf1);

  var fade_xyz: vec3<f32> = fade3(Pf0);
  let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix
  let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);
  let n_yz = mix(n_z.xy, n_z.zw, vec2<f32>(f32(fade_xyz.y))); // simplify after chrome bug fix
  let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

fn CalculateNoiseValue2(pos: vec3<f32>, scale: f32) -> f32
{
	return FractalNoise21(4, 0.5343, 2.2324, 0.68324, pos * scale);
}

fn CLerp2(a: f32, b: f32, t: f32) -> f32
{
	return (1.0 - t) * a + t * b;
}

fn rotateAlign(v1: vec3<f32>, v2: vec3<f32>) -> mat3x3<f32>
{
    let axis = cross( v1, v2 );

    let cosA = dot( v1, v2 );
    let k = 1.0 / (1.0 + cosA);

    return mat3x3<f32>( (axis.x * axis.x * k) + cosA,
                 (axis.y * axis.x * k) - axis.z,
                 (axis.z * axis.x * k) + axis.y,
                 (axis.x * axis.y * k) + axis.z,
                 (axis.y * axis.y * k) + cosA,
                 (axis.z * axis.y * k) - axis.x,
                 (axis.x * axis.z * k) - axis.y,
                 (axis.y * axis.z * k) + axis.x,
                 (axis.z * axis.z * k) + cosA
                 );
}


fn AngleAxis3x3(angle: f32, axis: vec3<f32>) -> mat3x3<f32>
{
    let s = sin(angle);
    let c = cos(angle);

    let t = 1 - c;
    let x = axis.x;
    let y = axis.y;
    let z = axis.z;

    return mat3x3<f32>(
        t * x * x + c,      t * x * y - s * z,  t * x * z + s * y,
        t * x * y + s * z,  t * y * y + c,      t * y * z - s * x,
        t * x * z - s * y,  t * y * z + s * x,  t * z * z + c
    );
}

fn blockSize(blockType: u32) -> f32 {
  if (blockType == 2 || blockType == 3) {
    return 0.5;
  }
  return 1.0;
}

fn calculateDensity(worldPosition: vec3<f32>) -> Density {
	var worldRadius: f32 = 5000.0;
	var world: vec3<f32> = worldPosition - vec3<f32>(2000000.0, 100.0, 100.0);
	var worldDist: f32 = -worldRadius + length(world);
	let up = vec3<f32>(0.0, 1.0, 0.0);


	let flatlandNoiseScale: f32 = 1.0;
	let flatlandLerpAmount: f32 = 0.07;
	let flatlandYPercent: f32 = 1.2;

	let rockyNoiseScale: f32 = 1.5;
	let rockyLerpAmount: f32 = 0.05;
	let rockyYPercent: f32 = 0.7;

	let maxMountainMixLerpAmount: f32 = 0.075;
	let minMountainMixLerpAmount: f32 = 1.0;

	let rockyBlend: f32 = 0.0;

	let mountainBlend: f32 = clamp(abs(FractalNoise2(0.5343, 2.2324, 0.68324, world * 0.11)) * 4.0, 0.0, 1.0);
	//let mountainBlend: f32 = 1.0;

	//let mountain: f32 = CalculateNoiseValue2(world, 0.07);
	let mountain: f32 = 0.0;

//	var blob: f32 = CalculateNoiseValue2(world, flatlandNoiseScale + ((rockyNoiseScale - flatlandNoiseScale) * rockyBlend));
//	blob = CLerp2(blob, (worldDist) * (flatlandYPercent + ((rockyYPercent - flatlandYPercent) * rockyBlend)),
//				flatlandLerpAmount + ((rockyLerpAmount - flatlandLerpAmount) * rockyBlend))
//				+ CLerp2(mountain, blob, minMountainMixLerpAmount + ((maxMountainMixLerpAmount - minMountainMixLerpAmount) * mountainBlend));

  var result = Density(1.0, MATERIAL_AIR);

	//result = add(result, blob, MATERIAL_WOOD);

  result = add(result, Box(worldPosition, vec3<f32>(2000000.0, 150.0, 5000.0), vec3<f32>(5000.0, 1000.0, 5000.0)), MATERIAL_WOOD);
  result = add(result, Sphere(worldPosition, vec3<f32>(2000000.0, 100.0, 100.0), 5000.0), MATERIAL_ROCK);

  //result = add(result, Sphere(worldPosition, vec3<f32>(2000000.0 - 1000000.0, 0.0, 0.0), 1000000.0), MATERIAL_ROCK);

  result = add(result, Sphere(worldPosition, vec3<f32>(0.0, 0.0, 0.0), 200000.0), MATERIAL_FIRE);

  //result = subtract(result, -Sphere(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), 1000.0));
  //result = subtract(result, -Box(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), vec3<f32>(6000.0, 500.0, 500.0)));
  //result = subtract(result, -Box(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), vec3<f32>(500.0, 500.0, 5000.0)));

  //result = add(result, Sphere(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), 1000.0), MATERIAL_FIRE);


  let count = augmentations.count;

  var i: u32 = 0u;
  loop {
    if (i >= count) { break; }

    let augmentation = augmentations.augmentations[i];

    let minBounds = augmentation.position - augmentation.size * 2;
    let maxBounds = augmentation.position + augmentation.size * 2;
    if (minBounds.x > worldPosition.x || minBounds.y > worldPosition.y || minBounds.z > worldPosition.z
      || maxBounds.x < worldPosition.x || maxBounds.y < worldPosition.y || maxBounds.z < worldPosition.z) { continue; }

    let shape = (augmentation.attributes & 0xFE) >> 1;
    var density: f32 = 0.0;

    let down = normalize(augmentation.position - vec3<f32>(2000000.0, 100.0, 100.0));
    let rotation = rotateAlign(down, up);
    let position = ((worldPosition - augmentation.position) * rotation - vec3<f32>(0.0, augmentation.size * blockSize(shape), 0.0)) + augmentation.position;

    switch(shape) {
      case 0: {
        density = Sphere(position, vec3<f32>(augmentation.position.x, augmentation.position.y, augmentation.position.z), augmentation.size);
      }
      case 1: {
        density = Box(position, vec3<f32>(augmentation.position.x, augmentation.position.y, augmentation.position.z), vec3<f32>(augmentation.size));
      }
      case 2: {
        density = Box(position, vec3<f32>(augmentation.position.x, augmentation.position.y + augmentation.size / 2, augmentation.position.z), vec3<f32>(augmentation.size, 5.0, augmentation.size));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x - augmentation.size / 2, augmentation.position.y, augmentation.position.z - augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x + augmentation.size / 2, augmentation.position.y, augmentation.position.z - augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x - augmentation.size / 2, augmentation.position.y, augmentation.position.z + augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x + augmentation.size / 2, augmentation.position.y, augmentation.position.z + augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
      }
      case 3: {
        density = Box(position, vec3<f32>(augmentation.position.x, augmentation.position.y + augmentation.size / 2, augmentation.position.z), vec3<f32>(augmentation.size, 5.0, augmentation.size));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x - augmentation.size, augmentation.position.y + augmentation.size, augmentation.position.z), vec3<f32>(5.0, augmentation.size / 2, augmentation.size)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x - augmentation.size / 2, augmentation.position.y, augmentation.position.z - augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x + augmentation.size / 2, augmentation.position.y, augmentation.position.z - augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x - augmentation.size / 2, augmentation.position.y, augmentation.position.z + augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
        density = min(density, Box(position, vec3<f32>(augmentation.position.x + augmentation.size / 2, augmentation.position.y, augmentation.position.z + augmentation.size / 2), vec3<f32>(5.0, augmentation.size / 2, 5.0)));
      }
      case 4: {
        density = Box(position, vec3<f32>(augmentation.position.x, augmentation.position.y - augmentation.size + 16, augmentation.position.z), vec3<f32>(augmentation.size, 16, augmentation.size));
      }
      default: {
        continue;
      }
    }

    if ((augmentation.attributes & 0x1) == 0x1) {
      let material = (augmentation.attributes & 0x1FF00) >> 8;
      result = add(result, density, material);
    } else {
      result = subtract(result, -density);
    }


    continuing {
      i = i + 1u;
    }
  }

  return result;
}

fn getDensity(worldPosition: vec3<f32>) -> f32 {
	return calculateDensity(worldPosition).density;
}
`;var DensityType=(c=>(c[c.Subtract=0]="Subtract",c[c.Add=1]="Add",c))(DensityType||{}),DensityShape=(c=>(c[c.Sphere=0]="Sphere",c[c.Box=1]="Box",c[c.Table=2]="Table",c[c.Chair=3]="Chair",c[c.Foundation=4]="Foundation",c))(DensityShape||{}),DensityMaterial=(c=>(c[c.Air=0]="Air",c[c.Rock=1]="Rock",c[c.Wood=2]="Wood",c[c.Fire=3]="Fire",c))(DensityMaterial||{});class DensityInstance{constructor(s){F(this,"bindGroup");this.bindGroup=s}apply(s){s.setBindGroup(1,this.bindGroup)}}class Density{constructor(s){F(this,"augmentationBuffer");F(this,"augmentationArray",[]);F(this,"augmentations");F(this,"onModified",()=>{});this.augmentationBuffer=s,this.augmentations=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT*4)}static async init(s){const i=64*Float32Array.BYTES_PER_ELEMENT*8+8,a=s.createBuffer({size:i,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1});return new Density(a)}async apply(s,i){const a=s.createBindGroup({layout:i.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.augmentationBuffer}}]});return new DensityInstance(a)}modify(s,i){this.augmentationArray.push(i),this.update(s,this.augmentationArray),this.onModified()}update(s,i){this.augmentations=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT*4+Uint32Array.BYTES_PER_ELEMENT*i.length*8);const a=new Uint32Array(this.augmentations,0,4);a[0]=i.length;const u=new Float32Array(this.augmentations,Uint32Array.BYTES_PER_ELEMENT*4),l=new Uint32Array(this.augmentations,Uint32Array.BYTES_PER_ELEMENT*4);for(let d=0;d<i.length;d++)u[d*8]=i[d].x,u[d*8+1]=i[d].y,u[d*8+2]=i[d].z,u[d*8+3]=i[d].size,l[d*8+4]=i[d].type|i[d].shape<<1|i[d].material<<8;s.queue.writeBuffer(this.augmentationBuffer,0,this.augmentations,0,this.augmentations.byteLength)}updateRaw(s,i){this.augmentations=i,s.queue.writeBuffer(this.augmentationBuffer,0,this.augmentations,0,this.augmentations.byteLength)}static patch(s){return s.replace("#import density",DensityShader)}}const swapChainFormat=navigator.gpu.getPreferredCanvasFormat();let Ray$1=class{constructor(s,i){F(this,"sign",[]);F(this,"invdir");this.source=s,this.dir=i,this.invdir=create$2(),this.setDirection(i)}setDirection(s){this.dir=s,scale(this.invdir,s,-1),this.sign[0]=this.invdir[0]<0?1:0,this.sign[1]=this.invdir[1]<0?1:0,this.sign[2]=this.invdir[2]<0?1:0}};class VoxelCollection{constructor(s,i){F(this,"objects");F(this,"pool");F(this,"pipeline");F(this,"density");this.pipeline=s,this.objects=new Map,this.density=i,this.pool=[]}static async init(s,i){const a=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),u=s.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),l=s.createPipelineLayout({bindGroupLayouts:[a,u]}),d=s.createRenderPipeline({layout:l,vertex:{module:s.createShaderModule({code:VertexShader}),buffers:[{arrayStride:4*10,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:4*4,format:"float32x4"}]}],entryPoint:"main"},fragment:{module:s.createShaderModule({code:Density.patch(FragmentShader)}),entryPoint:"main",targets:[{format:swapChainFormat}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),h=await i.apply(s,d);return new VoxelCollection(d,h)}intersects(s,i,a){const u=[{x:i.x-a/2,y:i.y-a/2,z:i.z-a/2},{x:i.x+a/2,y:i.y+a/2,z:i.z+a/2}];let l=(u[s.sign[0]].x-s.orig[0])*s.invdir[0],d=(u[1-s.sign[0]].x-s.orig[0])*s.invdir[0];const h=(u[s.sign[1]].y-s.orig[1])*s.invdir[1],f=(u[1-s.sign[1]].y-s.orig[1])*s.invdir[1];if(l>f||h>d)return!1;h>l&&(l=h),f<d&&(d=f);const p=(u[s.sign[2]].z-s.orig[2])*s.invdir[2],g=(u[1-s.sign[2]].z-s.orig[2])*s.invdir[2];return!(l>g||p>d)}getAdjacent(s,i,a){const u=[],l=i/2,d=new Ray$1([a.x/31,a.y/31,a.z/31],[s.x-a.x,s.y-a.y,s.z-a.z]);for(const h of this.objects.values()){const f=h.stride/2;h.index[0]+f>=s.x-l&&s.x+l>=h.index[0]-f&&h.index[1]+f>=s.y-l&&s.y+l>=h.index[1]-f&&h.index[2]+f>=s.z-l&&s.z+l>=h.index[2]-f&&(d.setDirection([a.x/31-h.index[0],a.y/31-h.index[1],a.z/31-h.index[2]]),this.intersects(d,s,i)&&u.push(h))}return u}set(s,i,a,u,l,d,h,f,p,g){let m=this.objects.get(i);m||(m=this.pool.pop(),m?(m.index=fromValues$1(u.x,u.y,u.z),m.position=fromValues$1(a.x,a.y,a.z)):m=new VoxelObject(fromValues$1(a.x,a.y,a.z),fromValues$1(u.x,u.y,u.z),l,s,this.pipeline,g),this.objects.set(i,m)),m.setCorners(s,p),m.stride=l,m.consistency=g,m.setVertexBuffer(s,d,h),m.setIndexBuffer(s,f);const _=l/2;for(const[v,y]of this.objects){if(y===m)continue;const A=y.stride/2;y.index[0]+A>m.index[0]-_&&m.index[0]+_>y.index[0]-A&&y.index[1]+A>m.index[1]-_&&m.index[1]+_>y.index[1]-A&&y.index[2]+A>m.index[2]-_&&m.index[2]+_>y.index[2]-A&&this.free(v)}}free(s){const i=this.objects.get(s);i&&(this.pool.push(i),this.objects.delete(s))}freeAll(){for(const[s,i]of this.objects)this.pool.push(i),this.objects.delete(s)}update(s,i,a){for(const u of this.objects.values())u.update(s,i,a)}draw(s){s.setPipeline(this.pipeline),this.density.apply(s);for(const i of this.objects.values())i.consistency&&i.draw(s)}}const Physics=`struct Actor {
  position: vec3<f32>,
  velocity: vec3<f32>
};

struct Physics {
  actors: array<Actor>
};

@binding(6) @group(0)
var<storage, read_write> physics : Physics;

#import density

@compute @workgroup_size(1)
fn computePhysics(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let actor: u32 = GlobalInvocationID.x;

  if (getDensity(physics.actors[actor].position) < 0.0) {
    physics.actors[actor].position = physics.actors[actor].position + vec3<f32>(10.0, 0.0, 0.0);
  }

  let gravity = vec3<f32>(2000000.0, 0.0, 0.0);
  let gravityDirection = normalize(physics.actors[actor].position - gravity);

  physics.actors[actor].velocity -= gravityDirection * 9.8;

  let direction = normalize(physics.actors[actor].velocity);
  let pos = physics.actors[actor].position + physics.actors[actor].velocity;

  for (var i = 0; i < 10; i++) {
    let pos = physics.actors[actor].position + physics.actors[actor].velocity + gravityDirection * f32(i);
    if (getDensity(pos) >= 0.0) {
      physics.actors[actor].position = pos;
    }
  }
}
`;var alea$1={exports:{}};alea$1.exports;(function(c){(function(s,i,a){function u(f){var p=this,g=h();p.next=function(){var m=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=m-(p.c=m|0)},p.c=1,p.s0=g(" "),p.s1=g(" "),p.s2=g(" "),p.s0-=g(f),p.s0<0&&(p.s0+=1),p.s1-=g(f),p.s1<0&&(p.s1+=1),p.s2-=g(f),p.s2<0&&(p.s2+=1),g=null}function l(f,p){return p.c=f.c,p.s0=f.s0,p.s1=f.s1,p.s2=f.s2,p}function d(f,p){var g=new u(f),m=p&&p.state,_=g.next;return _.int32=function(){return g.next()*4294967296|0},_.double=function(){return _()+(_()*2097152|0)*11102230246251565e-32},_.quick=_,m&&(typeof m=="object"&&l(m,g),_.state=function(){return l(g,{})}),_}function h(){var f=4022871197,p=function(g){g=String(g);for(var m=0;m<g.length;m++){f+=g.charCodeAt(m);var _=.02519603282416938*f;f=_>>>0,_-=f,_*=f,f=_>>>0,_-=f,f+=_*4294967296}return(f>>>0)*23283064365386963e-26};return p}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.alea=d})(commonjsGlobal,c,!1)})(alea$1);var aleaExports=alea$1.exports,xor128$1={exports:{}};xor128$1.exports;(function(c){(function(s,i,a){function u(h){var f=this,p="";f.x=0,f.y=0,f.z=0,f.w=0,f.next=function(){var m=f.x^f.x<<11;return f.x=f.y,f.y=f.z,f.z=f.w,f.w^=f.w>>>19^m^m>>>8},h===(h|0)?f.x=h:p+=h;for(var g=0;g<p.length+64;g++)f.x^=p.charCodeAt(g)|0,f.next()}function l(h,f){return f.x=h.x,f.y=h.y,f.z=h.z,f.w=h.w,f}function d(h,f){var p=new u(h),g=f&&f.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var _=p.next()>>>11,v=(p.next()>>>0)/4294967296,y=(_+v)/(1<<21);while(y===0);return y},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.xor128=d})(commonjsGlobal,c,!1)})(xor128$1);var xor128Exports=xor128$1.exports,xorwow$1={exports:{}};xorwow$1.exports;(function(c){(function(s,i,a){function u(h){var f=this,p="";f.next=function(){var m=f.x^f.x>>>2;return f.x=f.y,f.y=f.z,f.z=f.w,f.w=f.v,(f.d=f.d+362437|0)+(f.v=f.v^f.v<<4^(m^m<<1))|0},f.x=0,f.y=0,f.z=0,f.w=0,f.v=0,h===(h|0)?f.x=h:p+=h;for(var g=0;g<p.length+64;g++)f.x^=p.charCodeAt(g)|0,g==p.length&&(f.d=f.x<<10^f.x>>>4),f.next()}function l(h,f){return f.x=h.x,f.y=h.y,f.z=h.z,f.w=h.w,f.v=h.v,f.d=h.d,f}function d(h,f){var p=new u(h),g=f&&f.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var _=p.next()>>>11,v=(p.next()>>>0)/4294967296,y=(_+v)/(1<<21);while(y===0);return y},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.xorwow=d})(commonjsGlobal,c,!1)})(xorwow$1);var xorwowExports=xorwow$1.exports,xorshift7$1={exports:{}};xorshift7$1.exports;(function(c){(function(s,i,a){function u(h){var f=this;f.next=function(){var g=f.x,m=f.i,_,v;return _=g[m],_^=_>>>7,v=_^_<<24,_=g[m+1&7],v^=_^_>>>10,_=g[m+3&7],v^=_^_>>>3,_=g[m+4&7],v^=_^_<<7,_=g[m+7&7],_=_^_<<13,v^=_^_<<9,g[m]=v,f.i=m+1&7,v};function p(g,m){var _,v=[];if(m===(m|0))v[0]=m;else for(m=""+m,_=0;_<m.length;++_)v[_&7]=v[_&7]<<15^m.charCodeAt(_)+v[_+1&7]<<13;for(;v.length<8;)v.push(0);for(_=0;_<8&&v[_]===0;++_);for(_==8?v[7]=-1:v[_],g.x=v,g.i=0,_=256;_>0;--_)g.next()}p(f,h)}function l(h,f){return f.x=h.x.slice(),f.i=h.i,f}function d(h,f){h==null&&(h=+new Date);var p=new u(h),g=f&&f.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var _=p.next()>>>11,v=(p.next()>>>0)/4294967296,y=(_+v)/(1<<21);while(y===0);return y},m.int32=p.next,m.quick=m,g&&(g.x&&l(g,p),m.state=function(){return l(p,{})}),m}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.xorshift7=d})(commonjsGlobal,c,!1)})(xorshift7$1);var xorshift7Exports=xorshift7$1.exports,xor4096$1={exports:{}};xor4096$1.exports;(function(c){(function(s,i,a){function u(h){var f=this;f.next=function(){var g=f.w,m=f.X,_=f.i,v,y;return f.w=g=g+1640531527|0,y=m[_+34&127],v=m[_=_+1&127],y^=y<<13,v^=v<<17,y^=y>>>15,v^=v>>>12,y=m[_]=y^v,f.i=_,y+(g^g>>>16)|0};function p(g,m){var _,v,y,A,T,x=[],O=128;for(m===(m|0)?(v=m,m=null):(m=m+"\0",v=0,O=Math.max(O,m.length)),y=0,A=-32;A<O;++A)m&&(v^=m.charCodeAt((A+32)%m.length)),A===0&&(T=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,A>=0&&(T=T+1640531527|0,_=x[A&127]^=v+T,y=_==0?y+1:0);for(y>=128&&(x[(m&&m.length||0)&127]=-1),y=127,A=4*128;A>0;--A)v=x[y+34&127],_=x[y=y+1&127],v^=v<<13,_^=_<<17,v^=v>>>15,_^=_>>>12,x[y]=v^_;g.w=T,g.X=x,g.i=y}p(f,h)}function l(h,f){return f.i=h.i,f.w=h.w,f.X=h.X.slice(),f}function d(h,f){h==null&&(h=+new Date);var p=new u(h),g=f&&f.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var _=p.next()>>>11,v=(p.next()>>>0)/4294967296,y=(_+v)/(1<<21);while(y===0);return y},m.int32=p.next,m.quick=m,g&&(g.X&&l(g,p),m.state=function(){return l(p,{})}),m}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.xor4096=d})(commonjsGlobal,c,!1)})(xor4096$1);var xor4096Exports=xor4096$1.exports,tychei$1={exports:{}};tychei$1.exports;(function(c){(function(s,i,a){function u(h){var f=this,p="";f.next=function(){var m=f.b,_=f.c,v=f.d,y=f.a;return m=m<<25^m>>>7^_,_=_-v|0,v=v<<24^v>>>8^y,y=y-m|0,f.b=m=m<<20^m>>>12^_,f.c=_=_-v|0,f.d=v<<16^_>>>16^y,f.a=y-m|0},f.a=0,f.b=0,f.c=-1640531527,f.d=1367130551,h===Math.floor(h)?(f.a=h/4294967296|0,f.b=h|0):p+=h;for(var g=0;g<p.length+20;g++)f.b^=p.charCodeAt(g)|0,f.next()}function l(h,f){return f.a=h.a,f.b=h.b,f.c=h.c,f.d=h.d,f}function d(h,f){var p=new u(h),g=f&&f.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var _=p.next()>>>11,v=(p.next()>>>0)/4294967296,y=(_+v)/(1<<21);while(y===0);return y},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}i&&i.exports?i.exports=d:a&&a.amd?a(function(){return d}):this.tychei=d})(commonjsGlobal,c,!1)})(tychei$1);var tycheiExports=tychei$1.exports,seedrandom$1={exports:{}};const __viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(__viteBrowserExternal$1);(function(c){(function(s,i,a){var u=256,l=6,d=52,h="random",f=a.pow(u,l),p=a.pow(2,d),g=p*2,m=u-1,_;function v(b,N,C){var w=[];N=N==!0?{entropy:!0}:N||{};var S=x(T(N.entropy?[b,E(i)]:b??O(),3),w),M=new y(w),P=function(){for(var I=M.g(l),k=f,D=0;I<p;)I=(I+D)*u,k*=u,D=M.g(1);for(;I>=g;)I/=2,k/=2,D>>>=1;return(I+D)/k};return P.int32=function(){return M.g(4)|0},P.quick=function(){return M.g(4)/4294967296},P.double=P,x(E(M.S),i),(N.pass||C||function(I,k,D,R){return R&&(R.S&&A(R,M),I.state=function(){return A(M,{})}),D?(a[h]=I,k):I})(P,S,"global"in N?N.global:this==a,N.state)}function y(b){var N,C=b.length,w=this,S=0,M=w.i=w.j=0,P=w.S=[];for(C||(b=[C++]);S<u;)P[S]=S++;for(S=0;S<u;S++)P[S]=P[M=m&M+b[S%C]+(N=P[S])],P[M]=N;(w.g=function(I){for(var k,D=0,R=w.i,z=w.j,V=w.S;I--;)k=V[R=m&R+1],D=D*u+V[m&(V[R]=V[z=m&z+k])+(V[z]=k)];return w.i=R,w.j=z,D})(u)}function A(b,N){return N.i=b.i,N.j=b.j,N.S=b.S.slice(),N}function T(b,N){var C=[],w=typeof b,S;if(N&&w=="object")for(S in b)try{C.push(T(b[S],N-1))}catch{}return C.length?C:w=="string"?b:b+"\0"}function x(b,N){for(var C=b+"",w,S=0;S<C.length;)N[m&S]=m&(w^=N[m&S]*19)+C.charCodeAt(S++);return E(N)}function O(){try{var b;return _&&(b=_.randomBytes)?b=b(u):(b=new Uint8Array(u),(s.crypto||s.msCrypto).getRandomValues(b)),E(b)}catch{var N=s.navigator,C=N&&N.plugins;return[+new Date,s,C,s.screen,E(i)]}}function E(b){return String.fromCharCode.apply(0,b)}if(x(a.random(),i),c.exports){c.exports=v;try{_=require$$0}catch{}}else a["seed"+h]=v})(typeof self<"u"?self:commonjsGlobal,[],Math)})(seedrandom$1);var seedrandomExports=seedrandom$1.exports,alea=aleaExports,xor128=xor128Exports,xorwow=xorwowExports,xorshift7=xorshift7Exports,xor4096=xor4096Exports,tychei=tycheiExports,sr=seedrandomExports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;var seedrandom=sr;const Random=getDefaultExportFromCjs(seedrandom);class Voxel{constructor(s,i,a,u,l,d,h){F(this,"running",!1);F(this,"velocity");F(this,"position");F(this,"computePipeline");F(this,"actorsBuffer");F(this,"computeBindGroup");F(this,"actorsReadBuffer");F(this,"density");this.velocity=s,this.position=i,this.computePipeline=a,this.actorsBuffer=u,this.computeBindGroup=l,this.actorsReadBuffer=d,this.density=h}static async init(s,i,a){const u=Density.patch(Physics),l=fromValues$1(0,0,0),d=performance.now();console.log("Loading physics engine");const h=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:u}),entryPoint:"computePhysics"}}),f=new Int32Array(512),p=new Random("James");for(let T=0;T<256;T++)f[T]=256*p();for(let T=256;T<512;T++)f[T]=f[T-256];const g=s.createBuffer({size:f.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Int32Array(g.getMappedRange()).set(f),g.unmap();const m=s.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(m.getMappedRange()).set(i),m.unmap();const v=s.createBindGroup({layout:h.getBindGroupLayout(0),entries:[{binding:6,resource:{buffer:m}}]}),y=s.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),A=await a.apply(s,h);return console.log("Physics engine loaded",performance.now()-d),new Voxel(l,i,h,m,v,y,A)}generate(s,i){return new Promise(a=>{s.queue.writeBuffer(this.actorsBuffer,Float32Array.BYTES_PER_ELEMENT*4,this.velocity.buffer);const u=s.createCommandEncoder(),l=u.beginComputePass();l.setPipeline(this.computePipeline),l.setBindGroup(0,this.computeBindGroup),this.density.apply(l),l.dispatchWorkgroups(1),l.end();const d=s.createCommandEncoder();d.copyBufferToBuffer(this.actorsBuffer,0,this.actorsReadBuffer,0,Float32Array.BYTES_PER_ELEMENT*8),i({items:[u.finish(),d.finish()],callback:()=>{this.actorsReadBuffer.mapAsync(GPUMapMode.READ).then(()=>{const h=this.actorsReadBuffer.getMappedRange(),f=new Float32Array(h);this.position.set([f[0],f[1],f[2]]),this.actorsReadBuffer.unmap(),a()})}})})}async update(s,i){if(this.running)return Promise.resolve();this.running=!0,await this.generate(s,i),this.running=!1}}class Mouse{constructor(){F(this,"position");this.position={x:0,y:0}}init(){const s=i=>{this.position.x+=i.movementX,this.position.y+=i.movementY};document.addEventListener("mousemove",s)}update(){this.position.x=0,this.position.y=0}}const Ray=`#import density

struct Uniforms {
  position: vec3<f32>,
  direction: vec3<f32>
}
@binding(0) @group(0) var<uniform> uniforms : Uniforms;

struct Intersection {
  position: vec3<f32>,
  found: u32,
  normal: vec3<f32>,
  distance: f32
}
@binding(1) @group(0) var <storage, read_write> intersection: Intersection;


@compute @workgroup_size(1)
fn main() {

  let direction = normalize(uniforms.direction);
  var i = 1.0;

  intersection.found = 0;

  loop {
    let position = uniforms.position + direction * i;
    let density = getDensity(position);

    if (i > 10000) {
      return;
    }

    if (density < 0) {
      intersection.found = 1;
      intersection.position = position;
      intersection.normal = vec3<f32>(3.0, 5.0, 1.0);
      intersection.distance = length(uniforms.position - position);
      return;
    }

    continuing {
      i = i + 1;
    }
  }
}
`;class Intersection{constructor(s,i,a){F(this,"position");F(this,"normal");F(this,"distance");this.position=s,this.normal=i,this.distance=a}}class Raycast{constructor(s,i,a,u,l,d){F(this,"computePipeline");F(this,"uniformBuffer");F(this,"intersectionsBuffer");F(this,"computeBindGroup");F(this,"intersectionsReadBuffer");F(this,"density");this.computePipeline=s,this.uniformBuffer=i,this.intersectionsBuffer=a,this.computeBindGroup=u,this.intersectionsReadBuffer=l,this.density=d}static async init(s,i){const a=await s.createComputePipelineAsync({layout:"auto",compute:{module:s.createShaderModule({code:Density.patch(Ray)}),entryPoint:"main"}}),u=await i.apply(s,a),l=Float32Array.BYTES_PER_ELEMENT*8,d=s.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),h=s.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});h.unmap();const f=s.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:d}},{binding:1,resource:{buffer:h}}]}),p=s.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});return new Raycast(a,d,h,f,p,u)}cast(s,i,a,u){return new Promise(l=>{s.queue.writeBuffer(this.uniformBuffer,0,a.buffer),s.queue.writeBuffer(this.uniformBuffer,Float32Array.BYTES_PER_ELEMENT*4,u.buffer);const d=s.createCommandEncoder(),h=d.beginComputePass();h.setPipeline(this.computePipeline),h.setBindGroup(0,this.computeBindGroup),this.density.apply(h),h.dispatchWorkgroups(1),h.end();const f=s.createCommandEncoder();f.copyBufferToBuffer(this.intersectionsBuffer,0,this.intersectionsReadBuffer,0,Float32Array.BYTES_PER_ELEMENT*8),i({items:[d.finish(),f.finish()],callback:()=>{this.intersectionsReadBuffer.mapAsync(GPUMapMode.READ).then(()=>{const p=this.intersectionsReadBuffer.getMappedRange();new Uint32Array(p,Float32Array.BYTES_PER_ELEMENT*3,1)[0]===0&&l(null);const m=new Float32Array(p),_=new Intersection(fromValues$1(m[0],m[1],m[2]),fromValues$1(m[4],m[5],m[6]),m[7]);this.intersectionsReadBuffer.unmap(),l(_)})}})})}}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var extendStatics=function(c,s){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(i,a){i.__proto__=a}||function(i,a){for(var u in a)a.hasOwnProperty(u)&&(i[u]=a[u])},extendStatics(c,s)};function __extends(c,s){extendStatics(c,s);function i(){this.constructor=c}c.prototype=s===null?Object.create(s):(i.prototype=s.prototype,new i)}function __values(c){var s=typeof Symbol=="function"&&c[Symbol.iterator],i=0;return s?s.call(c):{next:function(){return c&&i>=c.length&&(c=void 0),{value:c&&c[i++],done:!c}}}}function __read(c,s){var i=typeof Symbol=="function"&&c[Symbol.iterator];if(!i)return c;var a=i.call(c),u,l=[],d;try{for(;(s===void 0||s-- >0)&&!(u=a.next()).done;)l.push(u.value)}catch(h){d={error:h}}finally{try{u&&!u.done&&(i=a.return)&&i.call(a)}finally{if(d)throw d.error}}return l}function __spread(){for(var c=[],s=0;s<arguments.length;s++)c=c.concat(__read(arguments[s]));return c}var Event=function(){function c(s,i){this.target=i,this.type=s}return c}(),ErrorEvent$1=function(c){__extends(s,c);function s(i,a){var u=c.call(this,"error",a)||this;return u.message=i.message,u.error=i,u}return s}(Event),CloseEvent=function(c){__extends(s,c);function s(i,a,u){i===void 0&&(i=1e3),a===void 0&&(a="");var l=c.call(this,"close",u)||this;return l.wasClean=!0,l.code=i,l.reason=a,l}return s}(Event);/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */var getGlobalWebSocket=function(){if(typeof WebSocket<"u")return WebSocket},isWebSocket=function(c){return typeof c<"u"&&!!c&&c.CLOSING===2},DEFAULT={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+Math.random()*4e3,minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:1/0,maxEnqueuedMessages:1/0,startClosed:!1,debug:!1},ReconnectingWebSocket=function(){function c(s,i,a){var u=this;a===void 0&&(a={}),this._listeners={error:[],message:[],open:[],close:[]},this._retryCount=-1,this._shouldReconnect=!0,this._connectLock=!1,this._binaryType="blob",this._closeCalled=!1,this._messageQueue=[],this.onclose=null,this.onerror=null,this.onmessage=null,this.onopen=null,this._handleOpen=function(l){u._debug("open event");var d=u._options.minUptime,h=d===void 0?DEFAULT.minUptime:d;clearTimeout(u._connectTimeout),u._uptimeTimeout=setTimeout(function(){return u._acceptOpen()},h),u._ws.binaryType=u._binaryType,u._messageQueue.forEach(function(f){return u._ws.send(f)}),u._messageQueue=[],u.onopen&&u.onopen(l),u._listeners.open.forEach(function(f){return u._callEventListener(l,f)})},this._handleMessage=function(l){u._debug("message event"),u.onmessage&&u.onmessage(l),u._listeners.message.forEach(function(d){return u._callEventListener(l,d)})},this._handleError=function(l){u._debug("error event",l.message),u._disconnect(void 0,l.message==="TIMEOUT"?"timeout":void 0),u.onerror&&u.onerror(l),u._debug("exec error listeners"),u._listeners.error.forEach(function(d){return u._callEventListener(l,d)}),u._connect()},this._handleClose=function(l){u._debug("close event"),u._clearTimeouts(),u._shouldReconnect&&u._connect(),u.onclose&&u.onclose(l),u._listeners.close.forEach(function(d){return u._callEventListener(l,d)})},this._url=s,this._protocols=i,this._options=a,this._options.startClosed&&(this._shouldReconnect=!1),this._connect()}return Object.defineProperty(c,"CONNECTING",{get:function(){return 0},enumerable:!0,configurable:!0}),Object.defineProperty(c,"OPEN",{get:function(){return 1},enumerable:!0,configurable:!0}),Object.defineProperty(c,"CLOSING",{get:function(){return 2},enumerable:!0,configurable:!0}),Object.defineProperty(c,"CLOSED",{get:function(){return 3},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CONNECTING",{get:function(){return c.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"OPEN",{get:function(){return c.OPEN},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CLOSING",{get:function(){return c.CLOSING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CLOSED",{get:function(){return c.CLOSED},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"binaryType",{get:function(){return this._ws?this._ws.binaryType:this._binaryType},set:function(s){this._binaryType=s,this._ws&&(this._ws.binaryType=s)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"retryCount",{get:function(){return Math.max(this._retryCount,0)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"bufferedAmount",{get:function(){var s=this._messageQueue.reduce(function(i,a){return typeof a=="string"?i+=a.length:a instanceof Blob?i+=a.size:i+=a.byteLength,i},0);return s+(this._ws?this._ws.bufferedAmount:0)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"extensions",{get:function(){return this._ws?this._ws.extensions:""},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"protocol",{get:function(){return this._ws?this._ws.protocol:""},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"readyState",{get:function(){return this._ws?this._ws.readyState:this._options.startClosed?c.CLOSED:c.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"url",{get:function(){return this._ws?this._ws.url:""},enumerable:!0,configurable:!0}),c.prototype.close=function(s,i){if(s===void 0&&(s=1e3),this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),!this._ws){this._debug("close enqueued: no ws instance");return}if(this._ws.readyState===this.CLOSED){this._debug("close: already closed");return}this._ws.close(s,i)},c.prototype.reconnect=function(s,i){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,!this._ws||this._ws.readyState===this.CLOSED?this._connect():(this._disconnect(s,i),this._connect())},c.prototype.send=function(s){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",s),this._ws.send(s);else{var i=this._options.maxEnqueuedMessages,a=i===void 0?DEFAULT.maxEnqueuedMessages:i;this._messageQueue.length<a&&(this._debug("enqueue",s),this._messageQueue.push(s))}},c.prototype.addEventListener=function(s,i){this._listeners[s]&&this._listeners[s].push(i)},c.prototype.dispatchEvent=function(s){var i,a,u=this._listeners[s.type];if(u)try{for(var l=__values(u),d=l.next();!d.done;d=l.next()){var h=d.value;this._callEventListener(s,h)}}catch(f){i={error:f}}finally{try{d&&!d.done&&(a=l.return)&&a.call(l)}finally{if(i)throw i.error}}return!0},c.prototype.removeEventListener=function(s,i){this._listeners[s]&&(this._listeners[s]=this._listeners[s].filter(function(a){return a!==i}))},c.prototype._debug=function(){for(var s=[],i=0;i<arguments.length;i++)s[i]=arguments[i];this._options.debug&&console.log.apply(console,__spread(["RWS>"],s))},c.prototype._getNextDelay=function(){var s=this._options,i=s.reconnectionDelayGrowFactor,a=i===void 0?DEFAULT.reconnectionDelayGrowFactor:i,u=s.minReconnectionDelay,l=u===void 0?DEFAULT.minReconnectionDelay:u,d=s.maxReconnectionDelay,h=d===void 0?DEFAULT.maxReconnectionDelay:d,f=0;return this._retryCount>0&&(f=l*Math.pow(a,this._retryCount-1),f>h&&(f=h)),this._debug("next delay",f),f},c.prototype._wait=function(){var s=this;return new Promise(function(i){setTimeout(i,s._getNextDelay())})},c.prototype._getNextUrl=function(s){if(typeof s=="string")return Promise.resolve(s);if(typeof s=="function"){var i=s();if(typeof i=="string")return Promise.resolve(i);if(i.then)return i}throw Error("Invalid URL")},c.prototype._connect=function(){var s=this;if(!(this._connectLock||!this._shouldReconnect)){this._connectLock=!0;var i=this._options,a=i.maxRetries,u=a===void 0?DEFAULT.maxRetries:a,l=i.connectionTimeout,d=l===void 0?DEFAULT.connectionTimeout:l,h=i.WebSocket,f=h===void 0?getGlobalWebSocket():h;if(this._retryCount>=u){this._debug("max retries reached",this._retryCount,">=",u);return}if(this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),!isWebSocket(f))throw Error("No valid WebSocket class provided");this._wait().then(function(){return s._getNextUrl(s._url)}).then(function(p){s._closeCalled||(s._debug("connect",{url:p,protocols:s._protocols}),s._ws=s._protocols?new f(p,s._protocols):new f(p),s._ws.binaryType=s._binaryType,s._connectLock=!1,s._addListeners(),s._connectTimeout=setTimeout(function(){return s._handleTimeout()},d))})}},c.prototype._handleTimeout=function(){this._debug("timeout event"),this._handleError(new ErrorEvent$1(Error("TIMEOUT"),this))},c.prototype._disconnect=function(s,i){if(s===void 0&&(s=1e3),this._clearTimeouts(),!!this._ws){this._removeListeners();try{this._ws.close(s,i),this._handleClose(new CloseEvent(s,i,this))}catch{}}},c.prototype._acceptOpen=function(){this._debug("accept open"),this._retryCount=0},c.prototype._callEventListener=function(s,i){"handleEvent"in i?i.handleEvent(s):i(s)},c.prototype._removeListeners=function(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))},c.prototype._addListeners=function(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))},c.prototype._clearTimeouts=function(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)},c}();function e(c){this.message=c}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r=typeof window<"u"&&window.atob&&window.atob.bind(window)||function(c){var s=String(c).replace(/=+$/,"");if(s.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var i,a,u=0,l=0,d="";a=s.charAt(l++);~a&&(i=u%4?64*i+a:a,u++%4)?d+=String.fromCharCode(255&i>>(-2*u&6)):0)a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a);return d};function t(c){var s=c.replace(/-/g,"+").replace(/_/g,"/");switch(s.length%4){case 0:break;case 2:s+="==";break;case 3:s+="=";break;default:throw"Illegal base64url string!"}try{return function(i){return decodeURIComponent(r(i).replace(/(.)/g,function(a,u){var l=u.charCodeAt(0).toString(16).toUpperCase();return l.length<2&&(l="0"+l),"%"+l}))}(s)}catch{return r(s)}}function n(c){this.message=c}function o(c,s){if(typeof c!="string")throw new n("Invalid token specified");var i=(s=s||{}).header===!0?0:1;try{return JSON.parse(t(c.split(".")[i]))}catch(a){throw new n("Invalid token specified: "+a.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";const apiUrl="wss://api.new-world.james-parker.dev";class Network{constructor(s,i,a,u,l,d){this.clientId=s,this.socket=i,this.players=a,this.createPlayer=u,this.density=l,this.device=d}static async init(s,i,a,u,l){const d=new ReconnectingWebSocket(`${apiUrl}/client`);return new Promise(h=>{d.onmessage=f=>{const p=JSON.parse(f.data);if(p.type==="connected"){if(p.state){const m=o(p.state);set(s.position,m.position.x,m.position.y,m.position.z)}const g=new Network(p.clientId,d,i,a,u,l);d.onmessage=g.processMessage.bind(g),h(g)}}})}async sendData(s){this.socket.send(JSON.stringify({...s,clientId:this.clientId}))}async processMessage(s){const i=JSON.parse(s.data);if(i.state){const a=o(i.state);console.log(a)}switch(i.type){case"client_connected":if(i.clientId===this.clientId)break;this.createPlayer(i.clientId);break;case"position":{if(i.clientId===this.clientId)break;let a=this.players[i.clientId];a||(a=this.createPlayer(i.clientId)),set(a.position,i.position.x,i.position.y,i.position.z);break}case"build":{const a=JSON.parse(i.data);this.density.modify(this.device,{x:a.position.x,y:a.position.y,z:a.position.z,size:a.size,type:a.tool,shape:a.shape,material:a.material})}}}}const cubeVertexSize=4*10,cubePositionOffset=0,cubeUVOffset=4*8,cubeVertexCount=36,cubeVertexArray=new Float32Array([1,-1,1,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,0,0,1,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,0,0,-1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,-1,1,1,1,0,1,0,0,-1,1,-1,1,0,1,0,1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,-1,1,1,1,0,1,0,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,1,-1,1,0,1,0,1,0,0,-1,-1,-1,1,0,0,0,1,1,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,-1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,0,0,1,1,0,0,1,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,-1,-1,-1,1,0,0,0,1,0,1,-1,1,-1,1,0,1,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,-1,1,-1,1,0,1,0,1,0,0]),vertex=`struct Uniforms {\r
  modelViewProjectionMatrix : mat4x4<f32>,\r
}\r
@binding(0) @group(0) var<uniform> uniforms : Uniforms;\r
\r
struct VertexOutput {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) fragUV : vec2<f32>,\r
  @location(1) fragPosition: vec4<f32>,\r
}\r
\r
@vertex\r
fn main(\r
  @location(0) position : vec4<f32>,\r
  @location(1) uv : vec2<f32>\r
) -> VertexOutput {\r
  var output : VertexOutput;\r
  output.Position = uniforms.modelViewProjectionMatrix * (position * 100.0);\r
  output.fragUV = uv;\r
  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\r
  return output;\r
}\r
`,fragment=`\r
@fragment\r
fn main(\r
  @location(0) fragUV: vec2<f32>,\r
  @location(1) fragPosition: vec4<f32>\r
) -> @location(0) vec4<f32> {\r
  return fragPosition;\r
}`;class Player{constructor(s,i){F(this,"position");F(this,"vertexBuffer");F(this,"uniformBuffer");F(this,"uniformBindGroup");F(this,"pipeline");this.position=i,this.pipeline=s.createRenderPipeline({layout:"auto",vertex:{module:s.createShaderModule({code:vertex}),entryPoint:"main",buffers:[{arrayStride:cubeVertexSize,attributes:[{shaderLocation:0,offset:cubePositionOffset,format:"float32x4"},{shaderLocation:1,offset:cubeUVOffset,format:"float32x2"}]}]},fragment:{module:s.createShaderModule({code:fragment}),entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.vertexBuffer=s.createBuffer({size:cubeVertexArray.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(cubeVertexArray),this.vertexBuffer.unmap();const a=4*16;this.uniformBuffer=s.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=s.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]})}getTransformationMatrix(s){const i=create$3();translate(i,i,this.position),scale$1(i,i,fromValues$1(100,100,100));const a=create$3();return multiply$2(a,s,i),a}update(s,i){const a=this.getTransformationMatrix(i);s.queue.writeBuffer(this.uniformBuffer,0,a.buffer,a.byteOffset,a.byteLength)}draw(s){s.setPipeline(this.pipeline),s.setBindGroup(0,this.uniformBindGroup),s.setVertexBuffer(0,this.vertexBuffer),s.draw(cubeVertexCount,1,0,0)}}function fixPoint(c){return c>=0?c+1:c}function generatePoints(c){const s=[],i=c*2;for(let a=0;a<i;a++)for(let u=0;u<i;u++)for(let l=0;l<i;l++){if(!(a===0||a===i-1||u===0||u===i-1||l===0||l===i-1))continue;const d={x:fixPoint(a-c),y:fixPoint(u-c),z:fixPoint(l-c)};s.push(d)}return s}const points=[];for(let c=0;c<=6;c++)points[c]=generatePoints(c);class WorldGenerator{constructor(s){F(this,"minStride");this.minStride=s}init(s,i,a){return{x:Math.round(s/this.minStride)*this.minStride,y:Math.round(i/this.minStride)*this.minStride,z:Math.round(a/this.minStride)*this.minStride,stride:this.minStride,iteration:0,layer:1,previousOffset:-1*this.minStride/2}}layerRadius(s,i){return i===this.minStride?s:2}radius(s,i,a){return Math.sign(s)*(a+Math.abs(s)*i)}layerCount(s){return s==this.minStride?2:1}next(s){const i=points[this.layerRadius(s.layer,s.stride)],a=i[s.iteration],u=s.stride/2;let l=s.iteration+1,d=s.layer,h=s.stride,f=s.previousOffset;if(l>=i.length){l=0,d++;const p=this.layerCount(s.stride);d>p&&(d=1,h*=2,f=this.radius(s.layer,s.stride,s.previousOffset)-s.stride/2)}return[{x:s.stride*a.x+s.x-Math.sign(a.x)*u,y:s.stride*a.y+s.y-Math.sign(a.y)*u,z:s.stride*a.z+s.z-Math.sign(a.z)*u,stride:s.stride},{...s,iteration:l,layer:d,stride:h,previousOffset:f}]}}class Camera{constructor(s,i,a){F(this,"forward");F(this,"viewMatrix");F(this,"rotation");this.controller=s,this.mouse=i,this.touchController=a,this.viewMatrix=create$3(),this.rotation=0,this.forward=create$2()}update(s){const i=this.mouse.position.y+this.touchController.position.y;this.rotation-=toRadian(i*.08),this.rotation=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.rotation));const a=this.controller.getTransformMatrix();copy$1(this.viewMatrix,a),rotateX(this.viewMatrix,this.viewMatrix,this.rotation),normalize$2(this.forward,this.viewMatrix.slice(8,11)),invert(this.viewMatrix,this.viewMatrix),multiply$2(this.viewMatrix,s,this.viewMatrix)}}class Pointer{constructor(s,i,a,u){F(this,"position");F(this,"vertexBuffer");F(this,"uniformBuffer");F(this,"uniformBindGroup");F(this,"pipeline");F(this,"updating");F(this,"size",32);F(this,"snapToGrid",!0);this.controller=i,this.camera=a,this.raycast=u,this.position=create$2(),this.updating=!1,this.pipeline=s.createRenderPipeline({layout:"auto",vertex:{module:s.createShaderModule({code:vertex}),entryPoint:"main",buffers:[{arrayStride:cubeVertexSize,attributes:[{shaderLocation:0,offset:cubePositionOffset,format:"float32x4"},{shaderLocation:1,offset:cubeUVOffset,format:"float32x2"}]}]},fragment:{module:s.createShaderModule({code:fragment}),entryPoint:"main",targets:[{format:navigator.gpu.getPreferredCanvasFormat()}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.vertexBuffer=s.createBuffer({size:cubeVertexArray.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(cubeVertexArray),this.vertexBuffer.unmap();const l=4*16;this.uniformBuffer=s.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=s.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]})}getTransformationMatrix(s){const i=create$3();translate(i,i,this.position),scale$1(i,i,fromValues$1(10,10,10));const a=create$3();return multiply$2(a,s,i),a}update(s,i,a){if(!this.updating){this.updating=!0;const l=create$2();scale(l,this.controller.up,100),add(l,this.controller.position,l),this.raycast.cast(s,i,l,scale(create$2(),this.camera.forward,-1)).then(d=>{if(this.updating=!1,d!==null&&(copy(this.position,d.position),this.snapToGrid)){const h=this.size*2;this.position[0]=Math.round(this.position[0]/h)*h,this.position[1]=Math.round(this.position[1]/h)*h,this.position[2]=Math.round(this.position[2]/h)*h}})}const u=this.getTransformationMatrix(a);s.queue.writeBuffer(this.uniformBuffer,0,u.buffer,u.byteOffset,u.byteLength)}draw(s){s.setPipeline(this.pipeline),s.setBindGroup(0,this.uniformBindGroup),s.setVertexBuffer(0,this.vertexBuffer),s.draw(cubeVertexCount,1,0,0)}}class TouchController{constructor(){F(this,"position");F(this,"primaryTrigger",!1);F(this,"leftMoved",!1);F(this,"previousTouch",null);this.position={x:0,y:0}}init(){const s=i=>{const a=i.touches[0];console.log("Move"),this.leftMoved=!0,this.previousTouch&&(this.position.x+=this.previousTouch.screenX-a.screenX,this.position.y+=this.previousTouch.screenY-a.screenY),this.previousTouch=a};document.addEventListener("touchmove",s),document.addEventListener("touchstart",i=>{console.log(i)}),document.addEventListener("touchend",()=>{this.previousTouch=null,this.leftMoved||(this.primaryTrigger=!0),this.leftMoved=!1})}update(){this.position.x=0,this.position.y=0,this.primaryTrigger=!1}}class Game{constructor(s,i,a,u,l,d,h,f,p,g,m,_){F(this,"lastUpdate",0);F(this,"lastTimestamp",0);F(this,"tool",DensityType.Add);F(this,"shape",DensityShape.Sphere);F(this,"material",DensityMaterial.Rock);this.voxelWorker=s,this.keyboard=i,this.mouse=a,this.physics=u,this.controller=l,this.touchController=d,this.camera=h,this.collection=f,this.network=p,this.players=g,this.pointer=m,this.generate=_}static async init(s){const i=new Keyboard;i.init();const a=new Mouse;a.init();const u=new TouchController;u.init();const l=new Controller(i,a,u);l.init();const d=new Camera(l,a,u),h=await Density.init(s),f=new Map,p=await Network.init(l,f,w=>{const S=new Player(s,fromValues$1(2e6,100,100));return f[w]=S,S},h,s);await p.sendData({type:"move",position:{x:0,y:0,z:0}});const g=await Voxel.init(s,fromValues(l.position[0],l.position[1],l.position[2],0),h),m=await VoxelCollection.init(s,h),_=await Raycast.init(s,h),v=await new Promise(w=>{const S=new WorkerWrapper;S.onmessage=({data:M})=>{M.type==="init_complete"&&(console.log("Received Voxel engine init complete"),w(S))}}),y=2,A=31,T=new WorldGenerator(y);let x=performance.now(),O,E=!1;v.onmessage=({data:w})=>{const{type:S,vertices:M,consistency:P,normals:I,indices:k,corners:D,stride:R}=w;switch(S){case"clear":m.freeAll();break;case"update":{m.set(s,`${w.ix}x${w.iy}x${w.iz}`,{x:w.x,y:w.y,z:w.z},{x:w.ix,y:w.iy,z:w.iz},R,new Float32Array(M),new Float32Array(I),new Uint16Array(k),new Uint32Array(D),P);break}}if(O.stride>32768){E=!1,console.log(`Generation complete in ${performance.now()-x} milliseconds with ${m.objects.size} objects`);return}const z=T.next(O),V=z[0];v.postMessage({stride:R,position:l.position,detail:{x:V.x,y:V.y,z:V.z,s:V.stride},density:h.augmentations}),O=z[1]};const b=()=>{if(x=performance.now(),O=T.init(l.position[0]/A,l.position[1]/A,l.position[2]/A),console.log(E),E)return;E=!0;const w=T.next(O),S=w[0];v.postMessage({stride:y,position:l.position,detail:{x:S.x,y:S.y,z:S.z,s:S.stride},density:h.augmentations}),O=w[1]};b(),h.onModified=b;const N=new Pointer(s,l,d,_),C=new Game(v,i,a,g,l,u,d,m,p,f,N,b);return document.getElementById("loading").style.display="none",C}destroy(){this.voxelWorker.terminate()}async update(s,i,a){const u=a-this.lastTimestamp,l=p=>{s.queue.onSubmittedWorkDone().then(()=>{p.callback()}),s.queue.submit(p.items)},d=DensityShape[Object.keys(DensityShape).sort(p=>-DensityShape[p])[0]];this.keyboard.keydown("1")&&(this.tool=DensityType.Add),this.keyboard.keydown("2")&&(this.tool=DensityType.Subtract),this.keyboard.keypress("3")&&(this.shape=Math.max(0,this.shape-1)),this.keyboard.keypress("4")&&(this.shape=Math.min(d,this.shape+1)),this.keyboard.keydown("5")&&(this.material=DensityMaterial.Rock),this.keyboard.keydown("6")&&(this.material=DensityMaterial.Wood),this.keyboard.keydown("7")&&(this.material=DensityMaterial.Fire),this.keyboard.keypress("t")&&(this.pointer.snapToGrid=!this.pointer.snapToGrid),this.keyboard.keypress("=")&&(this.pointer.size=this.pointer.size*2),this.keyboard.keypress("-")&&(this.pointer.size=Math.max(4,this.pointer.size/2));const h=document.getElementById("tool");if(h&&(h.innerText=`${DensityType[this.tool]} - ${DensityShape[this.shape]} - ${DensityMaterial[this.material]} - ${this.pointer.size} - ${this.pointer.snapToGrid}`),a-this.lastUpdate>1e4&&(this.network.sendData({type:"position",position:{x:this.controller.position[0],y:this.controller.position[1],z:this.controller.position[2]}}),this.lastUpdate=a),this.keyboard.keypress("g")&&this.generate(),this.keyboard.keypress(" ")||this.touchController.primaryTrigger){const p=create$2();scale(p,this.controller.up,100),add(p,this.controller.position,p),this.network.sendData({type:"build",data:JSON.stringify({position:{x:this.pointer.position[0],y:this.pointer.position[1],z:this.pointer.position[2]},shape:this.shape,material:this.material,tool:this.tool,size:this.pointer.size})})}this.physics.velocity=this.controller.velocity,await this.physics.update(s,p=>l(p)),this.controller.position=this.physics.position,this.controller.update(u),this.camera.update(i);const f=this.camera.viewMatrix;this.pointer.update(s,l,f),this.collection.update(s,f,a);for(const p in this.players)this.players[p].update(s,f,a);this.keyboard.update(),this.mouse.update(),this.touchController.update(),this.lastTimestamp=a}draw(s){this.pointer.draw(s);for(const i in this.players)this.players[i].draw(s);this.collection.draw(s)}}(async function(){const canvas=document.getElementById("canvas"),projectionMatrix=create$3(),steamworks=eval(`typeof require === "function" && require('steamworks.js')`);if(steamworks)try{const c=steamworks.init(2377570);console.log(c.localplayer.getName()),c.localplayer.getSteamId(),c.achievement.activate("ACH_WIN_ONE_GAME")||console.log("Sad fish"),console.log("Steam ID",c.localplayer.getSteamId()),c.auth.getSessionTicket().then(s=>{const i=s.getBytes();console.log("ticket",i.toString("hex"))})}catch{}const renderer=await Renderer.init(canvas),configureRenderer=()=>{canvas.width=window.innerWidth,canvas.height=window.innerHeight;const c=Math.abs(canvas.width/canvas.height);perspective(projectionMatrix,2*Math.PI/5,c,1,1e8),renderer.configure(canvas.width,canvas.height)};window.addEventListener("resize",configureRenderer,!1),window.addEventListener("click",()=>{canvas.requestPointerLock()});let game=await Game.init(renderer.device);configureRenderer(),performance.now();const stats=new Stats;stats.showPanel(0),document.body.appendChild(stats.dom),window.addEventListener("beforeunload",()=>{renderer.running=!1,game.destroy()});const doFrame=async c=>{renderer.running&&(stats.begin(),await game.update(renderer.device,projectionMatrix,c),renderer.render(s=>game.draw(s)),performance.now(),stats.end(),requestAnimationFrame(doFrame))};requestAnimationFrame(doFrame)})();
