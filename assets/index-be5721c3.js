var ye=Object.defineProperty;var ve=(c,i,s)=>i in c?ye(c,i,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[i]=s;var q=(c,i,s)=>(ve(c,typeof i!="symbol"?i+"":i,s),s);(function(){const i=document.createElement("link").relList;if(i&&i.supports&&i.supports("modulepreload"))return;for(const u of document.querySelectorAll('link[rel="modulepreload"]'))a(u);new MutationObserver(u=>{for(const l of u)if(l.type==="childList")for(const h of l.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&a(h)}).observe(document,{childList:!0,subtree:!0});function s(u){const l={};return u.integrity&&(l.integrity=u.integrity),u.referrerpolicy&&(l.referrerPolicy=u.referrerpolicy),u.crossorigin==="use-credentials"?l.credentials="include":u.crossorigin==="anonymous"?l.credentials="omit":l.credentials="same-origin",l}function a(u){if(u.ep)return;u.ep=!0;const l=s(u);fetch(u.href,l)}})();const styles="";var commonjsGlobal=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function getDefaultExportFromCjs(c){return c&&c.__esModule&&Object.prototype.hasOwnProperty.call(c,"default")?c.default:c}function getAugmentedNamespace(c){if(c.__esModule)return c;var i=c.default;if(typeof i=="function"){var s=function a(){if(this instanceof a){var u=[null];u.push.apply(u,arguments);var l=Function.bind.apply(i,u);return new l}return i.apply(this,arguments)};s.prototype=i.prototype}else s={};return Object.defineProperty(s,"__esModule",{value:!0}),Object.keys(c).forEach(function(a){var u=Object.getOwnPropertyDescriptor(c,a);Object.defineProperty(s,a,u.get?u:{enumerable:!0,get:function(){return c[a]}})}),s}var stats_minExports={},stats_min={get exports(){return stats_minExports},set exports(c){stats_minExports=c}};(function(c,i){(function(s,a){c.exports=a()})(commonjsGlobal,function(){var s=function(){function a(v){return h.appendChild(v.dom),v}function u(v){for(var _=0;_<h.children.length;_++)h.children[_].style.display=_===v?"block":"none";l=v}var l=0,h=document.createElement("div");h.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",h.addEventListener("click",function(v){v.preventDefault(),u(++l%h.children.length)},!1);var f=(performance||Date).now(),d=f,p=0,g=a(new s.Panel("FPS","#0ff","#002")),m=a(new s.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var y=a(new s.Panel("MB","#f08","#201"));return u(0),{REVISION:16,dom:h,addPanel:a,showPanel:u,begin:function(){f=(performance||Date).now()},end:function(){p++;var v=(performance||Date).now();if(m.update(v-f,200),v>d+1e3&&(g.update(1e3*p/(v-d),100),d=v,p=0,y)){var _=performance.memory;y.update(_.usedJSHeapSize/1048576,_.jsHeapSizeLimit/1048576)}return v},update:function(){f=this.end()},domElement:h,setMode:u}};return s.Panel=function(a,u,l){var h=1/0,f=0,d=Math.round,p=d(window.devicePixelRatio||1),g=80*p,m=48*p,y=3*p,v=2*p,_=3*p,A=15*p,T=74*p,x=30*p,w=document.createElement("canvas");w.width=g,w.height=m,w.style.cssText="width:80px;height:48px";var b=w.getContext("2d");return b.font="bold "+9*p+"px Helvetica,Arial,sans-serif",b.textBaseline="top",b.fillStyle=l,b.fillRect(0,0,g,m),b.fillStyle=u,b.fillText(a,y,v),b.fillRect(_,A,T,x),b.fillStyle=l,b.globalAlpha=.9,b.fillRect(_,A,T,x),{dom:w,update:function(C,N){h=Math.min(h,C),f=Math.max(f,C),b.fillStyle=l,b.globalAlpha=1,b.fillRect(0,0,g,A),b.fillStyle=u,b.fillText(d(C)+" "+a+" ("+d(h)+"-"+d(f)+")",y,v),b.drawImage(w,_+p,A,T-p,x,_,A,T-p,x),b.fillRect(_+T-p,A,p,x),b.fillStyle=l,b.globalAlpha=.9,b.fillRect(_+T-p,A,p,d((1-C/N)*x))}}},s})})(stats_min);const Stats=stats_minExports;class Renderer{constructor(i,s,a){q(this,"running");q(this,"context");q(this,"device");q(this,"presentationFormat");q(this,"depthTexture",null);this.device=i,this.context=s,this.presentationFormat=a,this.running=!0}static async init(i){const s=await navigator.gpu.requestAdapter();if(!s)throw new Error("Unable to acquire GPU adapter, is WebGPU enabled?");const a=await s.requestDevice(),u=i.getContext("webgpu"),l=navigator.gpu.getPreferredCanvasFormat();return new Renderer(a,u,l)}configure(i,s){this.context.configure({device:this.device,format:this.presentationFormat,alphaMode:"opaque"}),this.depthTexture=this.device.createTexture({size:{width:i,height:s},format:"depth24plus-stencil8",usage:GPUTextureUsage.RENDER_ATTACHMENT})}render(i){const s=this.device.createCommandEncoder(),u={colorAttachments:[{view:this.context.getCurrentTexture().createView(),clearValue:{r:75/255,g:0/255,b:130/255,a:1},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:this.depthTexture.createView(),depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0,stencilLoadOp:"clear",stencilStoreOp:"store"}},l=s.beginRenderPass(u);i(l),l.end(),this.device.queue.submit([s.finish()])}}function WorkerWrapper(){return new Worker("/assets/contouring.worker-4480d662.js")}var EPSILON$1=1e-6,ARRAY_TYPE=typeof Float32Array<"u"?Float32Array:Array,degree=Math.PI/180;function toRadian(c){return c*degree}Math.hypot||(Math.hypot=function(){for(var c=0,i=arguments.length;i--;)c+=arguments[i]*arguments[i];return Math.sqrt(c)});function create$6(){var c=new ARRAY_TYPE(9);return ARRAY_TYPE!=Float32Array&&(c[1]=0,c[2]=0,c[3]=0,c[5]=0,c[6]=0,c[7]=0),c[0]=1,c[4]=1,c[8]=1,c}function create$5(){var c=new ARRAY_TYPE(16);return ARRAY_TYPE!=Float32Array&&(c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[11]=0,c[12]=0,c[13]=0,c[14]=0),c[0]=1,c[5]=1,c[10]=1,c[15]=1,c}function copy$1(c,i){return c[0]=i[0],c[1]=i[1],c[2]=i[2],c[3]=i[3],c[4]=i[4],c[5]=i[5],c[6]=i[6],c[7]=i[7],c[8]=i[8],c[9]=i[9],c[10]=i[10],c[11]=i[11],c[12]=i[12],c[13]=i[13],c[14]=i[14],c[15]=i[15],c}function identity(c){return c[0]=1,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=1,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[10]=1,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,c}function invert(c,i){var s=i[0],a=i[1],u=i[2],l=i[3],h=i[4],f=i[5],d=i[6],p=i[7],g=i[8],m=i[9],y=i[10],v=i[11],_=i[12],A=i[13],T=i[14],x=i[15],w=s*f-a*h,b=s*d-u*h,C=s*p-l*h,N=a*d-u*f,S=a*p-l*f,O=u*p-l*d,E=g*A-m*_,R=g*T-y*_,I=g*x-v*_,M=m*T-y*A,k=m*x-v*A,B=y*x-v*T,P=w*B-b*k+C*M+N*I-S*R+O*E;return P?(P=1/P,c[0]=(f*B-d*k+p*M)*P,c[1]=(u*k-a*B-l*M)*P,c[2]=(A*O-T*S+x*N)*P,c[3]=(y*S-m*O-v*N)*P,c[4]=(d*I-h*B-p*R)*P,c[5]=(s*B-u*I+l*R)*P,c[6]=(T*C-_*O-x*b)*P,c[7]=(g*O-y*C+v*b)*P,c[8]=(h*k-f*I+p*E)*P,c[9]=(a*I-s*k-l*E)*P,c[10]=(_*S-A*C+x*w)*P,c[11]=(m*C-g*S-v*w)*P,c[12]=(f*R-h*M-d*E)*P,c[13]=(s*M-a*R+u*E)*P,c[14]=(A*b-_*N-T*w)*P,c[15]=(g*N-m*b+y*w)*P,c):null}function multiply$2(c,i,s){var a=i[0],u=i[1],l=i[2],h=i[3],f=i[4],d=i[5],p=i[6],g=i[7],m=i[8],y=i[9],v=i[10],_=i[11],A=i[12],T=i[13],x=i[14],w=i[15],b=s[0],C=s[1],N=s[2],S=s[3];return c[0]=b*a+C*f+N*m+S*A,c[1]=b*u+C*d+N*y+S*T,c[2]=b*l+C*p+N*v+S*x,c[3]=b*h+C*g+N*_+S*w,b=s[4],C=s[5],N=s[6],S=s[7],c[4]=b*a+C*f+N*m+S*A,c[5]=b*u+C*d+N*y+S*T,c[6]=b*l+C*p+N*v+S*x,c[7]=b*h+C*g+N*_+S*w,b=s[8],C=s[9],N=s[10],S=s[11],c[8]=b*a+C*f+N*m+S*A,c[9]=b*u+C*d+N*y+S*T,c[10]=b*l+C*p+N*v+S*x,c[11]=b*h+C*g+N*_+S*w,b=s[12],C=s[13],N=s[14],S=s[15],c[12]=b*a+C*f+N*m+S*A,c[13]=b*u+C*d+N*y+S*T,c[14]=b*l+C*p+N*v+S*x,c[15]=b*h+C*g+N*_+S*w,c}function translate(c,i,s){var a=s[0],u=s[1],l=s[2],h,f,d,p,g,m,y,v,_,A,T,x;return i===c?(c[12]=i[0]*a+i[4]*u+i[8]*l+i[12],c[13]=i[1]*a+i[5]*u+i[9]*l+i[13],c[14]=i[2]*a+i[6]*u+i[10]*l+i[14],c[15]=i[3]*a+i[7]*u+i[11]*l+i[15]):(h=i[0],f=i[1],d=i[2],p=i[3],g=i[4],m=i[5],y=i[6],v=i[7],_=i[8],A=i[9],T=i[10],x=i[11],c[0]=h,c[1]=f,c[2]=d,c[3]=p,c[4]=g,c[5]=m,c[6]=y,c[7]=v,c[8]=_,c[9]=A,c[10]=T,c[11]=x,c[12]=h*a+g*u+_*l+i[12],c[13]=f*a+m*u+A*l+i[13],c[14]=d*a+y*u+T*l+i[14],c[15]=p*a+v*u+x*l+i[15]),c}function scale$1(c,i,s){var a=s[0],u=s[1],l=s[2];return c[0]=i[0]*a,c[1]=i[1]*a,c[2]=i[2]*a,c[3]=i[3]*a,c[4]=i[4]*u,c[5]=i[5]*u,c[6]=i[6]*u,c[7]=i[7]*u,c[8]=i[8]*l,c[9]=i[9]*l,c[10]=i[10]*l,c[11]=i[11]*l,c[12]=i[12],c[13]=i[13],c[14]=i[14],c[15]=i[15],c}function rotateX(c,i,s){var a=Math.sin(s),u=Math.cos(s),l=i[4],h=i[5],f=i[6],d=i[7],p=i[8],g=i[9],m=i[10],y=i[11];return i!==c&&(c[0]=i[0],c[1]=i[1],c[2]=i[2],c[3]=i[3],c[12]=i[12],c[13]=i[13],c[14]=i[14],c[15]=i[15]),c[4]=l*u+p*a,c[5]=h*u+g*a,c[6]=f*u+m*a,c[7]=d*u+y*a,c[8]=p*u-l*a,c[9]=g*u-h*a,c[10]=m*u-f*a,c[11]=y*u-d*a,c}function fromQuat(c,i){var s=i[0],a=i[1],u=i[2],l=i[3],h=s+s,f=a+a,d=u+u,p=s*h,g=a*h,m=a*f,y=u*h,v=u*f,_=u*d,A=l*h,T=l*f,x=l*d;return c[0]=1-m-_,c[1]=g+x,c[2]=y-T,c[3]=0,c[4]=g-x,c[5]=1-p-_,c[6]=v+A,c[7]=0,c[8]=y+T,c[9]=v-A,c[10]=1-p-m,c[11]=0,c[12]=0,c[13]=0,c[14]=0,c[15]=1,c}function perspectiveNO(c,i,s,a,u){var l=1/Math.tan(i/2),h;return c[0]=l/s,c[1]=0,c[2]=0,c[3]=0,c[4]=0,c[5]=l,c[6]=0,c[7]=0,c[8]=0,c[9]=0,c[11]=-1,c[12]=0,c[13]=0,c[15]=0,u!=null&&u!==1/0?(h=1/(a-u),c[10]=(u+a)*h,c[14]=2*u*a*h):(c[10]=-1,c[14]=-2*a),c}var perspective=perspectiveNO,mul=multiply$2;function create$4(){var c=new ARRAY_TYPE(3);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0),c}function length(c){var i=c[0],s=c[1],a=c[2];return Math.hypot(i,s,a)}function fromValues$1(c,i,s){var a=new ARRAY_TYPE(3);return a[0]=c,a[1]=i,a[2]=s,a}function copy(c,i){return c[0]=i[0],c[1]=i[1],c[2]=i[2],c}function set(c,i,s,a){return c[0]=i,c[1]=s,c[2]=a,c}function add(c,i,s){return c[0]=i[0]+s[0],c[1]=i[1]+s[1],c[2]=i[2]+s[2],c}function subtract(c,i,s){return c[0]=i[0]-s[0],c[1]=i[1]-s[1],c[2]=i[2]-s[2],c}function scale(c,i,s){return c[0]=i[0]*s,c[1]=i[1]*s,c[2]=i[2]*s,c}function normalize$2(c,i){var s=i[0],a=i[1],u=i[2],l=s*s+a*a+u*u;return l>0&&(l=1/Math.sqrt(l)),c[0]=i[0]*l,c[1]=i[1]*l,c[2]=i[2]*l,c}function dot(c,i){return c[0]*i[0]+c[1]*i[1]+c[2]*i[2]}function cross(c,i,s){var a=i[0],u=i[1],l=i[2],h=s[0],f=s[1],d=s[2];return c[0]=u*d-l*f,c[1]=l*h-a*d,c[2]=a*f-u*h,c}function zero(c){return c[0]=0,c[1]=0,c[2]=0,c}var sub=subtract,len=length;(function(){var c=create$4();return function(i,s,a,u,l,h){var f,d;for(s||(s=3),a||(a=0),u?d=Math.min(u*s+a,i.length):d=i.length,f=a;f<d;f+=s)c[0]=i[f],c[1]=i[f+1],c[2]=i[f+2],l(c,c,h),i[f]=c[0],i[f+1]=c[1],i[f+2]=c[2];return i}})();function create$3(){var c=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0,c[3]=0),c}function fromValues(c,i,s,a){var u=new ARRAY_TYPE(4);return u[0]=c,u[1]=i,u[2]=s,u[3]=a,u}function normalize$1(c,i){var s=i[0],a=i[1],u=i[2],l=i[3],h=s*s+a*a+u*u+l*l;return h>0&&(h=1/Math.sqrt(h)),c[0]=s*h,c[1]=a*h,c[2]=u*h,c[3]=l*h,c}(function(){var c=create$3();return function(i,s,a,u,l,h){var f,d;for(s||(s=4),a||(a=0),u?d=Math.min(u*s+a,i.length):d=i.length,f=a;f<d;f+=s)c[0]=i[f],c[1]=i[f+1],c[2]=i[f+2],c[3]=i[f+3],l(c,c,h),i[f]=c[0],i[f+1]=c[1],i[f+2]=c[2],i[f+3]=c[3];return i}})();function create$2(){var c=new ARRAY_TYPE(4);return ARRAY_TYPE!=Float32Array&&(c[0]=0,c[1]=0,c[2]=0),c[3]=1,c}function setAxisAngle(c,i,s){s=s*.5;var a=Math.sin(s);return c[0]=a*i[0],c[1]=a*i[1],c[2]=a*i[2],c[3]=Math.cos(s),c}function multiply$1(c,i,s){var a=i[0],u=i[1],l=i[2],h=i[3],f=s[0],d=s[1],p=s[2],g=s[3];return c[0]=a*g+h*f+u*p-l*d,c[1]=u*g+h*d+l*f-a*p,c[2]=l*g+h*p+a*d-u*f,c[3]=h*g-a*f-u*d-l*p,c}function rotateY(c,i,s){s*=.5;var a=i[0],u=i[1],l=i[2],h=i[3],f=Math.sin(s),d=Math.cos(s);return c[0]=a*d-l*f,c[1]=u*d+h*f,c[2]=l*d+a*f,c[3]=h*d-u*f,c}function rotateZ(c,i,s){s*=.5;var a=i[0],u=i[1],l=i[2],h=i[3],f=Math.sin(s),d=Math.cos(s);return c[0]=a*d+u*f,c[1]=u*d-a*f,c[2]=l*d+h*f,c[3]=h*d-l*f,c}function slerp(c,i,s,a){var u=i[0],l=i[1],h=i[2],f=i[3],d=s[0],p=s[1],g=s[2],m=s[3],y,v,_,A,T;return v=u*d+l*p+h*g+f*m,v<0&&(v=-v,d=-d,p=-p,g=-g,m=-m),1-v>EPSILON$1?(y=Math.acos(v),_=Math.sin(y),A=Math.sin((1-a)*y)/_,T=Math.sin(a*y)/_):(A=1-a,T=a),c[0]=A*u+T*d,c[1]=A*l+T*p,c[2]=A*h+T*g,c[3]=A*f+T*m,c}function fromMat3(c,i){var s=i[0]+i[4]+i[8],a;if(s>0)a=Math.sqrt(s+1),c[3]=.5*a,a=.5/a,c[0]=(i[5]-i[7])*a,c[1]=(i[6]-i[2])*a,c[2]=(i[1]-i[3])*a;else{var u=0;i[4]>i[0]&&(u=1),i[8]>i[u*3+u]&&(u=2);var l=(u+1)%3,h=(u+2)%3;a=Math.sqrt(i[u*3+u]-i[l*3+l]-i[h*3+h]+1),c[u]=.5*a,a=.5/a,c[3]=(i[l*3+h]-i[h*3+l])*a,c[l]=(i[l*3+u]+i[u*3+l])*a,c[h]=(i[h*3+u]+i[u*3+h])*a}return c}var normalize=normalize$1,rotationTo=function(){var c=create$4(),i=fromValues$1(1,0,0),s=fromValues$1(0,1,0);return function(a,u,l){var h=dot(u,l);return h<-.999999?(cross(c,i,u),len(c)<1e-6&&cross(c,s,u),normalize$2(c,c),setAxisAngle(a,c,Math.PI),a):h>.999999?(a[0]=0,a[1]=0,a[2]=0,a[3]=1,a):(cross(c,u,l),a[0]=c[0],a[1]=c[1],a[2]=c[2],a[3]=1+h,normalize(a,a))}}();(function(){var c=create$2(),i=create$2();return function(s,a,u,l,h,f){return slerp(c,a,h,f),slerp(i,u,l,f),slerp(s,c,i,2*f*(1-f)),s}})();(function(){var c=create$6();return function(i,s,a,u){return c[0]=a[0],c[3]=a[1],c[6]=a[2],c[1]=u[0],c[4]=u[1],c[7]=u[2],c[2]=-s[0],c[5]=-s[1],c[8]=-s[2],normalize(i,fromMat3(i,c))}})();const version="14.7.77",createExtendedExponentialRampToValueAutomationEvent=(c,i,s)=>({endTime:i,insertTime:s,type:"exponentialRampToValue",value:c}),createExtendedLinearRampToValueAutomationEvent=(c,i,s)=>({endTime:i,insertTime:s,type:"linearRampToValue",value:c}),createSetValueAutomationEvent=(c,i)=>({startTime:i,type:"setValue",value:c}),createSetValueCurveAutomationEvent=(c,i,s)=>({duration:s,startTime:i,type:"setValueCurve",values:c}),getTargetValueAtTime=(c,i,{startTime:s,target:a,timeConstant:u})=>a+(i-a)*Math.exp((s-c)/u),isExponentialRampToValueAutomationEvent=c=>c.type==="exponentialRampToValue",isLinearRampToValueAutomationEvent=c=>c.type==="linearRampToValue",isAnyRampToValueAutomationEvent=c=>isExponentialRampToValueAutomationEvent(c)||isLinearRampToValueAutomationEvent(c),isSetValueAutomationEvent=c=>c.type==="setValue",isSetValueCurveAutomationEvent=c=>c.type==="setValueCurve",getValueOfAutomationEventAtIndexAtTime=(c,i,s,a)=>{const u=c[i];return u===void 0?a:isAnyRampToValueAutomationEvent(u)||isSetValueAutomationEvent(u)?u.value:isSetValueCurveAutomationEvent(u)?u.values[u.values.length-1]:getTargetValueAtTime(s,getValueOfAutomationEventAtIndexAtTime(c,i-1,u.startTime,a),u)},getEndTimeAndValueOfPreviousAutomationEvent=(c,i,s,a,u)=>s===void 0?[a.insertTime,u]:isAnyRampToValueAutomationEvent(s)?[s.endTime,s.value]:isSetValueAutomationEvent(s)?[s.startTime,s.value]:isSetValueCurveAutomationEvent(s)?[s.startTime+s.duration,s.values[s.values.length-1]]:[s.startTime,getValueOfAutomationEventAtIndexAtTime(c,i-1,s.startTime,u)],isCancelAndHoldAutomationEvent=c=>c.type==="cancelAndHold",isCancelScheduledValuesAutomationEvent=c=>c.type==="cancelScheduledValues",getEventTime=c=>isCancelAndHoldAutomationEvent(c)||isCancelScheduledValuesAutomationEvent(c)?c.cancelTime:isExponentialRampToValueAutomationEvent(c)||isLinearRampToValueAutomationEvent(c)?c.endTime:c.startTime,getExponentialRampValueAtTime=(c,i,s,{endTime:a,value:u})=>s===u?u:0<s&&0<u||s<0&&u<0?s*(u/s)**((c-i)/(a-i)):0,getLinearRampValueAtTime=(c,i,s,{endTime:a,value:u})=>s+(c-i)/(a-i)*(u-s),interpolateValue=(c,i)=>{const s=Math.floor(i),a=Math.ceil(i);return s===a?c[s]:(1-(i-s))*c[s]+(1-(a-i))*c[a]},getValueCurveValueAtTime=(c,{duration:i,startTime:s,values:a})=>{const u=(c-s)/i*(a.length-1);return interpolateValue(a,u)},isSetTargetAutomationEvent=c=>c.type==="setTarget";class AutomationEventList{constructor(i){this._automationEvents=[],this._currenTime=0,this._defaultValue=i}[Symbol.iterator](){return this._automationEvents[Symbol.iterator]()}add(i){const s=getEventTime(i);if(isCancelAndHoldAutomationEvent(i)||isCancelScheduledValuesAutomationEvent(i)){const a=this._automationEvents.findIndex(l=>isCancelScheduledValuesAutomationEvent(i)&&isSetValueCurveAutomationEvent(l)?l.startTime+l.duration>=s:getEventTime(l)>=s),u=this._automationEvents[a];if(a!==-1&&(this._automationEvents=this._automationEvents.slice(0,a)),isCancelAndHoldAutomationEvent(i)){const l=this._automationEvents[this._automationEvents.length-1];if(u!==void 0&&isAnyRampToValueAutomationEvent(u)){if(isSetTargetAutomationEvent(l))throw new Error("The internal list is malformed.");const h=isSetValueCurveAutomationEvent(l)?l.startTime+l.duration:getEventTime(l),f=isSetValueCurveAutomationEvent(l)?l.values[l.values.length-1]:l.value,d=isExponentialRampToValueAutomationEvent(u)?getExponentialRampValueAtTime(s,h,f,u):getLinearRampValueAtTime(s,h,f,u),p=isExponentialRampToValueAutomationEvent(u)?createExtendedExponentialRampToValueAutomationEvent(d,s,this._currenTime):createExtendedLinearRampToValueAutomationEvent(d,s,this._currenTime);this._automationEvents.push(p)}l!==void 0&&isSetTargetAutomationEvent(l)&&this._automationEvents.push(createSetValueAutomationEvent(this.getValue(s),s)),l!==void 0&&isSetValueCurveAutomationEvent(l)&&l.startTime+l.duration>s&&(this._automationEvents[this._automationEvents.length-1]=createSetValueCurveAutomationEvent(new Float32Array([6,7]),l.startTime,s-l.startTime))}}else{const a=this._automationEvents.findIndex(h=>getEventTime(h)>s),u=a===-1?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[a-1];if(u!==void 0&&isSetValueCurveAutomationEvent(u)&&getEventTime(u)+u.duration>s)return!1;const l=isExponentialRampToValueAutomationEvent(i)?createExtendedExponentialRampToValueAutomationEvent(i.value,i.endTime,this._currenTime):isLinearRampToValueAutomationEvent(i)?createExtendedLinearRampToValueAutomationEvent(i.value,s,this._currenTime):i;if(a===-1)this._automationEvents.push(l);else{if(isSetValueCurveAutomationEvent(i)&&s+i.duration>getEventTime(this._automationEvents[a]))return!1;this._automationEvents.splice(a,0,l)}}return!0}flush(i){const s=this._automationEvents.findIndex(a=>getEventTime(a)>i);if(s>1){const a=this._automationEvents.slice(s-1),u=a[0];isSetTargetAutomationEvent(u)&&a.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents,s-2,u.startTime,this._defaultValue),u.startTime)),this._automationEvents=a}}getValue(i){if(this._automationEvents.length===0)return this._defaultValue;const s=this._automationEvents.findIndex(h=>getEventTime(h)>i),a=this._automationEvents[s],u=(s===-1?this._automationEvents.length:s)-1,l=this._automationEvents[u];if(l!==void 0&&isSetTargetAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)||a.insertTime>i))return getTargetValueAtTime(i,getValueOfAutomationEventAtIndexAtTime(this._automationEvents,u-1,l.startTime,this._defaultValue),l);if(l!==void 0&&isSetValueAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)))return l.value;if(l!==void 0&&isSetValueCurveAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)||l.startTime+l.duration>i))return i<l.startTime+l.duration?getValueCurveValueAtTime(i,l):l.values[l.values.length-1];if(l!==void 0&&isAnyRampToValueAutomationEvent(l)&&(a===void 0||!isAnyRampToValueAutomationEvent(a)))return l.value;if(a!==void 0&&isExponentialRampToValueAutomationEvent(a)){const[h,f]=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,u,l,a,this._defaultValue);return getExponentialRampValueAtTime(i,h,f,a)}if(a!==void 0&&isLinearRampToValueAutomationEvent(a)){const[h,f]=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,u,l,a,this._defaultValue);return getLinearRampValueAtTime(i,h,f,a)}return this._defaultValue}}const createCancelAndHoldAutomationEvent=c=>({cancelTime:c,type:"cancelAndHold"}),createCancelScheduledValuesAutomationEvent=c=>({cancelTime:c,type:"cancelScheduledValues"}),createExponentialRampToValueAutomationEvent=(c,i)=>({endTime:i,type:"exponentialRampToValue",value:c}),createLinearRampToValueAutomationEvent=(c,i)=>({endTime:i,type:"linearRampToValue",value:c}),createSetTargetAutomationEvent=(c,i,s)=>({startTime:i,target:c,timeConstant:s,type:"setTarget"}),createAbortError=()=>new DOMException("","AbortError"),createAddActiveInputConnectionToAudioNode=c=>(i,s,[a,u,l],h)=>{c(i[u],[s,a,l],f=>f[0]===s&&f[1]===a,h)},createAddAudioNodeConnections=c=>(i,s,a)=>{const u=[];for(let l=0;l<a.numberOfInputs;l+=1)u.push(new Set);c.set(i,{activeInputs:u,outputs:new Set,passiveInputs:new WeakMap,renderer:s})},createAddAudioParamConnections=c=>(i,s)=>{c.set(i,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:s})},ACTIVE_AUDIO_NODE_STORE=new WeakSet,AUDIO_NODE_CONNECTIONS_STORE=new WeakMap,AUDIO_NODE_STORE=new WeakMap,AUDIO_PARAM_CONNECTIONS_STORE=new WeakMap,AUDIO_PARAM_STORE=new WeakMap,CONTEXT_STORE=new WeakMap,EVENT_LISTENERS=new WeakMap,CYCLE_COUNTERS=new WeakMap,NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS=new WeakMap,NODE_TO_PROCESSOR_MAPS=new WeakMap,handler={construct(){return handler}},isConstructible=c=>{try{const i=new Proxy(c,handler);new i}catch{return!1}return!0},IMPORT_STATEMENT_REGEX=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,splitImportStatements=(c,i)=>{const s=[];let a=c.replace(/^[\s]+/,""),u=a.match(IMPORT_STATEMENT_REGEX);for(;u!==null;){const l=u[1].slice(1,-1),h=u[0].replace(/([\s]+)?;?$/,"").replace(l,new URL(l,i).toString());s.push(h),a=a.slice(u[0].length).replace(/^[\s]+/,""),u=a.match(IMPORT_STATEMENT_REGEX)}return[s.join(";"),a]},verifyParameterDescriptors=c=>{if(c!==void 0&&!Array.isArray(c))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},verifyProcessorCtor=c=>{if(!isConstructible(c))throw new TypeError("The given value for processorCtor should be a constructor.");if(c.prototype===null||typeof c.prototype!="object")throw new TypeError("The given value for processorCtor should have a prototype.")},createAddAudioWorkletModule=(c,i,s,a,u,l,h,f,d,p,g,m,y)=>{let v=0;return(_,A,T={credentials:"omit"})=>{const x=g.get(_);if(x!==void 0&&x.has(A))return Promise.resolve();const w=p.get(_);if(w!==void 0){const N=w.get(A);if(N!==void 0)return N}const b=l(_),C=b.audioWorklet===void 0?u(A).then(([N,S])=>{const[O,E]=splitImportStatements(N,S),R=`${O};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${E}
})})(window,'_AWGS')`;return s(R)}).then(()=>{const N=y._AWGS.pop();if(N===void 0)throw new SyntaxError;a(b.currentTime,b.sampleRate,()=>N(class{},void 0,(S,O)=>{if(S.trim()==="")throw i();const E=NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(b);if(E!==void 0){if(E.has(S))throw i();verifyProcessorCtor(O),verifyParameterDescriptors(O.parameterDescriptors),E.set(S,O)}else verifyProcessorCtor(O),verifyParameterDescriptors(O.parameterDescriptors),NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(b,new Map([[S,O]]))},b.sampleRate,void 0,void 0))}):Promise.all([u(A),Promise.resolve(c(m,m))]).then(([[N,S],O])=>{const E=v+1;v=E;const[R,I]=splitImportStatements(N,S),P=`${R};((AudioWorkletProcessor,registerProcessor)=>{${I}
})(${O?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${O?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${O?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${E}',class extends AudioWorkletProcessor{process(){return !1}})`,z=new Blob([P],{type:"application/javascript; charset=utf-8"}),W=URL.createObjectURL(z);return b.audioWorklet.addModule(W,T).then(()=>{if(f(b))return b;const G=h(b);return G.audioWorklet.addModule(W,T).then(()=>G)}).then(G=>{if(d===null)throw new SyntaxError;try{new d(G,`__sac${E}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(W))});return w===void 0?p.set(_,new Map([[A,C]])):w.set(A,C),C.then(()=>{const N=g.get(_);N===void 0?g.set(_,new Set([A])):N.add(A)}).finally(()=>{const N=p.get(_);N!==void 0&&N.delete(A)}),C}},getValueForKey=(c,i)=>{const s=c.get(i);if(s===void 0)throw new Error("A value with the given key could not be found.");return s},pickElementFromSet=(c,i)=>{const s=Array.from(c).filter(i);if(s.length>1)throw Error("More than one element was found.");if(s.length===0)throw Error("No element was found.");const[a]=s;return c.delete(a),a},deletePassiveInputConnectionToAudioNode=(c,i,s,a)=>{const u=getValueForKey(c,i),l=pickElementFromSet(u,h=>h[0]===s&&h[1]===a);return u.size===0&&c.delete(i),l},getEventListenersOfAudioNode=c=>getValueForKey(EVENT_LISTENERS,c),setInternalStateToActive=c=>{if(ACTIVE_AUDIO_NODE_STORE.has(c))throw new Error("The AudioNode is already stored.");ACTIVE_AUDIO_NODE_STORE.add(c),getEventListenersOfAudioNode(c).forEach(i=>i(!0))},isAudioWorkletNode=c=>"port"in c,setInternalStateToPassive=c=>{if(!ACTIVE_AUDIO_NODE_STORE.has(c))throw new Error("The AudioNode is not stored.");ACTIVE_AUDIO_NODE_STORE.delete(c),getEventListenersOfAudioNode(c).forEach(i=>i(!1))},setInternalStateToPassiveWhenNecessary=(c,i)=>{!isAudioWorkletNode(c)&&i.every(s=>s.size===0)&&setInternalStateToPassive(c)},createAddConnectionToAudioNode=(c,i,s,a,u,l,h,f,d,p,g,m,y)=>{const v=new WeakMap;return(_,A,T,x,w)=>{const{activeInputs:b,passiveInputs:C}=l(A),{outputs:N}=l(_),S=f(_),O=E=>{const R=d(A),I=d(_);if(E){const M=deletePassiveInputConnectionToAudioNode(C,_,T,x);c(b,_,M,!1),!w&&!m(_)&&s(I,R,T,x),y(A)&&setInternalStateToActive(A)}else{const M=a(b,_,T,x);i(C,x,M,!1),!w&&!m(_)&&u(I,R,T,x);const k=h(A);if(k===0)g(A)&&setInternalStateToPassiveWhenNecessary(A,b);else{const B=v.get(A);B!==void 0&&clearTimeout(B),v.set(A,setTimeout(()=>{g(A)&&setInternalStateToPassiveWhenNecessary(A,b)},k*1e3))}}};return p(N,[A,T,x],E=>E[0]===A&&E[1]===T&&E[2]===x,!0)?(S.add(O),g(_)?c(b,_,[T,x,O],!0):i(C,x,[_,T,O],!0),!0):!1}},createAddPassiveInputConnectionToAudioNode=c=>(i,s,[a,u,l],h)=>{const f=i.get(a);f===void 0?i.set(a,new Set([[u,s,l]])):c(f,[u,s,l],d=>d[0]===u&&d[1]===s,h)},createAddSilentConnection=c=>(i,s)=>{const a=c(i,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});s.connect(a).connect(i.destination);const u=()=>{s.removeEventListener("ended",u),s.disconnect(a),a.disconnect()};s.addEventListener("ended",u)},createAddUnrenderedAudioWorkletNode=c=>(i,s)=>{c(i).add(s)},DEFAULT_OPTIONS$j={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},createAnalyserNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=u(f),g={...DEFAULT_OPTIONS$j,...d},m=a(p,g),y=l(p)?i():null;super(f,!1,m,y),this._nativeAnalyserNode=m}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(f){this._nativeAnalyserNode.fftSize=f}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(f){const d=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=f,!(f>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=d,s()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(f){const d=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=f,!(this._nativeAnalyserNode.maxDecibels>f))throw this._nativeAnalyserNode.minDecibels=d,s()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(f){this._nativeAnalyserNode.smoothingTimeConstant=f}getByteFrequencyData(f){this._nativeAnalyserNode.getByteFrequencyData(f)}getByteTimeDomainData(f){this._nativeAnalyserNode.getByteTimeDomainData(f)}getFloatFrequencyData(f){this._nativeAnalyserNode.getFloatFrequencyData(f)}getFloatTimeDomainData(f){this._nativeAnalyserNode.getFloatTimeDomainData(f)}},isOwnedByContext=(c,i)=>c.context===i,createAnalyserNodeRendererFactory=(c,i,s)=>()=>{const a=new WeakMap,u=async(l,h)=>{let f=i(l);if(!isOwnedByContext(f,h)){const p={channelCount:f.channelCount,channelCountMode:f.channelCountMode,channelInterpretation:f.channelInterpretation,fftSize:f.fftSize,maxDecibels:f.maxDecibels,minDecibels:f.minDecibels,smoothingTimeConstant:f.smoothingTimeConstant};f=c(h,p)}return a.set(h,f),await s(l,h,f),f};return{render(l,h){const f=a.get(h);return f!==void 0?Promise.resolve(f):u(l,h)}}},testAudioBufferCopyChannelMethodsOutOfBoundsSupport=c=>{try{c.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},createIndexSizeError=()=>new DOMException("","IndexSizeError"),wrapAudioBufferGetChannelDataMethod=c=>{c.getChannelData=(i=>s=>{try{return i.call(c,s)}catch(a){throw a.code===12?createIndexSizeError():a}})(c.getChannelData)},DEFAULT_OPTIONS$i={numberOfChannels:1},createAudioBufferConstructor=(c,i,s,a,u,l,h,f)=>{let d=null;return class fe{constructor(g){if(u===null)throw new Error("Missing the native OfflineAudioContext constructor.");const{length:m,numberOfChannels:y,sampleRate:v}={...DEFAULT_OPTIONS$i,...g};d===null&&(d=new u(1,1,44100));const _=a!==null&&i(l,l)?new a({length:m,numberOfChannels:y,sampleRate:v}):d.createBuffer(y,m,v);if(_.numberOfChannels===0)throw s();return typeof _.copyFromChannel!="function"?(h(_),wrapAudioBufferGetChannelDataMethod(_)):i(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(_))||f(_),c.add(_),_}static[Symbol.hasInstance](g){return g!==null&&typeof g=="object"&&Object.getPrototypeOf(g)===fe.prototype||c.has(g)}}},MOST_NEGATIVE_SINGLE_FLOAT=-34028234663852886e22,MOST_POSITIVE_SINGLE_FLOAT=-MOST_NEGATIVE_SINGLE_FLOAT,isActiveAudioNode=c=>ACTIVE_AUDIO_NODE_STORE.has(c),DEFAULT_OPTIONS$h={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},createAudioBufferSourceNodeConstructor=(c,i,s,a,u,l,h,f)=>class extends c{constructor(p,g){const m=l(p),y={...DEFAULT_OPTIONS$h,...g},v=u(m,y),_=h(m),A=_?i():null;super(p,!1,v,A),this._audioBufferSourceNodeRenderer=A,this._isBufferNullified=!1,this._isBufferSet=y.buffer!==null,this._nativeAudioBufferSourceNode=v,this._onended=null,this._playbackRate=s(this,_,v.playbackRate,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(p){if(this._nativeAudioBufferSourceNode.buffer=p,p!==null){if(this._isBufferSet)throw a();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(p){this._nativeAudioBufferSourceNode.loop=p}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(p){this._nativeAudioBufferSourceNode.loopEnd=p}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(p){this._nativeAudioBufferSourceNode.loopStart=p}get onended(){return this._onended}set onended(p){const g=typeof p=="function"?f(this,p):null;this._nativeAudioBufferSourceNode.onended=g;const m=this._nativeAudioBufferSourceNode.onended;this._onended=m!==null&&m===g?p:m}get playbackRate(){return this._playbackRate}start(p=0,g=0,m){if(this._nativeAudioBufferSourceNode.start(p,g,m),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.start=m===void 0?[p,g]:[p,g,m]),this.context.state!=="closed"){setInternalStateToActive(this);const y=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",y),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",y)}}stop(p=0){this._nativeAudioBufferSourceNode.stop(p),this._audioBufferSourceNodeRenderer!==null&&(this._audioBufferSourceNodeRenderer.stop=p)}},createAudioBufferSourceNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap;let h=null,f=null;const d=async(p,g)=>{let m=s(p);const y=isOwnedByContext(m,g);if(!y){const v={buffer:m.buffer,channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,loop:m.loop,loopEnd:m.loopEnd,loopStart:m.loopStart,playbackRate:m.playbackRate.value};m=i(g,v),h!==null&&m.start(...h),f!==null&&m.stop(f)}return l.set(g,m),y?await c(g,p.playbackRate,m.playbackRate):await a(g,p.playbackRate,m.playbackRate),await u(p,g,m),m};return{set start(p){h=p},set stop(p){f=p},render(p,g){const m=l.get(g);return m!==void 0?Promise.resolve(m):d(p,g)}}},isAudioBufferSourceNode=c=>"playbackRate"in c,isBiquadFilterNode=c=>"frequency"in c&&"gain"in c,isConstantSourceNode=c=>"offset"in c,isGainNode=c=>!("frequency"in c)&&"gain"in c,isOscillatorNode=c=>"detune"in c&&"frequency"in c,isStereoPannerNode=c=>"pan"in c,getAudioNodeConnections=c=>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE,c),getAudioParamConnections=c=>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE,c),deactivateActiveAudioNodeInputConnections=(c,i)=>{const{activeInputs:s}=getAudioNodeConnections(c);s.forEach(u=>u.forEach(([l])=>{i.includes(c)||deactivateActiveAudioNodeInputConnections(l,[...i,c])}));const a=isAudioBufferSourceNode(c)?[c.playbackRate]:isAudioWorkletNode(c)?Array.from(c.parameters.values()):isBiquadFilterNode(c)?[c.Q,c.detune,c.frequency,c.gain]:isConstantSourceNode(c)?[c.offset]:isGainNode(c)?[c.gain]:isOscillatorNode(c)?[c.detune,c.frequency]:isStereoPannerNode(c)?[c.pan]:[];for(const u of a){const l=getAudioParamConnections(u);l!==void 0&&l.activeInputs.forEach(([h])=>deactivateActiveAudioNodeInputConnections(h,i))}isActiveAudioNode(c)&&setInternalStateToPassive(c)},deactivateAudioGraph=c=>{deactivateActiveAudioNodeInputConnections(c.destination,[])},isValidLatencyHint=c=>c===void 0||typeof c=="number"||typeof c=="string"&&(c==="balanced"||c==="interactive"||c==="playback"),createAudioContextConstructor=(c,i,s,a,u,l,h,f,d)=>class extends c{constructor(g={}){if(d===null)throw new Error("Missing the native AudioContext constructor.");let m;try{m=new d(g)}catch(_){throw _.code===12&&_.message==="sampleRate is not in range"?s():_}if(m===null)throw a();if(!isValidLatencyHint(g.latencyHint))throw new TypeError(`The provided value '${g.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(g.sampleRate!==void 0&&m.sampleRate!==g.sampleRate)throw s();super(m,2);const{latencyHint:y}=g,{sampleRate:v}=m;if(this._baseLatency=typeof m.baseLatency=="number"?m.baseLatency:y==="balanced"?512/v:y==="interactive"||y===void 0?256/v:y==="playback"?1024/v:Math.max(2,Math.min(128,Math.round(y*v/128)))*128/v,this._nativeAudioContext=m,d.name==="webkitAudioContext"?(this._nativeGainNode=m.createGain(),this._nativeOscillatorNode=m.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(m.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,m.state==="running"){this._state="suspended";const _=()=>{this._state==="suspended"&&(this._state=null),m.removeEventListener("statechange",_)};m.addEventListener("statechange",_)}}get baseLatency(){return this._baseLatency}get state(){return this._state!==null?this._state:this._nativeAudioContext.state}close(){return this.state==="closed"?this._nativeAudioContext.close().then(()=>{throw i()}):(this._state==="suspended"&&(this._state=null),this._nativeAudioContext.close().then(()=>{this._nativeGainNode!==null&&this._nativeOscillatorNode!==null&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),deactivateAudioGraph(this)}))}createMediaElementSource(g){return new u(this,{mediaElement:g})}createMediaStreamDestination(){return new l(this)}createMediaStreamSource(g){return new h(this,{mediaStream:g})}createMediaStreamTrackSource(g){return new f(this,{mediaStreamTrack:g})}resume(){return this._state==="suspended"?new Promise((g,m)=>{const y=()=>{this._nativeAudioContext.removeEventListener("statechange",y),this._nativeAudioContext.state==="running"?g():this.resume().then(g,m)};this._nativeAudioContext.addEventListener("statechange",y)}):this._nativeAudioContext.resume().catch(g=>{throw g===void 0||g.code===15?i():g})}suspend(){return this._nativeAudioContext.suspend().catch(g=>{throw g===void 0?i():g})}},createAudioDestinationNodeConstructor=(c,i,s,a,u,l,h,f)=>class extends c{constructor(p,g){const m=l(p),y=h(m),v=u(m,g,y),_=y?i(f):null;super(p,!1,v,_),this._isNodeOfNativeOfflineAudioContext=y,this._nativeAudioDestinationNode=v}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(p){if(this._isNodeOfNativeOfflineAudioContext)throw a();if(p>this._nativeAudioDestinationNode.maxChannelCount)throw s();this._nativeAudioDestinationNode.channelCount=p}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(p){if(this._isNodeOfNativeOfflineAudioContext)throw a();this._nativeAudioDestinationNode.channelCountMode=p}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}},createAudioDestinationNodeRenderer=c=>{const i=new WeakMap,s=async(a,u)=>{const l=u.destination;return i.set(u,l),await c(a,u,l),l};return{render(a,u){const l=i.get(u);return l!==void 0?Promise.resolve(l):s(a,u)}}},createAudioListenerFactory=(c,i,s,a,u,l,h,f)=>(d,p)=>{const g=p.listener,m=()=>{const N=new Float32Array(1),S=i(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),O=h(p);let E=!1,R=[0,0,-1,0,1,0],I=[0,0,0];const M=()=>{if(E)return;E=!0;const z=a(p,256,9,0);z.onaudioprocess=({inputBuffer:W})=>{const G=[l(W,N,0),l(W,N,1),l(W,N,2),l(W,N,3),l(W,N,4),l(W,N,5)];G.some((X,Z)=>X!==R[Z])&&(g.setOrientation(...G),R=G);const J=[l(W,N,6),l(W,N,7),l(W,N,8)];J.some((X,Z)=>X!==I[Z])&&(g.setPosition(...J),I=J)},S.connect(z)},k=z=>W=>{W!==R[z]&&(R[z]=W,g.setOrientation(...R))},B=z=>W=>{W!==I[z]&&(I[z]=W,g.setPosition(...I))},P=(z,W,G)=>{const J=s(p,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:W});J.connect(S,0,z),J.start(),Object.defineProperty(J.offset,"defaultValue",{get(){return W}});const X=c({context:d},O,J.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT);return f(X,"value",Z=>()=>Z.call(X),Z=>H=>{try{Z.call(X,H)}catch(te){if(te.code!==9)throw te}M(),O&&G(H)}),X.cancelAndHoldAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.cancelAndHoldAtTime),X.cancelScheduledValues=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.cancelScheduledValues),X.exponentialRampToValueAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.exponentialRampToValueAtTime),X.linearRampToValueAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.linearRampToValueAtTime),X.setTargetAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.setTargetAtTime),X.setValueAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.setValueAtTime),X.setValueCurveAtTime=(Z=>O?()=>{throw u()}:(...H)=>{const te=Z.apply(X,H);return M(),te})(X.setValueCurveAtTime),X};return{forwardX:P(0,0,k(0)),forwardY:P(1,0,k(1)),forwardZ:P(2,-1,k(2)),positionX:P(6,0,B(0)),positionY:P(7,0,B(1)),positionZ:P(8,0,B(2)),upX:P(3,0,k(3)),upY:P(4,1,k(4)),upZ:P(5,0,k(5))}},{forwardX:y,forwardY:v,forwardZ:_,positionX:A,positionY:T,positionZ:x,upX:w,upY:b,upZ:C}=g.forwardX===void 0?m():g;return{get forwardX(){return y},get forwardY(){return v},get forwardZ(){return _},get positionX(){return A},get positionY(){return T},get positionZ(){return x},get upX(){return w},get upY(){return b},get upZ(){return C}}},isAudioNode$1=c=>"context"in c,isAudioNodeOutputConnection=c=>isAudioNode$1(c[0]),insertElementInSet=(c,i,s,a)=>{for(const u of c)if(s(u)){if(a)return!1;throw Error("The set contains at least one similar element.")}return c.add(i),!0},addActiveInputConnectionToAudioParam=(c,i,[s,a],u)=>{insertElementInSet(c,[i,s,a],l=>l[0]===i&&l[1]===s,u)},addPassiveInputConnectionToAudioParam=(c,[i,s,a],u)=>{const l=c.get(i);l===void 0?c.set(i,new Set([[s,a]])):insertElementInSet(l,[s,a],h=>h[0]===s,u)},isNativeAudioNodeFaker=c=>"inputs"in c,connectNativeAudioNodeToNativeAudioNode=(c,i,s,a)=>{if(isNativeAudioNodeFaker(i)){const u=i.inputs[a];return c.connect(u,s,0),[u,s,0]}return c.connect(i,s,a),[i,s,a]},deleteActiveInputConnection=(c,i,s)=>{for(const a of c)if(a[0]===i&&a[1]===s)return c.delete(a),a;return null},deleteActiveInputConnectionToAudioParam=(c,i,s)=>pickElementFromSet(c,a=>a[0]===i&&a[1]===s),deleteEventListenerOfAudioNode=(c,i)=>{if(!getEventListenersOfAudioNode(c).delete(i))throw new Error("Missing the expected event listener.")},deletePassiveInputConnectionToAudioParam=(c,i,s)=>{const a=getValueForKey(c,i),u=pickElementFromSet(a,l=>l[0]===s);return a.size===0&&c.delete(i),u},disconnectNativeAudioNodeFromNativeAudioNode=(c,i,s,a)=>{isNativeAudioNodeFaker(i)?c.disconnect(i.inputs[a],s,0):c.disconnect(i,s,a)},getNativeAudioNode=c=>getValueForKey(AUDIO_NODE_STORE,c),getNativeAudioParam=c=>getValueForKey(AUDIO_PARAM_STORE,c),isPartOfACycle=c=>CYCLE_COUNTERS.has(c),isPassiveAudioNode=c=>!ACTIVE_AUDIO_NODE_STORE.has(c),testAudioNodeDisconnectMethodSupport=(c,i)=>new Promise(s=>{if(i!==null)s(!0);else{const a=c.createScriptProcessor(256,1,1),u=c.createGain(),l=c.createBuffer(1,2,44100),h=l.getChannelData(0);h[0]=1,h[1]=1;const f=c.createBufferSource();f.buffer=l,f.loop=!0,f.connect(a).connect(c.destination),f.connect(u),f.disconnect(u),a.onaudioprocess=d=>{const p=d.inputBuffer.getChannelData(0);Array.prototype.some.call(p,g=>g===1)?s(!0):s(!1),f.stop(),a.onaudioprocess=null,f.disconnect(a),a.disconnect(c.destination)},f.start()}}),visitEachAudioNodeOnce=(c,i)=>{const s=new Map;for(const a of c)for(const u of a){const l=s.get(u);s.set(u,l===void 0?1:l+1)}s.forEach((a,u)=>i(u,a))},isNativeAudioNode$1=c=>"context"in c,wrapAudioNodeDisconnectMethod=c=>{const i=new Map;c.connect=(s=>(a,u=0,l=0)=>{const h=isNativeAudioNode$1(a)?s(a,u,l):s(a,u),f=i.get(a);return f===void 0?i.set(a,[{input:l,output:u}]):f.every(d=>d.input!==l||d.output!==u)&&f.push({input:l,output:u}),h})(c.connect.bind(c)),c.disconnect=(s=>(a,u,l)=>{if(s.apply(c),a===void 0)i.clear();else if(typeof a=="number")for(const[h,f]of i){const d=f.filter(p=>p.output!==a);d.length===0?i.delete(h):i.set(h,d)}else if(i.has(a))if(u===void 0)i.delete(a);else{const h=i.get(a);if(h!==void 0){const f=h.filter(d=>d.output!==u&&(d.input!==l||l===void 0));f.length===0?i.delete(a):i.set(a,f)}}for(const[h,f]of i)f.forEach(d=>{isNativeAudioNode$1(h)?c.connect(h,d.output,d.input):c.connect(h,d.output)})})(c.disconnect)},addConnectionToAudioParamOfAudioContext=(c,i,s,a)=>{const{activeInputs:u,passiveInputs:l}=getAudioParamConnections(i),{outputs:h}=getAudioNodeConnections(c),f=getEventListenersOfAudioNode(c),d=p=>{const g=getNativeAudioNode(c),m=getNativeAudioParam(i);if(p){const y=deletePassiveInputConnectionToAudioParam(l,c,s);addActiveInputConnectionToAudioParam(u,c,y,!1),!a&&!isPartOfACycle(c)&&g.connect(m,s)}else{const y=deleteActiveInputConnectionToAudioParam(u,c,s);addPassiveInputConnectionToAudioParam(l,y,!1),!a&&!isPartOfACycle(c)&&g.disconnect(m,s)}};return insertElementInSet(h,[i,s],p=>p[0]===i&&p[1]===s,!0)?(f.add(d),isActiveAudioNode(c)?addActiveInputConnectionToAudioParam(u,c,[s,d],!0):addPassiveInputConnectionToAudioParam(l,[c,s,d],!0),!0):!1},deleteInputConnectionOfAudioNode=(c,i,s,a)=>{const{activeInputs:u,passiveInputs:l}=getAudioNodeConnections(i),h=deleteActiveInputConnection(u[a],c,s);return h===null?[deletePassiveInputConnectionToAudioNode(l,c,s,a)[2],!1]:[h[2],!0]},deleteInputConnectionOfAudioParam=(c,i,s)=>{const{activeInputs:a,passiveInputs:u}=getAudioParamConnections(i),l=deleteActiveInputConnection(a,c,s);return l===null?[deletePassiveInputConnectionToAudioParam(u,c,s)[1],!1]:[l[2],!0]},deleteInputsOfAudioNode=(c,i,s,a,u)=>{const[l,h]=deleteInputConnectionOfAudioNode(c,s,a,u);if(l!==null&&(deleteEventListenerOfAudioNode(c,l),h&&!i&&!isPartOfACycle(c)&&disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(c),getNativeAudioNode(s),a,u)),isActiveAudioNode(s)){const{activeInputs:f}=getAudioNodeConnections(s);setInternalStateToPassiveWhenNecessary(s,f)}},deleteInputsOfAudioParam=(c,i,s,a)=>{const[u,l]=deleteInputConnectionOfAudioParam(c,s,a);u!==null&&(deleteEventListenerOfAudioNode(c,u),l&&!i&&!isPartOfACycle(c)&&getNativeAudioNode(c).disconnect(getNativeAudioParam(s),a))},deleteAnyConnection=(c,i)=>{const s=getAudioNodeConnections(c),a=[];for(const u of s.outputs)isAudioNodeOutputConnection(u)?deleteInputsOfAudioNode(c,i,...u):deleteInputsOfAudioParam(c,i,...u),a.push(u[0]);return s.outputs.clear(),a},deleteConnectionAtOutput=(c,i,s)=>{const a=getAudioNodeConnections(c),u=[];for(const l of a.outputs)l[1]===s&&(isAudioNodeOutputConnection(l)?deleteInputsOfAudioNode(c,i,...l):deleteInputsOfAudioParam(c,i,...l),u.push(l[0]),a.outputs.delete(l));return u},deleteConnectionToDestination=(c,i,s,a,u)=>{const l=getAudioNodeConnections(c);return Array.from(l.outputs).filter(h=>h[0]===s&&(a===void 0||h[1]===a)&&(u===void 0||h[2]===u)).map(h=>(isAudioNodeOutputConnection(h)?deleteInputsOfAudioNode(c,i,...h):deleteInputsOfAudioParam(c,i,...h),l.outputs.delete(h),h[0]))},createAudioNodeConstructor=(c,i,s,a,u,l,h,f,d,p,g,m,y,v,_,A)=>class extends p{constructor(x,w,b,C){super(b),this._context=x,this._nativeAudioNode=b;const N=g(x);m(N)&&s(testAudioNodeDisconnectMethodSupport,()=>testAudioNodeDisconnectMethodSupport(N,A))!==!0&&wrapAudioNodeDisconnectMethod(b),AUDIO_NODE_STORE.set(this,b),EVENT_LISTENERS.set(this,new Set),x.state!=="closed"&&w&&setInternalStateToActive(this),c(this,C,b)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(x){this._nativeAudioNode.channelCount=x}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(x){this._nativeAudioNode.channelCountMode=x}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(x){this._nativeAudioNode.channelInterpretation=x}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(x,w=0,b=0){if(w<0||w>=this._nativeAudioNode.numberOfOutputs)throw u();const C=g(this._context),N=_(C);if(y(x)||v(x))throw l();if(isAudioNode$1(x)){const E=getNativeAudioNode(x);try{const I=connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode,E,w,b),M=isPassiveAudioNode(this);(N||M)&&this._nativeAudioNode.disconnect(...I),this.context.state!=="closed"&&!M&&isPassiveAudioNode(x)&&setInternalStateToActive(x)}catch(I){throw I.code===12?l():I}if(i(this,x,w,b,N)){const I=d([this],x);visitEachAudioNodeOnce(I,a(N))}return x}const S=getNativeAudioParam(x);if(S.name==="playbackRate"&&S.maxValue===1024)throw h();try{this._nativeAudioNode.connect(S,w),(N||isPassiveAudioNode(this))&&this._nativeAudioNode.disconnect(S,w)}catch(E){throw E.code===12?l():E}if(addConnectionToAudioParamOfAudioContext(this,x,w,N)){const E=d([this],x);visitEachAudioNodeOnce(E,a(N))}}disconnect(x,w,b){let C;const N=g(this._context),S=_(N);if(x===void 0)C=deleteAnyConnection(this,S);else if(typeof x=="number"){if(x<0||x>=this.numberOfOutputs)throw u();C=deleteConnectionAtOutput(this,S,x)}else{if(w!==void 0&&(w<0||w>=this.numberOfOutputs)||isAudioNode$1(x)&&b!==void 0&&(b<0||b>=x.numberOfInputs))throw u();if(C=deleteConnectionToDestination(this,S,x,w,b),C.length===0)throw l()}for(const O of C){const E=d([this],O);visitEachAudioNodeOnce(E,f)}}},createAudioParamFactory=(c,i,s,a,u,l,h,f,d,p,g,m,y)=>(v,_,A,T=null,x=null)=>{const w=new AutomationEventList(A.defaultValue),b=_?a(w):null,C={get defaultValue(){return A.defaultValue},get maxValue(){return T===null?A.maxValue:T},get minValue(){return x===null?A.minValue:x},get value(){return A.value},set value(N){A.value=N,C.setValueAtTime(N,v.context.currentTime)},cancelAndHoldAtTime(N){if(typeof A.cancelAndHoldAtTime=="function")b===null&&w.flush(v.context.currentTime),w.add(u(N)),A.cancelAndHoldAtTime(N);else{const S=Array.from(w).pop();b===null&&w.flush(v.context.currentTime),w.add(u(N));const O=Array.from(w).pop();A.cancelScheduledValues(N),S!==O&&O!==void 0&&(O.type==="exponentialRampToValue"?A.exponentialRampToValueAtTime(O.value,O.endTime):O.type==="linearRampToValue"?A.linearRampToValueAtTime(O.value,O.endTime):O.type==="setValue"?A.setValueAtTime(O.value,O.startTime):O.type==="setValueCurve"&&A.setValueCurveAtTime(O.values,O.startTime,O.duration))}return C},cancelScheduledValues(N){return b===null&&w.flush(v.context.currentTime),w.add(l(N)),A.cancelScheduledValues(N),C},exponentialRampToValueAtTime(N,S){if(N===0)throw new RangeError;if(!Number.isFinite(S)||S<0)throw new RangeError;return b===null&&w.flush(v.context.currentTime),w.add(h(N,S)),A.exponentialRampToValueAtTime(N,S),C},linearRampToValueAtTime(N,S){return b===null&&w.flush(v.context.currentTime),w.add(f(N,S)),A.linearRampToValueAtTime(N,S),C},setTargetAtTime(N,S,O){return b===null&&w.flush(v.context.currentTime),w.add(d(N,S,O)),A.setTargetAtTime(N,S,O),C},setValueAtTime(N,S){return b===null&&w.flush(v.context.currentTime),w.add(p(N,S)),A.setValueAtTime(N,S),C},setValueCurveAtTime(N,S,O){const E=N instanceof Float32Array?N:new Float32Array(N);if(m!==null&&m.name==="webkitAudioContext"){const R=S+O,I=v.context.sampleRate,M=Math.ceil(S*I),k=Math.floor(R*I),B=k-M,P=new Float32Array(B);for(let W=0;W<B;W+=1){const G=(E.length-1)/O*((M+W)/I-S),J=Math.floor(G),X=Math.ceil(G);P[W]=J===X?E[J]:(1-(G-J))*E[J]+(1-(X-G))*E[X]}b===null&&w.flush(v.context.currentTime),w.add(g(P,S,O)),A.setValueCurveAtTime(P,S,O);const z=k/I;z<R&&y(C,P[P.length-1],z),y(C,E[E.length-1],R)}else b===null&&w.flush(v.context.currentTime),w.add(g(E,S,O)),A.setValueCurveAtTime(E,S,O);return C}};return s.set(C,A),i.set(C,v),c(C,b),C},createAudioParamRenderer=c=>({replay(i){for(const s of c)if(s.type==="exponentialRampToValue"){const{endTime:a,value:u}=s;i.exponentialRampToValueAtTime(u,a)}else if(s.type==="linearRampToValue"){const{endTime:a,value:u}=s;i.linearRampToValueAtTime(u,a)}else if(s.type==="setTarget"){const{startTime:a,target:u,timeConstant:l}=s;i.setTargetAtTime(u,a,l)}else if(s.type==="setValue"){const{startTime:a,value:u}=s;i.setValueAtTime(u,a)}else if(s.type==="setValueCurve"){const{duration:a,startTime:u,values:l}=s;i.setValueCurveAtTime(l,u,a)}else throw new Error("Can't apply an unknown automation.")}});class ReadOnlyMap{constructor(i){this._map=new Map(i)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(i,s=null){return this._map.forEach((a,u)=>i.call(s,a,u,this))}get(i){return this._map.get(i)}has(i){return this._map.has(i)}keys(){return this._map.keys()}values(){return this._map.values()}}const DEFAULT_OPTIONS$g={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}},createAudioWorkletNodeConstructor=(c,i,s,a,u,l,h,f,d,p,g,m,y,v)=>class extends i{constructor(A,T,x){var w;const b=f(A),C=d(b),N=g({...DEFAULT_OPTIONS$g,...x});y(N);const S=NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(b),O=S==null?void 0:S.get(T),E=C||b.state!=="closed"?b:(w=h(b))!==null&&w!==void 0?w:b,R=u(E,C?null:A.baseLatency,p,T,O,N),I=C?a(T,N,O):null;super(A,!0,R,I);const M=[];R.parameters.forEach((B,P)=>{const z=s(this,C,B);M.push([P,z])}),this._nativeAudioWorkletNode=R,this._onprocessorerror=null,this._parameters=new ReadOnlyMap(M),C&&c(b,this);const{activeInputs:k}=l(this);m(R,k)}get onprocessorerror(){return this._onprocessorerror}set onprocessorerror(A){const T=typeof A=="function"?v(this,A):null;this._nativeAudioWorkletNode.onprocessorerror=T;const x=this._nativeAudioWorkletNode.onprocessorerror;this._onprocessorerror=x!==null&&x===T?A:x}get parameters(){return this._parameters===null?this._nativeAudioWorkletNode.parameters:this._parameters}get port(){return this._nativeAudioWorkletNode.port}};function copyFromChannel(c,i,s,a,u){if(typeof c.copyFromChannel=="function")i[s].byteLength===0&&(i[s]=new Float32Array(128)),c.copyFromChannel(i[s],a,u);else{const l=c.getChannelData(a);if(i[s].byteLength===0)i[s]=l.slice(u,u+128);else{const h=new Float32Array(l.buffer,u*Float32Array.BYTES_PER_ELEMENT,128);i[s].set(h)}}}const copyToChannel=(c,i,s,a,u)=>{typeof c.copyToChannel=="function"?i[s].byteLength!==0&&c.copyToChannel(i[s],a,u):i[s].byteLength!==0&&c.getChannelData(a).set(i[s],u)},createNestedArrays=(c,i)=>{const s=[];for(let a=0;a<c;a+=1){const u=[],l=typeof i=="number"?i:i[a];for(let h=0;h<l;h+=1)u.push(new Float32Array(128));s.push(u)}return s},getAudioWorkletProcessor=(c,i)=>{const s=getValueForKey(NODE_TO_PROCESSOR_MAPS,c),a=getNativeAudioNode(i);return getValueForKey(s,a)},processBuffer=async(c,i,s,a,u,l,h)=>{const f=i===null?Math.ceil(c.context.length/128)*128:i.length,d=a.channelCount*a.numberOfInputs,p=u.reduce((T,x)=>T+x,0),g=p===0?null:s.createBuffer(p,f,s.sampleRate);if(l===void 0)throw new Error("Missing the processor constructor.");const m=getAudioNodeConnections(c),y=await getAudioWorkletProcessor(s,c),v=createNestedArrays(a.numberOfInputs,a.channelCount),_=createNestedArrays(a.numberOfOutputs,u),A=Array.from(c.parameters.keys()).reduce((T,x)=>({...T,[x]:new Float32Array(128)}),{});for(let T=0;T<f;T+=128){if(a.numberOfInputs>0&&i!==null)for(let x=0;x<a.numberOfInputs;x+=1)for(let w=0;w<a.channelCount;w+=1)copyFromChannel(i,v[x],w,w,T);l.parameterDescriptors!==void 0&&i!==null&&l.parameterDescriptors.forEach(({name:x},w)=>{copyFromChannel(i,A,x,d+w,T)});for(let x=0;x<a.numberOfInputs;x+=1)for(let w=0;w<u[x];w+=1)_[x][w].byteLength===0&&(_[x][w]=new Float32Array(128));try{const x=v.map((b,C)=>m.activeInputs[C].size===0?[]:b),w=h(T/s.sampleRate,s.sampleRate,()=>y.process(x,_,A));if(g!==null)for(let b=0,C=0;b<a.numberOfOutputs;b+=1){for(let N=0;N<u[b];N+=1)copyToChannel(g,_[b],N,C+N,T);C+=u[b]}if(!w)break}catch(x){c.dispatchEvent(new ErrorEvent("processorerror",{colno:x.colno,filename:x.filename,lineno:x.lineno,message:x.message}));break}}return g},createAudioWorkletNodeRendererFactory=(c,i,s,a,u,l,h,f,d,p,g,m,y,v,_,A)=>(T,x,w)=>{const b=new WeakMap;let C=null;const N=async(S,O)=>{let E=g(S),R=null;const I=isOwnedByContext(E,O),M=Array.isArray(x.outputChannelCount)?x.outputChannelCount:Array.from(x.outputChannelCount);if(m===null){const k=M.reduce((W,G)=>W+G,0),B=u(O,{channelCount:Math.max(1,k),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,k)}),P=[];for(let W=0;W<S.numberOfOutputs;W+=1)P.push(a(O,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:M[W]}));const z=h(O,{channelCount:x.channelCount,channelCountMode:x.channelCountMode,channelInterpretation:x.channelInterpretation,gain:1});z.connect=i.bind(null,P),z.disconnect=d.bind(null,P),R=[B,P,z]}else I||(E=new m(O,T));if(b.set(O,R===null?E:R[2]),R!==null){if(C===null){if(w===void 0)throw new Error("Missing the processor constructor.");if(y===null)throw new Error("Missing the native OfflineAudioContext constructor.");const G=S.channelCount*S.numberOfInputs,J=w.parameterDescriptors===void 0?0:w.parameterDescriptors.length,X=G+J;C=processBuffer(S,X===0?null:await(async()=>{const H=new y(X,Math.ceil(S.context.length/128)*128,O.sampleRate),te=[],ce=[];for(let ie=0;ie<x.numberOfInputs;ie+=1)te.push(h(H,{channelCount:x.channelCount,channelCountMode:x.channelCountMode,channelInterpretation:x.channelInterpretation,gain:1})),ce.push(u(H,{channelCount:x.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:x.channelCount}));const oe=await Promise.all(Array.from(S.parameters.values()).map(async ie=>{const ae=l(H,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:ie.value});return await v(H,ie,ae.offset),ae})),K=a(H,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,G+J)});for(let ie=0;ie<x.numberOfInputs;ie+=1){te[ie].connect(ce[ie]);for(let ae=0;ae<x.channelCount;ae+=1)ce[ie].connect(K,ae,ie*x.channelCount+ae)}for(const[ie,ae]of oe.entries())ae.connect(K,0,G+ie),ae.start(0);return K.connect(H.destination),await Promise.all(te.map(ie=>_(S,H,ie))),A(H)})(),O,x,M,w,p)}const k=await C,B=s(O,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[P,z,W]=R;k!==null&&(B.buffer=k,B.start(0)),B.connect(P);for(let G=0,J=0;G<S.numberOfOutputs;G+=1){const X=z[G];for(let Z=0;Z<M[G];Z+=1)P.connect(X,J+Z,Z);J+=M[G]}return W}if(I)for(const[k,B]of S.parameters.entries())await c(O,B,E.parameters.get(k));else for(const[k,B]of S.parameters.entries())await v(O,B,E.parameters.get(k));return await _(S,O,E),E};return{render(S,O){f(O,S);const E=b.get(O);return E!==void 0?Promise.resolve(E):N(S,O)}}},createBaseAudioContextConstructor=(c,i,s,a,u,l,h,f,d,p,g,m,y,v,_,A,T,x,w,b)=>class extends _{constructor(N,S){super(N,S),this._nativeContext=N,this._audioWorklet=c===void 0?void 0:{addModule:(O,E)=>c(this,O,E)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new i(this)}createBiquadFilter(){return new u(this)}createBuffer(N,S,O){return new s({length:S,numberOfChannels:N,sampleRate:O})}createBufferSource(){return new a(this)}createChannelMerger(N=6){return new l(this,{numberOfInputs:N})}createChannelSplitter(N=6){return new h(this,{numberOfOutputs:N})}createConstantSource(){return new f(this)}createConvolver(){return new d(this)}createDelay(N=1){return new g(this,{maxDelayTime:N})}createDynamicsCompressor(){return new m(this)}createGain(){return new y(this)}createIIRFilter(N,S){return new v(this,{feedback:S,feedforward:N})}createOscillator(){return new A(this)}createPanner(){return new T(this)}createPeriodicWave(N,S,O={disableNormalization:!1}){return new x(this,{...O,imag:S,real:N})}createStereoPanner(){return new w(this)}createWaveShaper(){return new b(this)}decodeAudioData(N,S,O){return p(this._nativeContext,N).then(E=>(typeof S=="function"&&S(E),E),E=>{throw typeof O=="function"&&O(E),E})}},DEFAULT_OPTIONS$f={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},createBiquadFilterNodeConstructor=(c,i,s,a,u,l,h,f)=>class extends c{constructor(p,g){const m=l(p),y={...DEFAULT_OPTIONS$f,...g},v=u(m,y),_=h(m),A=_?s():null;super(p,!1,v,A),this._Q=i(this,_,v.Q,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._detune=i(this,_,v.detune,1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT),-1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT)),this._frequency=i(this,_,v.frequency,p.sampleRate/2,0),this._gain=i(this,_,v.gain,40*Math.log10(MOST_POSITIVE_SINGLE_FLOAT),MOST_NEGATIVE_SINGLE_FLOAT),this._nativeBiquadFilterNode=v,f(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(p){this._nativeBiquadFilterNode.type=p}getFrequencyResponse(p,g,m){try{this._nativeBiquadFilterNode.getFrequencyResponse(p,g,m)}catch(y){throw y.code===11?a():y}if(p.length!==g.length||g.length!==m.length)throw a()}},createBiquadFilterNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap,h=async(f,d)=>{let p=s(f);const g=isOwnedByContext(p,d);if(!g){const m={Q:p.Q.value,channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,detune:p.detune.value,frequency:p.frequency.value,gain:p.gain.value,type:p.type};p=i(d,m)}return l.set(d,p),g?(await c(d,f.Q,p.Q),await c(d,f.detune,p.detune),await c(d,f.frequency,p.frequency),await c(d,f.gain,p.gain)):(await a(d,f.Q,p.Q),await a(d,f.detune,p.detune),await a(d,f.frequency,p.frequency),await a(d,f.gain,p.gain)),await u(f,d,p),p};return{render(f,d){const p=l.get(d);return p!==void 0?Promise.resolve(p):h(f,d)}}},createCacheTestResult=(c,i)=>(s,a)=>{const u=i.get(s);if(u!==void 0)return u;const l=c.get(s);if(l!==void 0)return l;try{const h=a();return h instanceof Promise?(c.set(s,h),h.catch(()=>!1).then(f=>(c.delete(s),i.set(s,f),f))):(i.set(s,h),h)}catch{return i.set(s,!1),!1}},DEFAULT_OPTIONS$e={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},createChannelMergerNodeConstructor=(c,i,s,a,u)=>class extends c{constructor(h,f){const d=a(h),p={...DEFAULT_OPTIONS$e,...f},g=s(d,p),m=u(d)?i():null;super(h,!1,g,m)}},createChannelMergerNodeRendererFactory=(c,i,s)=>()=>{const a=new WeakMap,u=async(l,h)=>{let f=i(l);if(!isOwnedByContext(f,h)){const p={channelCount:f.channelCount,channelCountMode:f.channelCountMode,channelInterpretation:f.channelInterpretation,numberOfInputs:f.numberOfInputs};f=c(h,p)}return a.set(h,f),await s(l,h,f),f};return{render(l,h){const f=a.get(h);return f!==void 0?Promise.resolve(f):u(l,h)}}},DEFAULT_OPTIONS$d={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},createChannelSplitterNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=a(f),g=l({...DEFAULT_OPTIONS$d,...d}),m=s(p,g),y=u(p)?i():null;super(f,!1,m,y)}},createChannelSplitterNodeRendererFactory=(c,i,s)=>()=>{const a=new WeakMap,u=async(l,h)=>{let f=i(l);if(!isOwnedByContext(f,h)){const p={channelCount:f.channelCount,channelCountMode:f.channelCountMode,channelInterpretation:f.channelInterpretation,numberOfOutputs:f.numberOfOutputs};f=c(h,p)}return a.set(h,f),await s(l,h,f),f};return{render(l,h){const f=a.get(h);return f!==void 0?Promise.resolve(f):u(l,h)}}},createConnectAudioParam=c=>(i,s,a)=>c(s,i,a),createConnectMultipleOutputs=c=>(i,s,a=0,u=0)=>{const l=i[a];if(l===void 0)throw c();return isNativeAudioNode$1(s)?l.connect(s,0,u):l.connect(s,0)},createConnectedNativeAudioBufferSourceNodeFactory=c=>(i,s)=>{const a=c(i,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),u=i.createBuffer(1,2,44100);return a.buffer=u,a.loop=!0,a.connect(s),a.start(),()=>{a.stop(),a.disconnect(s)}},DEFAULT_OPTIONS$c={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},createConstantSourceNodeConstructor=(c,i,s,a,u,l,h)=>class extends c{constructor(d,p){const g=u(d),m={...DEFAULT_OPTIONS$c,...p},y=a(g,m),v=l(g),_=v?s():null;super(d,!1,y,_),this._constantSourceNodeRenderer=_,this._nativeConstantSourceNode=y,this._offset=i(this,v,y.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(d){const p=typeof d=="function"?h(this,d):null;this._nativeConstantSourceNode.onended=p;const g=this._nativeConstantSourceNode.onended;this._onended=g!==null&&g===p?d:g}start(d=0){if(this._nativeConstantSourceNode.start(d),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.start=d),this.context.state!=="closed"){setInternalStateToActive(this);const p=()=>{this._nativeConstantSourceNode.removeEventListener("ended",p),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeConstantSourceNode.addEventListener("ended",p)}}stop(d=0){this._nativeConstantSourceNode.stop(d),this._constantSourceNodeRenderer!==null&&(this._constantSourceNodeRenderer.stop=d)}},createConstantSourceNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap;let h=null,f=null;const d=async(p,g)=>{let m=s(p);const y=isOwnedByContext(m,g);if(!y){const v={channelCount:m.channelCount,channelCountMode:m.channelCountMode,channelInterpretation:m.channelInterpretation,offset:m.offset.value};m=i(g,v),h!==null&&m.start(h),f!==null&&m.stop(f)}return l.set(g,m),y?await c(g,p.offset,m.offset):await a(g,p.offset,m.offset),await u(p,g,m),m};return{set start(p){h=p},set stop(p){f=p},render(p,g){const m=l.get(g);return m!==void 0?Promise.resolve(m):d(p,g)}}},createConvertNumberToUnsignedLong=c=>i=>(c[0]=i,c[0]),DEFAULT_OPTIONS$b={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},createConvolverNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=a(f),g={...DEFAULT_OPTIONS$b,...d},m=s(p,g),v=u(p)?i():null;super(f,!1,m,v),this._isBufferNullified=!1,this._nativeConvolverNode=m,g.buffer!==null&&l(this,g.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(f){if(this._nativeConvolverNode.buffer=f,f===null&&this._nativeConvolverNode.buffer!==null){const d=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=d.createBuffer(1,1,d.sampleRate),this._isBufferNullified=!0,l(this,0)}else this._isBufferNullified=!1,l(this,this._nativeConvolverNode.buffer===null?0:this._nativeConvolverNode.buffer.duration)}get normalize(){return this._nativeConvolverNode.normalize}set normalize(f){this._nativeConvolverNode.normalize=f}},createConvolverNodeRendererFactory=(c,i,s)=>()=>{const a=new WeakMap,u=async(l,h)=>{let f=i(l);if(!isOwnedByContext(f,h)){const p={buffer:f.buffer,channelCount:f.channelCount,channelCountMode:f.channelCountMode,channelInterpretation:f.channelInterpretation,disableNormalization:!f.normalize};f=c(h,p)}return a.set(h,f),isNativeAudioNodeFaker(f)?await s(l,h,f.inputs[0]):await s(l,h,f),f};return{render(l,h){const f=a.get(h);return f!==void 0?Promise.resolve(f):u(l,h)}}},createCreateNativeOfflineAudioContext=(c,i)=>(s,a,u)=>{if(i===null)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new i(s,a,u)}catch(l){throw l.name==="SyntaxError"?c():l}},createDataCloneError=()=>new DOMException("","DataCloneError"),detachArrayBuffer=c=>{const{port1:i,port2:s}=new MessageChannel;return new Promise(a=>{const u=()=>{s.onmessage=null,i.close(),s.close(),a()};s.onmessage=()=>u();try{i.postMessage(c,[c])}finally{u()}})},createDecodeAudioData=(c,i,s,a,u,l,h,f,d,p,g)=>(m,y)=>{const v=h(m)?m:l(m);if(u.has(y)){const _=s();return Promise.reject(_)}try{u.add(y)}catch{}return i(d,()=>d(v))?v.decodeAudioData(y).then(_=>(detachArrayBuffer(y).catch(()=>{}),i(f,()=>f(_))||g(_),c.add(_),_)):new Promise((_,A)=>{const T=async()=>{try{await detachArrayBuffer(y)}catch{}},x=w=>{A(w),T()};try{v.decodeAudioData(y,w=>{typeof w.copyFromChannel!="function"&&(p(w),wrapAudioBufferGetChannelDataMethod(w)),c.add(w),T().then(()=>_(w))},w=>{x(w===null?a():w)})}catch(w){x(w)}})},createDecrementCycleCounter=(c,i,s,a,u,l,h,f)=>(d,p)=>{const g=i.get(d);if(g===void 0)throw new Error("Missing the expected cycle count.");const m=l(d.context),y=f(m);if(g===p){if(i.delete(d),!y&&h(d)){const v=a(d),{outputs:_}=s(d);for(const A of _)if(isAudioNodeOutputConnection(A)){const T=a(A[0]);c(v,T,A[1],A[2])}else{const T=u(A[0]);v.connect(T,A[1])}}}else i.set(d,g-p)},DEFAULT_OPTIONS$a={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},createDelayNodeConstructor=(c,i,s,a,u,l,h)=>class extends c{constructor(d,p){const g=u(d),m={...DEFAULT_OPTIONS$a,...p},y=a(g,m),v=l(g),_=v?s(m.maxDelayTime):null;super(d,!1,y,_),this._delayTime=i(this,v,y.delayTime),h(this,m.maxDelayTime)}get delayTime(){return this._delayTime}},createDelayNodeRendererFactory=(c,i,s,a,u)=>l=>{const h=new WeakMap,f=async(d,p)=>{let g=s(d);const m=isOwnedByContext(g,p);if(!m){const y={channelCount:g.channelCount,channelCountMode:g.channelCountMode,channelInterpretation:g.channelInterpretation,delayTime:g.delayTime.value,maxDelayTime:l};g=i(p,y)}return h.set(p,g),m?await c(p,d.delayTime,g.delayTime):await a(p,d.delayTime,g.delayTime),await u(d,p,g),g};return{render(d,p){const g=h.get(p);return g!==void 0?Promise.resolve(g):f(d,p)}}},createDeleteActiveInputConnectionToAudioNode=c=>(i,s,a,u)=>c(i[u],l=>l[0]===s&&l[1]===a),createDeleteUnrenderedAudioWorkletNode=c=>(i,s)=>{c(i).delete(s)},isDelayNode=c=>"delayTime"in c,createDetectCycles=(c,i,s)=>function a(u,l){const h=isAudioNode$1(l)?l:s(c,l);if(isDelayNode(h))return[];if(u[0]===h)return[u];if(u.includes(h))return[];const{outputs:f}=i(h);return Array.from(f).map(d=>a([...u,h],d[0])).reduce((d,p)=>d.concat(p),[])},getOutputAudioNodeAtIndex=(c,i,s)=>{const a=i[s];if(a===void 0)throw c();return a},createDisconnectMultipleOutputs=c=>(i,s=void 0,a=void 0,u=0)=>s===void 0?i.forEach(l=>l.disconnect()):typeof s=="number"?getOutputAudioNodeAtIndex(c,i,s).disconnect():isNativeAudioNode$1(s)?a===void 0?i.forEach(l=>l.disconnect(s)):u===void 0?getOutputAudioNodeAtIndex(c,i,a).disconnect(s,0):getOutputAudioNodeAtIndex(c,i,a).disconnect(s,0,u):a===void 0?i.forEach(l=>l.disconnect(s)):getOutputAudioNodeAtIndex(c,i,a).disconnect(s,0),DEFAULT_OPTIONS$9={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},createDynamicsCompressorNodeConstructor=(c,i,s,a,u,l,h,f)=>class extends c{constructor(p,g){const m=l(p),y={...DEFAULT_OPTIONS$9,...g},v=a(m,y),_=h(m),A=_?s():null;super(p,!1,v,A),this._attack=i(this,_,v.attack),this._knee=i(this,_,v.knee),this._nativeDynamicsCompressorNode=v,this._ratio=i(this,_,v.ratio),this._release=i(this,_,v.release),this._threshold=i(this,_,v.threshold),f(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(p){const g=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=p,p>2)throw this._nativeDynamicsCompressorNode.channelCount=g,u()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(p){const g=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=p,p==="max")throw this._nativeDynamicsCompressorNode.channelCountMode=g,u()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return typeof this._nativeDynamicsCompressorNode.reduction.value=="number"?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}},createDynamicsCompressorNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap,h=async(f,d)=>{let p=s(f);const g=isOwnedByContext(p,d);if(!g){const m={attack:p.attack.value,channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,knee:p.knee.value,ratio:p.ratio.value,release:p.release.value,threshold:p.threshold.value};p=i(d,m)}return l.set(d,p),g?(await c(d,f.attack,p.attack),await c(d,f.knee,p.knee),await c(d,f.ratio,p.ratio),await c(d,f.release,p.release),await c(d,f.threshold,p.threshold)):(await a(d,f.attack,p.attack),await a(d,f.knee,p.knee),await a(d,f.ratio,p.ratio),await a(d,f.release,p.release),await a(d,f.threshold,p.threshold)),await u(f,d,p),p};return{render(f,d){const p=l.get(d);return p!==void 0?Promise.resolve(p):h(f,d)}}},createEncodingError=()=>new DOMException("","EncodingError"),createEvaluateSource=c=>i=>new Promise((s,a)=>{if(c===null){a(new SyntaxError);return}const u=c.document.head;if(u===null)a(new SyntaxError);else{const l=c.document.createElement("script"),h=new Blob([i],{type:"application/javascript"}),f=URL.createObjectURL(h),d=c.onerror,p=()=>{c.onerror=d,URL.revokeObjectURL(f)};c.onerror=(g,m,y,v,_)=>{if(m===f||m===c.location.href&&y===1&&v===1)return p(),a(_),!1;if(d!==null)return d(g,m,y,v,_)},l.onerror=()=>{p(),a(new SyntaxError)},l.onload=()=>{p(),s()},l.src=f,l.type="module",u.appendChild(l)}}),createEventTargetConstructor=c=>class{constructor(s){this._nativeEventTarget=s,this._listeners=new WeakMap}addEventListener(s,a,u){if(a!==null){let l=this._listeners.get(a);l===void 0&&(l=c(this,a),typeof a=="function"&&this._listeners.set(a,l)),this._nativeEventTarget.addEventListener(s,l,u)}}dispatchEvent(s){return this._nativeEventTarget.dispatchEvent(s)}removeEventListener(s,a,u){const l=a===null?void 0:this._listeners.get(a);this._nativeEventTarget.removeEventListener(s,l===void 0?null:l,u)}},createExposeCurrentFrameAndCurrentTime=c=>(i,s,a)=>{Object.defineProperties(c,{currentFrame:{configurable:!0,get(){return Math.round(i*s)}},currentTime:{configurable:!0,get(){return i}}});try{return a()}finally{c!==null&&(delete c.currentFrame,delete c.currentTime)}},createFetchSource=c=>async i=>{try{const s=await fetch(i);if(s.ok)return[await s.text(),s.url]}catch{}throw c()},DEFAULT_OPTIONS$8={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},createGainNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=u(f),g={...DEFAULT_OPTIONS$8,...d},m=a(p,g),y=l(p),v=y?s():null;super(f,!1,m,v),this._gain=i(this,y,m.gain,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get gain(){return this._gain}},createGainNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap,h=async(f,d)=>{let p=s(f);const g=isOwnedByContext(p,d);if(!g){const m={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,gain:p.gain.value};p=i(d,m)}return l.set(d,p),g?await c(d,f.gain,p.gain):await a(d,f.gain,p.gain),await u(f,d,p),p};return{render(f,d){const p=l.get(d);return p!==void 0?Promise.resolve(p):h(f,d)}}},createGetActiveAudioWorkletNodeInputs=(c,i)=>s=>i(c,s),createGetAudioNodeRenderer=c=>i=>{const s=c(i);if(s.renderer===null)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return s.renderer},createGetAudioNodeTailTime=c=>i=>{var s;return(s=c.get(i))!==null&&s!==void 0?s:0},createGetAudioParamRenderer=c=>i=>{const s=c(i);if(s.renderer===null)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return s.renderer},createGetBackupOfflineAudioContext=c=>i=>c.get(i),createInvalidStateError=()=>new DOMException("","InvalidStateError"),createGetNativeContext=c=>i=>{const s=c.get(i);if(s===void 0)throw createInvalidStateError();return s},createGetOrCreateBackupOfflineAudioContext=(c,i)=>s=>{let a=c.get(s);if(a!==void 0)return a;if(i===null)throw new Error("Missing the native OfflineAudioContext constructor.");return a=new i(1,1,44100),c.set(s,a),a},createGetUnrenderedAudioWorkletNodes=c=>i=>{const s=c.get(i);if(s===void 0)throw new Error("The context has no set of AudioWorkletNodes.");return s},createInvalidAccessError=()=>new DOMException("","InvalidAccessError"),wrapIIRFilterNodeGetFrequencyResponseMethod=c=>{c.getFrequencyResponse=(i=>(s,a,u)=>{if(s.length!==a.length||a.length!==u.length)throw createInvalidAccessError();return i.call(c,s,a,u)})(c.getFrequencyResponse)},DEFAULT_OPTIONS$7={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},createIIRFilterNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=a(f),g=u(p),m={...DEFAULT_OPTIONS$7,...d},y=i(p,g?null:f.baseLatency,m),v=g?s(m.feedback,m.feedforward):null;super(f,!1,y,v),wrapIIRFilterNodeGetFrequencyResponseMethod(y),this._nativeIIRFilterNode=y,l(this,1)}getFrequencyResponse(f,d,p){return this._nativeIIRFilterNode.getFrequencyResponse(f,d,p)}},filterBuffer=(c,i,s,a,u,l,h,f,d,p,g)=>{const m=p.length;let y=f;for(let v=0;v<m;v+=1){let _=s[0]*p[v];for(let A=1;A<u;A+=1){const T=y-A&d-1;_+=s[A]*l[T],_-=c[A]*h[T]}for(let A=u;A<a;A+=1)_+=s[A]*l[y-A&d-1];for(let A=u;A<i;A+=1)_-=c[A]*h[y-A&d-1];l[y]=p[v],h[y]=_,y=y+1&d-1,g[v]=_}return y},filterFullBuffer=(c,i,s,a)=>{const u=s instanceof Float64Array?s:new Float64Array(s),l=a instanceof Float64Array?a:new Float64Array(a),h=u.length,f=l.length,d=Math.min(h,f);if(u[0]!==1){for(let _=0;_<h;_+=1)l[_]/=u[0];for(let _=1;_<f;_+=1)u[_]/=u[0]}const p=32,g=new Float32Array(p),m=new Float32Array(p),y=i.createBuffer(c.numberOfChannels,c.length,c.sampleRate),v=c.numberOfChannels;for(let _=0;_<v;_+=1){const A=c.getChannelData(_),T=y.getChannelData(_);g.fill(0),m.fill(0),filterBuffer(u,h,l,f,d,g,m,0,p,A,T)}return y},createIIRFilterNodeRendererFactory=(c,i,s,a,u)=>(l,h)=>{const f=new WeakMap;let d=null;const p=async(g,m)=>{let y=null,v=i(g);const _=isOwnedByContext(v,m);if(m.createIIRFilter===void 0?y=c(m,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}):_||(v=m.createIIRFilter(h,l)),f.set(m,y===null?v:y),y!==null){if(d===null){if(s===null)throw new Error("Missing the native OfflineAudioContext constructor.");const T=new s(g.context.destination.channelCount,g.context.length,m.sampleRate);d=(async()=>{await a(g,T,T.destination);const x=await u(T);return filterFullBuffer(x,m,l,h)})()}const A=await d;return y.buffer=A,y.start(0),y}return await a(g,m,v),v};return{render(g,m){const y=f.get(m);return y!==void 0?Promise.resolve(y):p(g,m)}}},createIncrementCycleCounterFactory=(c,i,s,a,u,l)=>h=>(f,d)=>{const p=c.get(f);if(p===void 0){if(!h&&l(f)){const g=a(f),{outputs:m}=s(f);for(const y of m)if(isAudioNodeOutputConnection(y)){const v=a(y[0]);i(g,v,y[1],y[2])}else{const v=u(y[0]);g.disconnect(v,y[1])}}c.set(f,d)}else c.set(f,p+d)},createIsAnyAudioContext=(c,i)=>s=>{const a=c.get(s);return i(a)||i(s)},createIsAnyAudioNode=(c,i)=>s=>c.has(s)||i(s),createIsAnyAudioParam=(c,i)=>s=>c.has(s)||i(s),createIsAnyOfflineAudioContext=(c,i)=>s=>{const a=c.get(s);return i(a)||i(s)},createIsNativeAudioContext=c=>i=>c!==null&&i instanceof c,createIsNativeAudioNode=c=>i=>c!==null&&typeof c.AudioNode=="function"&&i instanceof c.AudioNode,createIsNativeAudioParam=c=>i=>c!==null&&typeof c.AudioParam=="function"&&i instanceof c.AudioParam,createIsNativeContext=(c,i)=>s=>c(s)||i(s),createIsNativeOfflineAudioContext=c=>i=>c!==null&&i instanceof c,createIsSecureContext=c=>c!==null&&c.isSecureContext,createMediaElementAudioSourceNodeConstructor=(c,i,s,a)=>class extends c{constructor(l,h){const f=s(l),d=i(f,h);if(a(f))throw TypeError();super(l,!0,d,null),this._nativeMediaElementAudioSourceNode=d}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}},DEFAULT_OPTIONS$6={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},createMediaStreamAudioDestinationNodeConstructor=(c,i,s,a)=>class extends c{constructor(l,h){const f=s(l);if(a(f))throw new TypeError;const d={...DEFAULT_OPTIONS$6,...h},p=i(f,d);super(l,!1,p,null),this._nativeMediaStreamAudioDestinationNode=p}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}},createMediaStreamAudioSourceNodeConstructor=(c,i,s,a)=>class extends c{constructor(l,h){const f=s(l),d=i(f,h);if(a(f))throw new TypeError;super(l,!0,d,null),this._nativeMediaStreamAudioSourceNode=d}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}},createMediaStreamTrackAudioSourceNodeConstructor=(c,i,s)=>class extends c{constructor(u,l){const h=s(u),f=i(h,l);super(u,!0,f,null)}},createMinimalBaseAudioContextConstructor=(c,i,s,a,u,l)=>class extends s{constructor(f,d){super(f),this._nativeContext=f,CONTEXT_STORE.set(this,f),a(f)&&u.set(f,new Set),this._destination=new c(this,d),this._listener=i(this,f),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(f){const d=typeof f=="function"?l(this,f):null;this._nativeContext.onstatechange=d;const p=this._nativeContext.onstatechange;this._onstatechange=p!==null&&p===d?f:p}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}},testPromiseSupport=c=>{const i=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const s=c.decodeAudioData(i.buffer,()=>{});return s===void 0?!1:(s.catch(()=>{}),!0)}catch{}return!1},createMonitorConnections=(c,i)=>(s,a,u)=>{const l=new Set;return s.connect=(h=>(f,d=0,p=0)=>{const g=l.size===0;if(i(f))return h.call(s,f,d,p),c(l,[f,d,p],m=>m[0]===f&&m[1]===d&&m[2]===p,!0),g&&a(),f;h.call(s,f,d),c(l,[f,d],m=>m[0]===f&&m[1]===d,!0),g&&a()})(s.connect),s.disconnect=(h=>(f,d,p)=>{const g=l.size>0;if(f===void 0)h.apply(s),l.clear();else if(typeof f=="number"){h.call(s,f);for(const y of l)y[1]===f&&l.delete(y)}else{i(f)?h.call(s,f,d,p):h.call(s,f,d);for(const y of l)y[0]===f&&(d===void 0||y[1]===d)&&(p===void 0||y[2]===p)&&l.delete(y)}const m=l.size===0;g&&m&&u()})(s.disconnect),s},assignNativeAudioNodeOption=(c,i,s)=>{const a=i[s];a!==void 0&&a!==c[s]&&(c[s]=a)},assignNativeAudioNodeOptions=(c,i)=>{assignNativeAudioNodeOption(c,i,"channelCount"),assignNativeAudioNodeOption(c,i,"channelCountMode"),assignNativeAudioNodeOption(c,i,"channelInterpretation")},testAnalyserNodeGetFloatTimeDomainDataMethodSupport=c=>typeof c.getFloatTimeDomainData=="function",wrapAnalyserNodeGetFloatTimeDomainDataMethod=c=>{c.getFloatTimeDomainData=i=>{const s=new Uint8Array(i.length);c.getByteTimeDomainData(s);const a=Math.max(s.length,c.fftSize);for(let u=0;u<a;u+=1)i[u]=(s[u]-128)*.0078125;return i}},createNativeAnalyserNodeFactory=(c,i)=>(s,a)=>{const u=s.createAnalyser();if(assignNativeAudioNodeOptions(u,a),!(a.maxDecibels>a.minDecibels))throw i();return assignNativeAudioNodeOption(u,a,"fftSize"),assignNativeAudioNodeOption(u,a,"maxDecibels"),assignNativeAudioNodeOption(u,a,"minDecibels"),assignNativeAudioNodeOption(u,a,"smoothingTimeConstant"),c(testAnalyserNodeGetFloatTimeDomainDataMethodSupport,()=>testAnalyserNodeGetFloatTimeDomainDataMethodSupport(u))||wrapAnalyserNodeGetFloatTimeDomainDataMethod(u),u},createNativeAudioBufferConstructor=c=>c===null?null:c.hasOwnProperty("AudioBuffer")?c.AudioBuffer:null,assignNativeAudioNodeAudioParamValue=(c,i,s)=>{const a=i[s];a!==void 0&&a!==c[s].value&&(c[s].value=a)},wrapAudioBufferSourceNodeStartMethodConsecutiveCalls=c=>{c.start=(i=>{let s=!1;return(a=0,u=0,l)=>{if(s)throw createInvalidStateError();i.call(c,a,u,l),s=!0}})(c.start)},wrapAudioScheduledSourceNodeStartMethodNegativeParameters=c=>{c.start=(i=>(s=0,a=0,u)=>{if(typeof u=="number"&&u<0||a<0||s<0)throw new RangeError("The parameters can't be negative.");i.call(c,s,a,u)})(c.start)},wrapAudioScheduledSourceNodeStopMethodNegativeParameters=c=>{c.stop=(i=>(s=0)=>{if(s<0)throw new RangeError("The parameter can't be negative.");i.call(c,s)})(c.stop)},createNativeAudioBufferSourceNodeFactory=(c,i,s,a,u,l,h,f,d,p,g)=>(m,y)=>{const v=m.createBufferSource();return assignNativeAudioNodeOptions(v,y),assignNativeAudioNodeAudioParamValue(v,y,"playbackRate"),assignNativeAudioNodeOption(v,y,"buffer"),assignNativeAudioNodeOption(v,y,"loop"),assignNativeAudioNodeOption(v,y,"loopEnd"),assignNativeAudioNodeOption(v,y,"loopStart"),i(s,()=>s(m))||wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(v),i(a,()=>a(m))||d(v),i(u,()=>u(m))||p(v,m),i(l,()=>l(m))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(v),i(h,()=>h(m))||g(v,m),i(f,()=>f(m))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(v),c(m,v),v},createNativeAudioContextConstructor=c=>c===null?null:c.hasOwnProperty("AudioContext")?c.AudioContext:c.hasOwnProperty("webkitAudioContext")?c.webkitAudioContext:null,createNativeAudioDestinationNodeFactory=(c,i)=>(s,a,u)=>{const l=s.destination;if(l.channelCount!==a)try{l.channelCount=a}catch{}u&&l.channelCountMode!=="explicit"&&(l.channelCountMode="explicit"),l.maxChannelCount===0&&Object.defineProperty(l,"maxChannelCount",{value:a});const h=c(s,{channelCount:a,channelCountMode:l.channelCountMode,channelInterpretation:l.channelInterpretation,gain:1});return i(h,"channelCount",f=>()=>f.call(h),f=>d=>{f.call(h,d);try{l.channelCount=d}catch(p){if(d>l.maxChannelCount)throw p}}),i(h,"channelCountMode",f=>()=>f.call(h),f=>d=>{f.call(h,d),l.channelCountMode=d}),i(h,"channelInterpretation",f=>()=>f.call(h),f=>d=>{f.call(h,d),l.channelInterpretation=d}),Object.defineProperty(h,"maxChannelCount",{get:()=>l.maxChannelCount}),h.connect(l),h},createNativeAudioWorkletNodeConstructor=c=>c===null?null:c.hasOwnProperty("AudioWorkletNode")?c.AudioWorkletNode:null,testClonabilityOfAudioWorkletNodeOptions=c=>{const{port1:i}=new MessageChannel;try{i.postMessage(c)}finally{i.close()}},createNativeAudioWorkletNodeFactory=(c,i,s,a,u)=>(l,h,f,d,p,g)=>{if(f!==null)try{const m=new f(l,d,g),y=new Map;let v=null;if(Object.defineProperties(m,{channelCount:{get:()=>g.channelCount,set:()=>{throw c()}},channelCountMode:{get:()=>"explicit",set:()=>{throw c()}},onprocessorerror:{get:()=>v,set:_=>{typeof v=="function"&&m.removeEventListener("processorerror",v),v=typeof _=="function"?_:null,typeof v=="function"&&m.addEventListener("processorerror",v)}}}),m.addEventListener=(_=>(...A)=>{if(A[0]==="processorerror"){const T=typeof A[1]=="function"?A[1]:typeof A[1]=="object"&&A[1]!==null&&typeof A[1].handleEvent=="function"?A[1].handleEvent:null;if(T!==null){const x=y.get(A[1]);x!==void 0?A[1]=x:(A[1]=w=>{w.type==="error"?(Object.defineProperties(w,{type:{value:"processorerror"}}),T(w)):T(new ErrorEvent(A[0],{...w}))},y.set(T,A[1]))}}return _.call(m,"error",A[1],A[2]),_.call(m,...A)})(m.addEventListener),m.removeEventListener=(_=>(...A)=>{if(A[0]==="processorerror"){const T=y.get(A[1]);T!==void 0&&(y.delete(A[1]),A[1]=T)}return _.call(m,"error",A[1],A[2]),_.call(m,A[0],A[1],A[2])})(m.removeEventListener),g.numberOfOutputs!==0){const _=s(l,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return m.connect(_).connect(l.destination),u(m,()=>_.disconnect(),()=>_.connect(l.destination))}return m}catch(m){throw m.code===11?a():m}if(p===void 0)throw a();return testClonabilityOfAudioWorkletNodeOptions(g),i(l,h,p,g)},computeBufferSize=(c,i)=>c===null?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(c*i))))),cloneAudioWorkletNodeOptions=c=>new Promise((i,s)=>{const{port1:a,port2:u}=new MessageChannel;a.onmessage=({data:l})=>{a.close(),u.close(),i(l)},a.onmessageerror=({data:l})=>{a.close(),u.close(),s(l)},u.postMessage(c)}),createAudioWorkletProcessorPromise=async(c,i)=>{const s=await cloneAudioWorkletNodeOptions(i);return new c(s)},createAudioWorkletProcessor=(c,i,s,a)=>{let u=NODE_TO_PROCESSOR_MAPS.get(c);u===void 0&&(u=new WeakMap,NODE_TO_PROCESSOR_MAPS.set(c,u));const l=createAudioWorkletProcessorPromise(s,a);return u.set(i,l),l},createNativeAudioWorkletNodeFakerFactory=(c,i,s,a,u,l,h,f,d,p,g,m,y)=>(v,_,A,T)=>{if(T.numberOfInputs===0&&T.numberOfOutputs===0)throw d();const x=Array.isArray(T.outputChannelCount)?T.outputChannelCount:Array.from(T.outputChannelCount);if(x.some(L=>L<1))throw d();if(x.length!==T.numberOfOutputs)throw i();if(T.channelCountMode!=="explicit")throw d();const w=T.channelCount*T.numberOfInputs,b=x.reduce((L,Y)=>L+Y,0),C=A.parameterDescriptors===void 0?0:A.parameterDescriptors.length;if(w+C>6||b>6)throw d();const N=new MessageChannel,S=[],O=[];for(let L=0;L<T.numberOfInputs;L+=1)S.push(h(v,{channelCount:T.channelCount,channelCountMode:T.channelCountMode,channelInterpretation:T.channelInterpretation,gain:1})),O.push(u(v,{channelCount:T.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:T.channelCount}));const E=[];if(A.parameterDescriptors!==void 0)for(const{defaultValue:L,maxValue:Y,minValue:ee,name:re}of A.parameterDescriptors){const ne=l(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:T.parameterData[re]!==void 0?T.parameterData[re]:L===void 0?0:L});Object.defineProperties(ne.offset,{defaultValue:{get:()=>L===void 0?0:L},maxValue:{get:()=>Y===void 0?MOST_POSITIVE_SINGLE_FLOAT:Y},minValue:{get:()=>ee===void 0?MOST_NEGATIVE_SINGLE_FLOAT:ee}}),E.push(ne)}const R=a(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,w+C)}),I=computeBufferSize(_,v.sampleRate),M=f(v,I,w+C,Math.max(1,b)),k=u(v,{channelCount:Math.max(1,b),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,b)}),B=[];for(let L=0;L<T.numberOfOutputs;L+=1)B.push(a(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:x[L]}));for(let L=0;L<T.numberOfInputs;L+=1){S[L].connect(O[L]);for(let Y=0;Y<T.channelCount;Y+=1)O[L].connect(R,Y,L*T.channelCount+Y)}const P=new ReadOnlyMap(A.parameterDescriptors===void 0?[]:A.parameterDescriptors.map(({name:L},Y)=>{const ee=E[Y];return ee.connect(R,0,w+Y),ee.start(0),[L,ee.offset]}));R.connect(M);let z=T.channelInterpretation,W=null;const G=T.numberOfOutputs===0?[M]:B,J={get bufferSize(){return I},get channelCount(){return T.channelCount},set channelCount(L){throw s()},get channelCountMode(){return T.channelCountMode},set channelCountMode(L){throw s()},get channelInterpretation(){return z},set channelInterpretation(L){for(const Y of S)Y.channelInterpretation=L;z=L},get context(){return M.context},get inputs(){return S},get numberOfInputs(){return T.numberOfInputs},get numberOfOutputs(){return T.numberOfOutputs},get onprocessorerror(){return W},set onprocessorerror(L){typeof W=="function"&&J.removeEventListener("processorerror",W),W=typeof L=="function"?L:null,typeof W=="function"&&J.addEventListener("processorerror",W)},get parameters(){return P},get port(){return N.port2},addEventListener(...L){return M.addEventListener(L[0],L[1],L[2])},connect:c.bind(null,G),disconnect:p.bind(null,G),dispatchEvent(...L){return M.dispatchEvent(L[0])},removeEventListener(...L){return M.removeEventListener(L[0],L[1],L[2])}},X=new Map;N.port1.addEventListener=(L=>(...Y)=>{if(Y[0]==="message"){const ee=typeof Y[1]=="function"?Y[1]:typeof Y[1]=="object"&&Y[1]!==null&&typeof Y[1].handleEvent=="function"?Y[1].handleEvent:null;if(ee!==null){const re=X.get(Y[1]);re!==void 0?Y[1]=re:(Y[1]=ne=>{g(v.currentTime,v.sampleRate,()=>ee(ne))},X.set(ee,Y[1]))}}return L.call(N.port1,Y[0],Y[1],Y[2])})(N.port1.addEventListener),N.port1.removeEventListener=(L=>(...Y)=>{if(Y[0]==="message"){const ee=X.get(Y[1]);ee!==void 0&&(X.delete(Y[1]),Y[1]=ee)}return L.call(N.port1,Y[0],Y[1],Y[2])})(N.port1.removeEventListener);let Z=null;Object.defineProperty(N.port1,"onmessage",{get:()=>Z,set:L=>{typeof Z=="function"&&N.port1.removeEventListener("message",Z),Z=typeof L=="function"?L:null,typeof Z=="function"&&(N.port1.addEventListener("message",Z),N.port1.start())}}),A.prototype.port=N.port1;let H=null;createAudioWorkletProcessor(v,J,A,T).then(L=>H=L);const ce=createNestedArrays(T.numberOfInputs,T.channelCount),oe=createNestedArrays(T.numberOfOutputs,x),K=A.parameterDescriptors===void 0?[]:A.parameterDescriptors.reduce((L,{name:Y})=>({...L,[Y]:new Float32Array(128)}),{});let ie=!0;const ae=()=>{T.numberOfOutputs>0&&M.disconnect(k);for(let L=0,Y=0;L<T.numberOfOutputs;L+=1){const ee=B[L];for(let re=0;re<x[L];re+=1)k.disconnect(ee,Y+re,re);Y+=x[L]}},$=new Map;M.onaudioprocess=({inputBuffer:L,outputBuffer:Y})=>{if(H!==null){const ee=m(J);for(let re=0;re<I;re+=128){for(let ne=0;ne<T.numberOfInputs;ne+=1)for(let se=0;se<T.channelCount;se+=1)copyFromChannel(L,ce[ne],se,se,re);A.parameterDescriptors!==void 0&&A.parameterDescriptors.forEach(({name:ne},se)=>{copyFromChannel(L,K,ne,w+se,re)});for(let ne=0;ne<T.numberOfInputs;ne+=1)for(let se=0;se<x[ne];se+=1)oe[ne][se].byteLength===0&&(oe[ne][se]=new Float32Array(128));try{const ne=ce.map((ue,le)=>{if(ee[le].size>0)return $.set(le,I/128),ue;const de=$.get(le);return de===void 0?[]:(ue.every(me=>me.every(ge=>ge===0))&&(de===1?$.delete(le):$.set(le,de-1)),ue)});ie=g(v.currentTime+re/v.sampleRate,v.sampleRate,()=>H.process(ne,oe,K));for(let ue=0,le=0;ue<T.numberOfOutputs;ue+=1){for(let he=0;he<x[ue];he+=1)copyToChannel(Y,oe[ue],he,le+he,re);le+=x[ue]}}catch(ne){ie=!1,J.dispatchEvent(new ErrorEvent("processorerror",{colno:ne.colno,filename:ne.filename,lineno:ne.lineno,message:ne.message}))}if(!ie){for(let ne=0;ne<T.numberOfInputs;ne+=1){S[ne].disconnect(O[ne]);for(let se=0;se<T.channelCount;se+=1)O[re].disconnect(R,se,ne*T.channelCount+se)}if(A.parameterDescriptors!==void 0){const ne=A.parameterDescriptors.length;for(let se=0;se<ne;se+=1){const ue=E[se];ue.disconnect(R,0,w+se),ue.stop()}}R.disconnect(M),M.onaudioprocess=null,D?ae():U();break}}}};let D=!1;const F=h(v,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),V=()=>M.connect(F).connect(v.destination),U=()=>{M.disconnect(F),F.disconnect()},j=()=>{if(ie){U(),T.numberOfOutputs>0&&M.connect(k);for(let L=0,Y=0;L<T.numberOfOutputs;L+=1){const ee=B[L];for(let re=0;re<x[L];re+=1)k.connect(ee,Y+re,re);Y+=x[L]}}D=!0},Q=()=>{ie&&(V(),ae()),D=!1};return V(),y(J,j,Q)},createNativeBiquadFilterNode=(c,i)=>{const s=c.createBiquadFilter();return assignNativeAudioNodeOptions(s,i),assignNativeAudioNodeAudioParamValue(s,i,"Q"),assignNativeAudioNodeAudioParamValue(s,i,"detune"),assignNativeAudioNodeAudioParamValue(s,i,"frequency"),assignNativeAudioNodeAudioParamValue(s,i,"gain"),assignNativeAudioNodeOption(s,i,"type"),s},createNativeChannelMergerNodeFactory=(c,i)=>(s,a)=>{const u=s.createChannelMerger(a.numberOfInputs);return c!==null&&c.name==="webkitAudioContext"&&i(s,u),assignNativeAudioNodeOptions(u,a),u},wrapChannelSplitterNode=c=>{const i=c.numberOfOutputs;Object.defineProperty(c,"channelCount",{get:()=>i,set:s=>{if(s!==i)throw createInvalidStateError()}}),Object.defineProperty(c,"channelCountMode",{get:()=>"explicit",set:s=>{if(s!=="explicit")throw createInvalidStateError()}}),Object.defineProperty(c,"channelInterpretation",{get:()=>"discrete",set:s=>{if(s!=="discrete")throw createInvalidStateError()}})},createNativeChannelSplitterNode=(c,i)=>{const s=c.createChannelSplitter(i.numberOfOutputs);return assignNativeAudioNodeOptions(s,i),wrapChannelSplitterNode(s),s},createNativeConstantSourceNodeFactory=(c,i,s,a,u)=>(l,h)=>{if(l.createConstantSource===void 0)return s(l,h);const f=l.createConstantSource();return assignNativeAudioNodeOptions(f,h),assignNativeAudioNodeAudioParamValue(f,h,"offset"),i(a,()=>a(l))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(f),i(u,()=>u(l))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(f),c(l,f),f},interceptConnections=(c,i)=>(c.connect=i.connect.bind(i),c.disconnect=i.disconnect.bind(i),c),createNativeConstantSourceNodeFakerFactory=(c,i,s,a)=>(u,{offset:l,...h})=>{const f=u.createBuffer(1,2,44100),d=i(u,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),p=s(u,{...h,gain:l}),g=f.getChannelData(0);g[0]=1,g[1]=1,d.buffer=f,d.loop=!0;const m={get bufferSize(){},get channelCount(){return p.channelCount},set channelCount(_){p.channelCount=_},get channelCountMode(){return p.channelCountMode},set channelCountMode(_){p.channelCountMode=_},get channelInterpretation(){return p.channelInterpretation},set channelInterpretation(_){p.channelInterpretation=_},get context(){return p.context},get inputs(){return[]},get numberOfInputs(){return d.numberOfInputs},get numberOfOutputs(){return p.numberOfOutputs},get offset(){return p.gain},get onended(){return d.onended},set onended(_){d.onended=_},addEventListener(..._){return d.addEventListener(_[0],_[1],_[2])},dispatchEvent(..._){return d.dispatchEvent(_[0])},removeEventListener(..._){return d.removeEventListener(_[0],_[1],_[2])},start(_=0){d.start.call(d,_)},stop(_=0){d.stop.call(d,_)}},y=()=>d.connect(p),v=()=>d.disconnect(p);return c(u,d),a(interceptConnections(m,p),y,v)},createNativeConvolverNodeFactory=(c,i)=>(s,a)=>{const u=s.createConvolver();if(assignNativeAudioNodeOptions(u,a),a.disableNormalization===u.normalize&&(u.normalize=!a.disableNormalization),assignNativeAudioNodeOption(u,a,"buffer"),a.channelCount>2||(i(u,"channelCount",l=>()=>l.call(u),l=>h=>{if(h>2)throw c();return l.call(u,h)}),a.channelCountMode==="max"))throw c();return i(u,"channelCountMode",l=>()=>l.call(u),l=>h=>{if(h==="max")throw c();return l.call(u,h)}),u},createNativeDelayNode=(c,i)=>{const s=c.createDelay(i.maxDelayTime);return assignNativeAudioNodeOptions(s,i),assignNativeAudioNodeAudioParamValue(s,i,"delayTime"),s},createNativeDynamicsCompressorNodeFactory=c=>(i,s)=>{const a=i.createDynamicsCompressor();if(assignNativeAudioNodeOptions(a,s),s.channelCount>2||s.channelCountMode==="max")throw c();return assignNativeAudioNodeAudioParamValue(a,s,"attack"),assignNativeAudioNodeAudioParamValue(a,s,"knee"),assignNativeAudioNodeAudioParamValue(a,s,"ratio"),assignNativeAudioNodeAudioParamValue(a,s,"release"),assignNativeAudioNodeAudioParamValue(a,s,"threshold"),a},createNativeGainNode=(c,i)=>{const s=c.createGain();return assignNativeAudioNodeOptions(s,i),assignNativeAudioNodeAudioParamValue(s,i,"gain"),s},createNativeIIRFilterNodeFactory=c=>(i,s,a)=>{if(i.createIIRFilter===void 0)return c(i,s,a);const u=i.createIIRFilter(a.feedforward,a.feedback);return assignNativeAudioNodeOptions(u,a),u};function divide(c,i){const s=i[0]*i[0]+i[1]*i[1];return[(c[0]*i[0]+c[1]*i[1])/s,(c[1]*i[0]-c[0]*i[1])/s]}function multiply(c,i){return[c[0]*i[0]-c[1]*i[1],c[0]*i[1]+c[1]*i[0]]}function evaluatePolynomial(c,i){let s=[0,0];for(let a=c.length-1;a>=0;a-=1)s=multiply(s,i),s[0]+=c[a];return s}const createNativeIIRFilterNodeFakerFactory=(c,i,s,a)=>(u,l,{channelCount:h,channelCountMode:f,channelInterpretation:d,feedback:p,feedforward:g})=>{const m=computeBufferSize(l,u.sampleRate),y=p instanceof Float64Array?p:new Float64Array(p),v=g instanceof Float64Array?g:new Float64Array(g),_=y.length,A=v.length,T=Math.min(_,A);if(_===0||_>20)throw a();if(y[0]===0)throw i();if(A===0||A>20)throw a();if(v[0]===0)throw i();if(y[0]!==1){for(let E=0;E<A;E+=1)v[E]/=y[0];for(let E=1;E<_;E+=1)y[E]/=y[0]}const x=s(u,m,h,h);x.channelCount=h,x.channelCountMode=f,x.channelInterpretation=d;const w=32,b=[],C=[],N=[];for(let E=0;E<h;E+=1){b.push(0);const R=new Float32Array(w),I=new Float32Array(w);R.fill(0),I.fill(0),C.push(R),N.push(I)}x.onaudioprocess=E=>{const R=E.inputBuffer,I=E.outputBuffer,M=R.numberOfChannels;for(let k=0;k<M;k+=1){const B=R.getChannelData(k),P=I.getChannelData(k);b[k]=filterBuffer(y,_,v,A,T,C[k],N[k],b[k],w,B,P)}};const S=u.sampleRate/2;return interceptConnections({get bufferSize(){return m},get channelCount(){return x.channelCount},set channelCount(E){x.channelCount=E},get channelCountMode(){return x.channelCountMode},set channelCountMode(E){x.channelCountMode=E},get channelInterpretation(){return x.channelInterpretation},set channelInterpretation(E){x.channelInterpretation=E},get context(){return x.context},get inputs(){return[x]},get numberOfInputs(){return x.numberOfInputs},get numberOfOutputs(){return x.numberOfOutputs},addEventListener(...E){return x.addEventListener(E[0],E[1],E[2])},dispatchEvent(...E){return x.dispatchEvent(E[0])},getFrequencyResponse(E,R,I){if(E.length!==R.length||R.length!==I.length)throw c();const M=E.length;for(let k=0;k<M;k+=1){const B=-Math.PI*(E[k]/S),P=[Math.cos(B),Math.sin(B)],z=evaluatePolynomial(v,P),W=evaluatePolynomial(y,P),G=divide(z,W);R[k]=Math.sqrt(G[0]*G[0]+G[1]*G[1]),I[k]=Math.atan2(G[1],G[0])}},removeEventListener(...E){return x.removeEventListener(E[0],E[1],E[2])}},x)},createNativeMediaElementAudioSourceNode=(c,i)=>c.createMediaElementSource(i.mediaElement),createNativeMediaStreamAudioDestinationNode=(c,i)=>{const s=c.createMediaStreamDestination();return assignNativeAudioNodeOptions(s,i),s.numberOfOutputs===1&&Object.defineProperty(s,"numberOfOutputs",{get:()=>0}),s},createNativeMediaStreamAudioSourceNode=(c,{mediaStream:i})=>{const s=i.getAudioTracks();s.sort((l,h)=>l.id<h.id?-1:l.id>h.id?1:0);const a=s.slice(0,1),u=c.createMediaStreamSource(new MediaStream(a));return Object.defineProperty(u,"mediaStream",{value:i}),u},createNativeMediaStreamTrackAudioSourceNodeFactory=(c,i)=>(s,{mediaStreamTrack:a})=>{if(typeof s.createMediaStreamTrackSource=="function")return s.createMediaStreamTrackSource(a);const u=new MediaStream([a]),l=s.createMediaStreamSource(u);if(a.kind!=="audio")throw c();if(i(s))throw new TypeError;return l},createNativeOfflineAudioContextConstructor=c=>c===null?null:c.hasOwnProperty("OfflineAudioContext")?c.OfflineAudioContext:c.hasOwnProperty("webkitOfflineAudioContext")?c.webkitOfflineAudioContext:null,createNativeOscillatorNodeFactory=(c,i,s,a,u,l)=>(h,f)=>{const d=h.createOscillator();return assignNativeAudioNodeOptions(d,f),assignNativeAudioNodeAudioParamValue(d,f,"detune"),assignNativeAudioNodeAudioParamValue(d,f,"frequency"),f.periodicWave!==void 0?d.setPeriodicWave(f.periodicWave):assignNativeAudioNodeOption(d,f,"type"),i(s,()=>s(h))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(d),i(a,()=>a(h))||l(d,h),i(u,()=>u(h))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(d),c(h,d),d},createNativePannerNodeFactory=c=>(i,s)=>{const a=i.createPanner();return a.orientationX===void 0?c(i,s):(assignNativeAudioNodeOptions(a,s),assignNativeAudioNodeAudioParamValue(a,s,"orientationX"),assignNativeAudioNodeAudioParamValue(a,s,"orientationY"),assignNativeAudioNodeAudioParamValue(a,s,"orientationZ"),assignNativeAudioNodeAudioParamValue(a,s,"positionX"),assignNativeAudioNodeAudioParamValue(a,s,"positionY"),assignNativeAudioNodeAudioParamValue(a,s,"positionZ"),assignNativeAudioNodeOption(a,s,"coneInnerAngle"),assignNativeAudioNodeOption(a,s,"coneOuterAngle"),assignNativeAudioNodeOption(a,s,"coneOuterGain"),assignNativeAudioNodeOption(a,s,"distanceModel"),assignNativeAudioNodeOption(a,s,"maxDistance"),assignNativeAudioNodeOption(a,s,"panningModel"),assignNativeAudioNodeOption(a,s,"refDistance"),assignNativeAudioNodeOption(a,s,"rolloffFactor"),a)},createNativePannerNodeFakerFactory=(c,i,s,a,u,l,h,f,d,p)=>(g,{coneInnerAngle:m,coneOuterAngle:y,coneOuterGain:v,distanceModel:_,maxDistance:A,orientationX:T,orientationY:x,orientationZ:w,panningModel:b,positionX:C,positionY:N,positionZ:S,refDistance:O,rolloffFactor:E,...R})=>{const I=g.createPanner();if(R.channelCount>2||R.channelCountMode==="max")throw h();assignNativeAudioNodeOptions(I,R);const M={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},k=s(g,{...M,channelInterpretation:"speakers",numberOfInputs:6}),B=a(g,{...R,gain:1}),P=a(g,{...M,gain:1}),z=a(g,{...M,gain:0}),W=a(g,{...M,gain:0}),G=a(g,{...M,gain:0}),J=a(g,{...M,gain:0}),X=a(g,{...M,gain:0}),Z=u(g,256,6,1),H=l(g,{...M,curve:new Float32Array([1,1]),oversample:"none"});let te=[T,x,w],ce=[C,N,S];const oe=new Float32Array(1);Z.onaudioprocess=({inputBuffer:$})=>{const D=[d($,oe,0),d($,oe,1),d($,oe,2)];D.some((V,U)=>V!==te[U])&&(I.setOrientation(...D),te=D);const F=[d($,oe,3),d($,oe,4),d($,oe,5)];F.some((V,U)=>V!==ce[U])&&(I.setPosition(...F),ce=F)},Object.defineProperty(z.gain,"defaultValue",{get:()=>0}),Object.defineProperty(W.gain,"defaultValue",{get:()=>0}),Object.defineProperty(G.gain,"defaultValue",{get:()=>0}),Object.defineProperty(J.gain,"defaultValue",{get:()=>0}),Object.defineProperty(X.gain,"defaultValue",{get:()=>0});const K={get bufferSize(){},get channelCount(){return I.channelCount},set channelCount($){if($>2)throw h();B.channelCount=$,I.channelCount=$},get channelCountMode(){return I.channelCountMode},set channelCountMode($){if($==="max")throw h();B.channelCountMode=$,I.channelCountMode=$},get channelInterpretation(){return I.channelInterpretation},set channelInterpretation($){B.channelInterpretation=$,I.channelInterpretation=$},get coneInnerAngle(){return I.coneInnerAngle},set coneInnerAngle($){I.coneInnerAngle=$},get coneOuterAngle(){return I.coneOuterAngle},set coneOuterAngle($){I.coneOuterAngle=$},get coneOuterGain(){return I.coneOuterGain},set coneOuterGain($){if($<0||$>1)throw i();I.coneOuterGain=$},get context(){return I.context},get distanceModel(){return I.distanceModel},set distanceModel($){I.distanceModel=$},get inputs(){return[B]},get maxDistance(){return I.maxDistance},set maxDistance($){if($<0)throw new RangeError;I.maxDistance=$},get numberOfInputs(){return I.numberOfInputs},get numberOfOutputs(){return I.numberOfOutputs},get orientationX(){return P.gain},get orientationY(){return z.gain},get orientationZ(){return W.gain},get panningModel(){return I.panningModel},set panningModel($){I.panningModel=$},get positionX(){return G.gain},get positionY(){return J.gain},get positionZ(){return X.gain},get refDistance(){return I.refDistance},set refDistance($){if($<0)throw new RangeError;I.refDistance=$},get rolloffFactor(){return I.rolloffFactor},set rolloffFactor($){if($<0)throw new RangeError;I.rolloffFactor=$},addEventListener(...$){return B.addEventListener($[0],$[1],$[2])},dispatchEvent(...$){return B.dispatchEvent($[0])},removeEventListener(...$){return B.removeEventListener($[0],$[1],$[2])}};m!==K.coneInnerAngle&&(K.coneInnerAngle=m),y!==K.coneOuterAngle&&(K.coneOuterAngle=y),v!==K.coneOuterGain&&(K.coneOuterGain=v),_!==K.distanceModel&&(K.distanceModel=_),A!==K.maxDistance&&(K.maxDistance=A),T!==K.orientationX.value&&(K.orientationX.value=T),x!==K.orientationY.value&&(K.orientationY.value=x),w!==K.orientationZ.value&&(K.orientationZ.value=w),b!==K.panningModel&&(K.panningModel=b),C!==K.positionX.value&&(K.positionX.value=C),N!==K.positionY.value&&(K.positionY.value=N),S!==K.positionZ.value&&(K.positionZ.value=S),O!==K.refDistance&&(K.refDistance=O),E!==K.rolloffFactor&&(K.rolloffFactor=E),(te[0]!==1||te[1]!==0||te[2]!==0)&&I.setOrientation(...te),(ce[0]!==0||ce[1]!==0||ce[2]!==0)&&I.setPosition(...ce);const ie=()=>{B.connect(I),c(B,H,0,0),H.connect(P).connect(k,0,0),H.connect(z).connect(k,0,1),H.connect(W).connect(k,0,2),H.connect(G).connect(k,0,3),H.connect(J).connect(k,0,4),H.connect(X).connect(k,0,5),k.connect(Z).connect(g.destination)},ae=()=>{B.disconnect(I),f(B,H,0,0),H.disconnect(P),P.disconnect(k),H.disconnect(z),z.disconnect(k),H.disconnect(W),W.disconnect(k),H.disconnect(G),G.disconnect(k),H.disconnect(J),J.disconnect(k),H.disconnect(X),X.disconnect(k),k.disconnect(Z),Z.disconnect(g.destination)};return p(interceptConnections(K,I),ie,ae)},createNativePeriodicWaveFactory=c=>(i,{disableNormalization:s,imag:a,real:u})=>{const l=a instanceof Float32Array?a:new Float32Array(a),h=u instanceof Float32Array?u:new Float32Array(u),f=i.createPeriodicWave(h,l,{disableNormalization:s});if(Array.from(a).length<2)throw c();return f},createNativeScriptProcessorNode=(c,i,s,a)=>c.createScriptProcessor(i,s,a),createNativeStereoPannerNodeFactory=(c,i)=>(s,a)=>{const u=a.channelCountMode;if(u==="clamped-max")throw i();if(s.createStereoPanner===void 0)return c(s,a);const l=s.createStereoPanner();return assignNativeAudioNodeOptions(l,a),assignNativeAudioNodeAudioParamValue(l,a,"pan"),Object.defineProperty(l,"channelCountMode",{get:()=>u,set:h=>{if(h!==u)throw i()}}),l},createNativeStereoPannerNodeFakerFactory=(c,i,s,a,u,l)=>{const f=new Float32Array([1,1]),d=Math.PI/2,p={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},g={...p,oversample:"none"},m=(_,A,T,x)=>{const w=new Float32Array(16385),b=new Float32Array(16385);for(let R=0;R<16385;R+=1){const I=R/16384*d;w[R]=Math.cos(I),b[R]=Math.sin(I)}const C=s(_,{...p,gain:0}),N=a(_,{...g,curve:w}),S=a(_,{...g,curve:f}),O=s(_,{...p,gain:0}),E=a(_,{...g,curve:b});return{connectGraph(){A.connect(C),A.connect(S.inputs===void 0?S:S.inputs[0]),A.connect(O),S.connect(T),T.connect(N.inputs===void 0?N:N.inputs[0]),T.connect(E.inputs===void 0?E:E.inputs[0]),N.connect(C.gain),E.connect(O.gain),C.connect(x,0,0),O.connect(x,0,1)},disconnectGraph(){A.disconnect(C),A.disconnect(S.inputs===void 0?S:S.inputs[0]),A.disconnect(O),S.disconnect(T),T.disconnect(N.inputs===void 0?N:N.inputs[0]),T.disconnect(E.inputs===void 0?E:E.inputs[0]),N.disconnect(C.gain),E.disconnect(O.gain),C.disconnect(x,0,0),O.disconnect(x,0,1)}}},y=(_,A,T,x)=>{const w=new Float32Array(16385),b=new Float32Array(16385),C=new Float32Array(16385),N=new Float32Array(16385),S=Math.floor(16385/2);for(let G=0;G<16385;G+=1)if(G>S){const J=(G-S)/(16384-S)*d;w[G]=Math.cos(J),b[G]=Math.sin(J),C[G]=0,N[G]=1}else{const J=G/(16384-S)*d;w[G]=1,b[G]=0,C[G]=Math.cos(J),N[G]=Math.sin(J)}const O=i(_,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),E=s(_,{...p,gain:0}),R=a(_,{...g,curve:w}),I=s(_,{...p,gain:0}),M=a(_,{...g,curve:b}),k=a(_,{...g,curve:f}),B=s(_,{...p,gain:0}),P=a(_,{...g,curve:C}),z=s(_,{...p,gain:0}),W=a(_,{...g,curve:N});return{connectGraph(){A.connect(O),A.connect(k.inputs===void 0?k:k.inputs[0]),O.connect(E,0),O.connect(I,0),O.connect(B,1),O.connect(z,1),k.connect(T),T.connect(R.inputs===void 0?R:R.inputs[0]),T.connect(M.inputs===void 0?M:M.inputs[0]),T.connect(P.inputs===void 0?P:P.inputs[0]),T.connect(W.inputs===void 0?W:W.inputs[0]),R.connect(E.gain),M.connect(I.gain),P.connect(B.gain),W.connect(z.gain),E.connect(x,0,0),B.connect(x,0,0),I.connect(x,0,1),z.connect(x,0,1)},disconnectGraph(){A.disconnect(O),A.disconnect(k.inputs===void 0?k:k.inputs[0]),O.disconnect(E,0),O.disconnect(I,0),O.disconnect(B,1),O.disconnect(z,1),k.disconnect(T),T.disconnect(R.inputs===void 0?R:R.inputs[0]),T.disconnect(M.inputs===void 0?M:M.inputs[0]),T.disconnect(P.inputs===void 0?P:P.inputs[0]),T.disconnect(W.inputs===void 0?W:W.inputs[0]),R.disconnect(E.gain),M.disconnect(I.gain),P.disconnect(B.gain),W.disconnect(z.gain),E.disconnect(x,0,0),B.disconnect(x,0,0),I.disconnect(x,0,1),z.disconnect(x,0,1)}}},v=(_,A,T,x,w)=>{if(A===1)return m(_,T,x,w);if(A===2)return y(_,T,x,w);throw u()};return(_,{channelCount:A,channelCountMode:T,pan:x,...w})=>{if(T==="max")throw u();const b=c(_,{...w,channelCount:1,channelCountMode:T,numberOfInputs:2}),C=s(_,{...w,channelCount:A,channelCountMode:T,gain:1}),N=s(_,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:x});let{connectGraph:S,disconnectGraph:O}=v(_,A,C,N,b);Object.defineProperty(N.gain,"defaultValue",{get:()=>0}),Object.defineProperty(N.gain,"maxValue",{get:()=>1}),Object.defineProperty(N.gain,"minValue",{get:()=>-1});const E={get bufferSize(){},get channelCount(){return C.channelCount},set channelCount(k){C.channelCount!==k&&(R&&O(),{connectGraph:S,disconnectGraph:O}=v(_,k,C,N,b),R&&S()),C.channelCount=k},get channelCountMode(){return C.channelCountMode},set channelCountMode(k){if(k==="clamped-max"||k==="max")throw u();C.channelCountMode=k},get channelInterpretation(){return C.channelInterpretation},set channelInterpretation(k){C.channelInterpretation=k},get context(){return C.context},get inputs(){return[C]},get numberOfInputs(){return C.numberOfInputs},get numberOfOutputs(){return C.numberOfOutputs},get pan(){return N.gain},addEventListener(...k){return C.addEventListener(k[0],k[1],k[2])},dispatchEvent(...k){return C.dispatchEvent(k[0])},removeEventListener(...k){return C.removeEventListener(k[0],k[1],k[2])}};let R=!1;const I=()=>{S(),R=!0},M=()=>{O(),R=!1};return l(interceptConnections(E,b),I,M)}},createNativeWaveShaperNodeFactory=(c,i,s,a,u,l,h)=>(f,d)=>{const p=f.createWaveShaper();if(l!==null&&l.name==="webkitAudioContext"&&f.createGain().gain.automationRate===void 0)return s(f,d);assignNativeAudioNodeOptions(p,d);const g=d.curve===null||d.curve instanceof Float32Array?d.curve:new Float32Array(d.curve);if(g!==null&&g.length<2)throw i();assignNativeAudioNodeOption(p,{curve:g},"curve"),assignNativeAudioNodeOption(p,d,"oversample");let m=null,y=!1;return h(p,"curve",A=>()=>A.call(p),A=>T=>(A.call(p,T),y&&(a(T)&&m===null?m=c(f,p):!a(T)&&m!==null&&(m(),m=null)),T)),u(p,()=>{y=!0,a(p.curve)&&(m=c(f,p))},()=>{y=!1,m!==null&&(m(),m=null)})},createNativeWaveShaperNodeFakerFactory=(c,i,s,a,u)=>(l,{curve:h,oversample:f,...d})=>{const p=l.createWaveShaper(),g=l.createWaveShaper();assignNativeAudioNodeOptions(p,d),assignNativeAudioNodeOptions(g,d);const m=s(l,{...d,gain:1}),y=s(l,{...d,gain:-1}),v=s(l,{...d,gain:1}),_=s(l,{...d,gain:-1});let A=null,T=!1,x=null;const w={get bufferSize(){},get channelCount(){return p.channelCount},set channelCount(N){m.channelCount=N,y.channelCount=N,p.channelCount=N,v.channelCount=N,g.channelCount=N,_.channelCount=N},get channelCountMode(){return p.channelCountMode},set channelCountMode(N){m.channelCountMode=N,y.channelCountMode=N,p.channelCountMode=N,v.channelCountMode=N,g.channelCountMode=N,_.channelCountMode=N},get channelInterpretation(){return p.channelInterpretation},set channelInterpretation(N){m.channelInterpretation=N,y.channelInterpretation=N,p.channelInterpretation=N,v.channelInterpretation=N,g.channelInterpretation=N,_.channelInterpretation=N},get context(){return p.context},get curve(){return x},set curve(N){if(N!==null&&N.length<2)throw i();if(N===null)p.curve=N,g.curve=N;else{const S=N.length,O=new Float32Array(S+2-S%2),E=new Float32Array(S+2-S%2);O[0]=N[0],E[0]=-N[S-1];const R=Math.ceil((S+1)/2),I=(S+1)/2-1;for(let M=1;M<R;M+=1){const k=M/R*I,B=Math.floor(k),P=Math.ceil(k);O[M]=B===P?N[B]:(1-(k-B))*N[B]+(1-(P-k))*N[P],E[M]=B===P?-N[S-1-B]:-((1-(k-B))*N[S-1-B])-(1-(P-k))*N[S-1-P]}O[R]=S%2===1?N[R-1]:(N[R-2]+N[R-1])/2,p.curve=O,g.curve=E}x=N,T&&(a(x)&&A===null?A=c(l,m):A!==null&&(A(),A=null))},get inputs(){return[m]},get numberOfInputs(){return p.numberOfInputs},get numberOfOutputs(){return p.numberOfOutputs},get oversample(){return p.oversample},set oversample(N){p.oversample=N,g.oversample=N},addEventListener(...N){return m.addEventListener(N[0],N[1],N[2])},dispatchEvent(...N){return m.dispatchEvent(N[0])},removeEventListener(...N){return m.removeEventListener(N[0],N[1],N[2])}};h!==null&&(w.curve=h instanceof Float32Array?h:new Float32Array(h)),f!==w.oversample&&(w.oversample=f);const b=()=>{m.connect(p).connect(v),m.connect(y).connect(g).connect(_).connect(v),T=!0,a(x)&&(A=c(l,m))},C=()=>{m.disconnect(p),p.disconnect(v),m.disconnect(y),y.disconnect(g),g.disconnect(_),_.disconnect(v),T=!1,A!==null&&(A(),A=null)};return u(interceptConnections(w,v),b,C)},createNotSupportedError=()=>new DOMException("","NotSupportedError"),DEFAULT_OPTIONS$5={numberOfChannels:1},createOfflineAudioContextConstructor=(c,i,s,a,u)=>class extends c{constructor(h,f,d){let p;if(typeof h=="number"&&f!==void 0&&d!==void 0)p={length:f,numberOfChannels:h,sampleRate:d};else if(typeof h=="object")p=h;else throw new Error("The given parameters are not valid.");const{length:g,numberOfChannels:m,sampleRate:y}={...DEFAULT_OPTIONS$5,...p},v=a(m,g,y);i(testPromiseSupport,()=>testPromiseSupport(v))||v.addEventListener("statechange",(()=>{let _=0;const A=T=>{this._state==="running"&&(_>0?(v.removeEventListener("statechange",A),T.stopImmediatePropagation(),this._waitForThePromiseToSettle(T)):_+=1)};return A})()),super(v,m),this._length=g,this._nativeOfflineAudioContext=v,this._state=null}get length(){return this._nativeOfflineAudioContext.length===void 0?this._length:this._nativeOfflineAudioContext.length}get state(){return this._state===null?this._nativeOfflineAudioContext.state:this._state}startRendering(){return this._state==="running"?Promise.reject(s()):(this._state="running",u(this.destination,this._nativeOfflineAudioContext).finally(()=>{this._state=null,deactivateAudioGraph(this)}))}_waitForThePromiseToSettle(h){this._state===null?this._nativeOfflineAudioContext.dispatchEvent(h):setTimeout(()=>this._waitForThePromiseToSettle(h))}},DEFAULT_OPTIONS$4={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"},createOscillatorNodeConstructor=(c,i,s,a,u,l,h)=>class extends c{constructor(d,p){const g=u(d),m={...DEFAULT_OPTIONS$4,...p},y=s(g,m),v=l(g),_=v?a():null,A=d.sampleRate/2;super(d,!1,y,_),this._detune=i(this,v,y.detune,153600,-153600),this._frequency=i(this,v,y.frequency,A,-A),this._nativeOscillatorNode=y,this._onended=null,this._oscillatorNodeRenderer=_,this._oscillatorNodeRenderer!==null&&m.periodicWave!==void 0&&(this._oscillatorNodeRenderer.periodicWave=m.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(d){const p=typeof d=="function"?h(this,d):null;this._nativeOscillatorNode.onended=p;const g=this._nativeOscillatorNode.onended;this._onended=g!==null&&g===p?d:g}get type(){return this._nativeOscillatorNode.type}set type(d){this._nativeOscillatorNode.type=d,this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(d){this._nativeOscillatorNode.setPeriodicWave(d),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.periodicWave=d)}start(d=0){if(this._nativeOscillatorNode.start(d),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.start=d),this.context.state!=="closed"){setInternalStateToActive(this);const p=()=>{this._nativeOscillatorNode.removeEventListener("ended",p),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeOscillatorNode.addEventListener("ended",p)}}stop(d=0){this._nativeOscillatorNode.stop(d),this._oscillatorNodeRenderer!==null&&(this._oscillatorNodeRenderer.stop=d)}},createOscillatorNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap;let h=null,f=null,d=null;const p=async(g,m)=>{let y=s(g);const v=isOwnedByContext(y,m);if(!v){const _={channelCount:y.channelCount,channelCountMode:y.channelCountMode,channelInterpretation:y.channelInterpretation,detune:y.detune.value,frequency:y.frequency.value,periodicWave:h===null?void 0:h,type:y.type};y=i(m,_),f!==null&&y.start(f),d!==null&&y.stop(d)}return l.set(m,y),v?(await c(m,g.detune,y.detune),await c(m,g.frequency,y.frequency)):(await a(m,g.detune,y.detune),await a(m,g.frequency,y.frequency)),await u(g,m,y),y};return{set periodicWave(g){h=g},set start(g){f=g},set stop(g){d=g},render(g,m){const y=l.get(m);return y!==void 0?Promise.resolve(y):p(g,m)}}},DEFAULT_OPTIONS$3={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},createPannerNodeConstructor=(c,i,s,a,u,l,h)=>class extends c{constructor(d,p){const g=u(d),m={...DEFAULT_OPTIONS$3,...p},y=s(g,m),v=l(g),_=v?a():null;super(d,!1,y,_),this._nativePannerNode=y,this._orientationX=i(this,v,y.orientationX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationY=i(this,v,y.orientationY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationZ=i(this,v,y.orientationZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionX=i(this,v,y.positionX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionY=i(this,v,y.positionY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionZ=i(this,v,y.positionZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),h(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(d){this._nativePannerNode.coneInnerAngle=d}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(d){this._nativePannerNode.coneOuterAngle=d}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(d){this._nativePannerNode.coneOuterGain=d}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(d){this._nativePannerNode.distanceModel=d}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(d){this._nativePannerNode.maxDistance=d}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(d){this._nativePannerNode.panningModel=d}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(d){this._nativePannerNode.refDistance=d}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(d){this._nativePannerNode.rolloffFactor=d}},createPannerNodeRendererFactory=(c,i,s,a,u,l,h,f,d,p)=>()=>{const g=new WeakMap;let m=null;const y=async(v,_)=>{let A=null,T=l(v);const x={channelCount:T.channelCount,channelCountMode:T.channelCountMode,channelInterpretation:T.channelInterpretation},w={...x,coneInnerAngle:T.coneInnerAngle,coneOuterAngle:T.coneOuterAngle,coneOuterGain:T.coneOuterGain,distanceModel:T.distanceModel,maxDistance:T.maxDistance,panningModel:T.panningModel,refDistance:T.refDistance,rolloffFactor:T.rolloffFactor},b=isOwnedByContext(T,_);if("bufferSize"in T)A=a(_,{...x,gain:1});else if(!b){const C={...w,orientationX:T.orientationX.value,orientationY:T.orientationY.value,orientationZ:T.orientationZ.value,positionX:T.positionX.value,positionY:T.positionY.value,positionZ:T.positionZ.value};T=u(_,C)}if(g.set(_,A===null?T:A),A!==null){if(m===null){if(h===null)throw new Error("Missing the native OfflineAudioContext constructor.");const M=new h(6,v.context.length,_.sampleRate),k=i(M,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});k.connect(M.destination),m=(async()=>{const B=await Promise.all([v.orientationX,v.orientationY,v.orientationZ,v.positionX,v.positionY,v.positionZ].map(async(P,z)=>{const W=s(M,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:z===0?1:0});return await f(M,P,W.offset),W}));for(let P=0;P<6;P+=1)B[P].connect(k,0,P),B[P].start(0);return p(M)})()}const C=await m,N=a(_,{...x,gain:1});await d(v,_,N);const S=[];for(let M=0;M<C.numberOfChannels;M+=1)S.push(C.getChannelData(M));let O=[S[0][0],S[1][0],S[2][0]],E=[S[3][0],S[4][0],S[5][0]],R=a(_,{...x,gain:1}),I=u(_,{...w,orientationX:O[0],orientationY:O[1],orientationZ:O[2],positionX:E[0],positionY:E[1],positionZ:E[2]});N.connect(R).connect(I.inputs[0]),I.connect(A);for(let M=128;M<C.length;M+=128){const k=[S[0][M],S[1][M],S[2][M]],B=[S[3][M],S[4][M],S[5][M]];if(k.some((P,z)=>P!==O[z])||B.some((P,z)=>P!==E[z])){O=k,E=B;const P=M/_.sampleRate;R.gain.setValueAtTime(0,P),R=a(_,{...x,gain:0}),I=u(_,{...w,orientationX:O[0],orientationY:O[1],orientationZ:O[2],positionX:E[0],positionY:E[1],positionZ:E[2]}),R.gain.setValueAtTime(1,P),N.connect(R).connect(I.inputs[0]),I.connect(A)}}return A}return b?(await c(_,v.orientationX,T.orientationX),await c(_,v.orientationY,T.orientationY),await c(_,v.orientationZ,T.orientationZ),await c(_,v.positionX,T.positionX),await c(_,v.positionY,T.positionY),await c(_,v.positionZ,T.positionZ)):(await f(_,v.orientationX,T.orientationX),await f(_,v.orientationY,T.orientationY),await f(_,v.orientationZ,T.orientationZ),await f(_,v.positionX,T.positionX),await f(_,v.positionY,T.positionY),await f(_,v.positionZ,T.positionZ)),isNativeAudioNodeFaker(T)?await d(v,_,T.inputs[0]):await d(v,_,T),T};return{render(v,_){const A=g.get(_);return A!==void 0?Promise.resolve(A):y(v,_)}}},DEFAULT_OPTIONS$2={disableNormalization:!1},createPeriodicWaveConstructor=(c,i,s,a)=>class pe{constructor(l,h){const f=i(l),d=a({...DEFAULT_OPTIONS$2,...h}),p=c(f,d);return s.add(p),p}static[Symbol.hasInstance](l){return l!==null&&typeof l=="object"&&Object.getPrototypeOf(l)===pe.prototype||s.has(l)}},createRenderAutomation=(c,i)=>(s,a,u)=>(c(a).replay(u),i(a,s,u)),createRenderInputsOfAudioNode=(c,i,s)=>async(a,u,l)=>{const h=c(a);await Promise.all(h.activeInputs.map((f,d)=>Array.from(f).map(async([p,g])=>{const y=await i(p).render(p,u),v=a.context.destination;!s(p)&&(a!==v||!s(a))&&y.connect(l,g,d)})).reduce((f,d)=>[...f,...d],[]))},createRenderInputsOfAudioParam=(c,i,s)=>async(a,u,l)=>{const h=i(a);await Promise.all(Array.from(h.activeInputs).map(async([f,d])=>{const g=await c(f).render(f,u);s(f)||g.connect(l,d)}))},createRenderNativeOfflineAudioContext=(c,i,s,a)=>u=>c(testPromiseSupport,()=>testPromiseSupport(u))?Promise.resolve(c(a,a)).then(l=>{if(!l){const h=s(u,512,0,1);u.oncomplete=()=>{h.onaudioprocess=null,h.disconnect()},h.onaudioprocess=()=>u.currentTime,h.connect(u.destination)}return u.startRendering()}):new Promise(l=>{const h=i(u,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});u.oncomplete=f=>{h.disconnect(),l(f.renderedBuffer)},h.connect(u.destination),u.startRendering()}),createSetActiveAudioWorkletNodeInputs=c=>(i,s)=>{c.set(i,s)},createSetAudioNodeTailTime=c=>(i,s)=>c.set(i,s),createStartRendering=(c,i,s,a,u,l,h,f)=>(d,p)=>s(d).render(d,p).then(()=>Promise.all(Array.from(a(p)).map(g=>s(g).render(g,p)))).then(()=>u(p)).then(g=>(typeof g.copyFromChannel!="function"?(h(g),wrapAudioBufferGetChannelDataMethod(g)):i(l,()=>l(g))||f(g),c.add(g),g)),DEFAULT_OPTIONS$1={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},createStereoPannerNodeConstructor=(c,i,s,a,u,l)=>class extends c{constructor(f,d){const p=u(f),g={...DEFAULT_OPTIONS$1,...d},m=s(p,g),y=l(p),v=y?a():null;super(f,!1,m,v),this._pan=i(this,y,m.pan)}get pan(){return this._pan}},createStereoPannerNodeRendererFactory=(c,i,s,a,u)=>()=>{const l=new WeakMap,h=async(f,d)=>{let p=s(f);const g=isOwnedByContext(p,d);if(!g){const m={channelCount:p.channelCount,channelCountMode:p.channelCountMode,channelInterpretation:p.channelInterpretation,pan:p.pan.value};p=i(d,m)}return l.set(d,p),g?await c(d,f.pan,p.pan):await a(d,f.pan,p.pan),isNativeAudioNodeFaker(p)?await u(f,d,p.inputs[0]):await u(f,d,p),p};return{render(f,d){const p=l.get(d);return p!==void 0?Promise.resolve(p):h(f,d)}}},createTestAudioBufferConstructorSupport=c=>()=>{if(c===null)return!1;try{new c({length:1,sampleRate:44100})}catch{return!1}return!0},createTestAudioWorkletProcessorPostMessageSupport=(c,i)=>async()=>{if(c===null)return!0;if(i===null)return!1;const s=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),a=new i(1,128,44100),u=URL.createObjectURL(s);let l=!1,h=!1;try{await a.audioWorklet.addModule(u);const f=new c(a,"a",{numberOfOutputs:0}),d=a.createOscillator();f.port.onmessage=()=>l=!0,f.onprocessorerror=()=>h=!0,d.connect(f),d.start(0),await a.startRendering()}catch{}finally{URL.revokeObjectURL(u)}return l&&!h},createTestOfflineAudioContextCurrentTimeSupport=(c,i)=>()=>{if(i===null)return Promise.resolve(!1);const s=new i(1,1,44100),a=c(s,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(u=>{s.oncomplete=()=>{a.disconnect(),u(s.currentTime!==0)},s.startRendering()})},createUnknownError=()=>new DOMException("","UnknownError"),DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},createWaveShaperNodeConstructor=(c,i,s,a,u,l,h)=>class extends c{constructor(d,p){const g=u(d),m={...DEFAULT_OPTIONS,...p},y=s(g,m),_=l(g)?a():null;super(d,!0,y,_),this._isCurveNullified=!1,this._nativeWaveShaperNode=y,h(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(d){if(d===null)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(d.length<2)throw i();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=d}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(d){this._nativeWaveShaperNode.oversample=d}},createWaveShaperNodeRendererFactory=(c,i,s)=>()=>{const a=new WeakMap,u=async(l,h)=>{let f=i(l);if(!isOwnedByContext(f,h)){const p={channelCount:f.channelCount,channelCountMode:f.channelCountMode,channelInterpretation:f.channelInterpretation,curve:f.curve,oversample:f.oversample};f=c(h,p)}return a.set(h,f),isNativeAudioNodeFaker(f)?await s(l,h,f.inputs[0]):await s(l,h,f),f};return{render(l,h){const f=a.get(h);return f!==void 0?Promise.resolve(f):u(l,h)}}},createWindow=()=>typeof window>"u"?null:window,createWrapAudioBufferCopyChannelMethods=(c,i)=>s=>{s.copyFromChannel=(a,u,l=0)=>{const h=c(l),f=c(u);if(f>=s.numberOfChannels)throw i();const d=s.length,p=s.getChannelData(f),g=a.length;for(let m=h<0?-h:0;m+h<d&&m<g;m+=1)a[m]=p[m+h]},s.copyToChannel=(a,u,l=0)=>{const h=c(l),f=c(u);if(f>=s.numberOfChannels)throw i();const d=s.length,p=s.getChannelData(f),g=a.length;for(let m=h<0?-h:0;m+h<d&&m<g;m+=1)p[m+h]=a[m]}},createWrapAudioBufferCopyChannelMethodsOutOfBounds=c=>i=>{i.copyFromChannel=(s=>(a,u,l=0)=>{const h=c(l),f=c(u);if(h<i.length)return s.call(i,a,f,h)})(i.copyFromChannel),i.copyToChannel=(s=>(a,u,l=0)=>{const h=c(l),f=c(u);if(h<i.length)return s.call(i,a,f,h)})(i.copyToChannel)},createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer=c=>(i,s)=>{const a=s.createBuffer(1,1,44100);i.buffer===null&&(i.buffer=a),c(i,"buffer",u=>()=>{const l=u.call(i);return l===a?null:l},u=>l=>u.call(i,l===null?a:l))},createWrapChannelMergerNode=(c,i)=>(s,a)=>{a.channelCount=1,a.channelCountMode="explicit",Object.defineProperty(a,"channelCount",{get:()=>1,set:()=>{throw c()}}),Object.defineProperty(a,"channelCountMode",{get:()=>"explicit",set:()=>{throw c()}});const u=s.createBufferSource();i(a,()=>{const f=a.numberOfInputs;for(let d=0;d<f;d+=1)u.connect(a,0,d)},()=>u.disconnect(a))},getFirstSample=(c,i,s)=>c.copyFromChannel===void 0?c.getChannelData(s)[0]:(c.copyFromChannel(i,s),i[0]),isDCCurve=c=>{if(c===null)return!1;const i=c.length;return i%2!==0?c[Math.floor(i/2)]!==0:c[i/2-1]+c[i/2]!==0},overwriteAccessors=(c,i,s,a)=>{let u=c;for(;!u.hasOwnProperty(i);)u=Object.getPrototypeOf(u);const{get:l,set:h}=Object.getOwnPropertyDescriptor(u,i);Object.defineProperty(c,i,{get:s(l),set:a(h)})},sanitizeAudioWorkletNodeOptions=c=>({...c,outputChannelCount:c.outputChannelCount!==void 0?c.outputChannelCount:c.numberOfInputs===1&&c.numberOfOutputs===1?[c.channelCount]:Array.from({length:c.numberOfOutputs},()=>1)}),sanitizeChannelSplitterOptions=c=>({...c,channelCount:c.numberOfOutputs}),sanitizePeriodicWaveOptions=c=>{const{imag:i,real:s}=c;return i===void 0?s===void 0?{...c,imag:[0,0],real:[0,0]}:{...c,imag:Array.from(s,()=>0),real:s}:s===void 0?{...c,imag:i,real:Array.from(i,()=>0)}:{...c,imag:i,real:s}},setValueAtTimeUntilPossible=(c,i,s)=>{try{c.setValueAtTime(i,s)}catch(a){if(a.code!==9)throw a;setValueAtTimeUntilPossible(c,i,s+1e-7)}},testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport=c=>{const i=c.createBufferSource();i.start();try{i.start()}catch{return!0}return!1},testAudioBufferSourceNodeStartMethodOffsetClampingSupport=c=>{const i=c.createBufferSource(),s=c.createBuffer(1,1,44100);i.buffer=s;try{i.start(0,1)}catch{return!1}return!0},testAudioBufferSourceNodeStopMethodNullifiedBufferSupport=c=>{const i=c.createBufferSource();i.start();try{i.stop()}catch{return!1}return!0},testAudioScheduledSourceNodeStartMethodNegativeParametersSupport=c=>{const i=c.createOscillator();try{i.start(-1)}catch(s){return s instanceof RangeError}return!1},testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport=c=>{const i=c.createBuffer(1,1,44100),s=c.createBufferSource();s.buffer=i,s.start(),s.stop();try{return s.stop(),!0}catch{return!1}},testAudioScheduledSourceNodeStopMethodNegativeParametersSupport=c=>{const i=c.createOscillator();try{i.stop(-1)}catch(s){return s instanceof RangeError}return!1},testAudioWorkletNodeOptionsClonability=c=>{const{port1:i,port2:s}=new MessageChannel;try{i.postMessage(c)}finally{i.close(),s.close()}},wrapAudioBufferSourceNodeStartMethodOffsetClamping=c=>{c.start=(i=>(s=0,a=0,u)=>{const l=c.buffer,h=l===null?a:Math.min(l.duration,a);l!==null&&h>l.duration-.5/c.context.sampleRate?i.call(c,s,0,0):i.call(c,s,h,u)})(c.start)},wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls=(c,i)=>{const s=i.createGain();c.connect(s);const a=(u=>()=>{u.call(c,s),c.removeEventListener("ended",a)})(c.disconnect);c.addEventListener("ended",a),interceptConnections(c,s),c.stop=(u=>{let l=!1;return(h=0)=>{if(l)try{u.call(c,h)}catch{s.gain.setValueAtTime(0,h)}else u.call(c,h),l=!0}})(c.stop)},wrapEventListener=(c,i)=>s=>{const a={value:c};return Object.defineProperties(s,{currentTarget:a,target:a}),typeof i=="function"?i.call(c,s):i.handleEvent.call(c,s)},addActiveInputConnectionToAudioNode=createAddActiveInputConnectionToAudioNode(insertElementInSet),addPassiveInputConnectionToAudioNode=createAddPassiveInputConnectionToAudioNode(insertElementInSet),deleteActiveInputConnectionToAudioNode=createDeleteActiveInputConnectionToAudioNode(pickElementFromSet),audioNodeTailTimeStore=new WeakMap,getAudioNodeTailTime=createGetAudioNodeTailTime(audioNodeTailTimeStore),cacheTestResult=createCacheTestResult(new Map,new WeakMap),window$1=createWindow(),createNativeAnalyserNode=createNativeAnalyserNodeFactory(cacheTestResult,createIndexSizeError),getAudioNodeRenderer=createGetAudioNodeRenderer(getAudioNodeConnections),renderInputsOfAudioNode=createRenderInputsOfAudioNode(getAudioNodeConnections,getAudioNodeRenderer,isPartOfACycle),createAnalyserNodeRenderer=createAnalyserNodeRendererFactory(createNativeAnalyserNode,getNativeAudioNode,renderInputsOfAudioNode),getNativeContext=createGetNativeContext(CONTEXT_STORE),nativeOfflineAudioContextConstructor=createNativeOfflineAudioContextConstructor(window$1),isNativeOfflineAudioContext=createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor),audioParamAudioNodeStore=new WeakMap,eventTargetConstructor=createEventTargetConstructor(wrapEventListener),nativeAudioContextConstructor=createNativeAudioContextConstructor(window$1),isNativeAudioContext=createIsNativeAudioContext(nativeAudioContextConstructor),isNativeAudioNode=createIsNativeAudioNode(window$1),isNativeAudioParam=createIsNativeAudioParam(window$1),nativeAudioWorkletNodeConstructor=createNativeAudioWorkletNodeConstructor(window$1),audioNodeConstructor=createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode,addPassiveInputConnectionToAudioNode,connectNativeAudioNodeToNativeAudioNode,deleteActiveInputConnectionToAudioNode,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getAudioNodeTailTime,getEventListenersOfAudioNode,getNativeAudioNode,insertElementInSet,isActiveAudioNode,isPartOfACycle,isPassiveAudioNode),cacheTestResult,createIncrementCycleCounterFactory(CYCLE_COUNTERS,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,isActiveAudioNode),createIndexSizeError,createInvalidAccessError,createNotSupportedError,createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode,CYCLE_COUNTERS,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,getNativeContext,isActiveAudioNode,isNativeOfflineAudioContext),createDetectCycles(audioParamAudioNodeStore,getAudioNodeConnections,getValueForKey),eventTargetConstructor,getNativeContext,isNativeAudioContext,isNativeAudioNode,isNativeAudioParam,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor),analyserNodeConstructor=createAnalyserNodeConstructor(audioNodeConstructor,createAnalyserNodeRenderer,createIndexSizeError,createNativeAnalyserNode,getNativeContext,isNativeOfflineAudioContext),audioBufferStore=new WeakSet,nativeAudioBufferConstructor=createNativeAudioBufferConstructor(window$1),convertNumberToUnsignedLong=createConvertNumberToUnsignedLong(new Uint32Array(1)),wrapAudioBufferCopyChannelMethods=createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong,createIndexSizeError),wrapAudioBufferCopyChannelMethodsOutOfBounds=createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong),audioBufferConstructor=createAudioBufferConstructor(audioBufferStore,cacheTestResult,createNotSupportedError,nativeAudioBufferConstructor,nativeOfflineAudioContextConstructor,createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),addSilentConnection=createAddSilentConnection(createNativeGainNode),renderInputsOfAudioParam=createRenderInputsOfAudioParam(getAudioNodeRenderer,getAudioParamConnections,isPartOfACycle),connectAudioParam=createConnectAudioParam(renderInputsOfAudioParam),createNativeAudioBufferSourceNode=createNativeAudioBufferSourceNodeFactory(addSilentConnection,cacheTestResult,testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,testAudioBufferSourceNodeStartMethodOffsetClampingSupport,testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioBufferSourceNodeStartMethodOffsetClamping,createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),renderAutomation=createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections),renderInputsOfAudioParam),createAudioBufferSourceNodeRenderer=createAudioBufferSourceNodeRendererFactory(connectAudioParam,createNativeAudioBufferSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),createAudioParam=createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),audioParamAudioNodeStore,AUDIO_PARAM_STORE,createAudioParamRenderer,createCancelAndHoldAutomationEvent,createCancelScheduledValuesAutomationEvent,createExponentialRampToValueAutomationEvent,createLinearRampToValueAutomationEvent,createSetTargetAutomationEvent,createSetValueAutomationEvent,createSetValueCurveAutomationEvent,nativeAudioContextConstructor,setValueAtTimeUntilPossible),audioBufferSourceNodeConstructor=createAudioBufferSourceNodeConstructor(audioNodeConstructor,createAudioBufferSourceNodeRenderer,createAudioParam,createInvalidStateError,createNativeAudioBufferSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),audioDestinationNodeConstructor=createAudioDestinationNodeConstructor(audioNodeConstructor,createAudioDestinationNodeRenderer,createIndexSizeError,createInvalidStateError,createNativeAudioDestinationNodeFactory(createNativeGainNode,overwriteAccessors),getNativeContext,isNativeOfflineAudioContext,renderInputsOfAudioNode),createBiquadFilterNodeRenderer=createBiquadFilterNodeRendererFactory(connectAudioParam,createNativeBiquadFilterNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),setAudioNodeTailTime=createSetAudioNodeTailTime(audioNodeTailTimeStore),biquadFilterNodeConstructor=createBiquadFilterNodeConstructor(audioNodeConstructor,createAudioParam,createBiquadFilterNodeRenderer,createInvalidAccessError,createNativeBiquadFilterNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),monitorConnections=createMonitorConnections(insertElementInSet,isNativeAudioNode),wrapChannelMergerNode=createWrapChannelMergerNode(createInvalidStateError,monitorConnections),createNativeChannelMergerNode=createNativeChannelMergerNodeFactory(nativeAudioContextConstructor,wrapChannelMergerNode),createChannelMergerNodeRenderer=createChannelMergerNodeRendererFactory(createNativeChannelMergerNode,getNativeAudioNode,renderInputsOfAudioNode),channelMergerNodeConstructor=createChannelMergerNodeConstructor(audioNodeConstructor,createChannelMergerNodeRenderer,createNativeChannelMergerNode,getNativeContext,isNativeOfflineAudioContext),createChannelSplitterNodeRenderer=createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode,getNativeAudioNode,renderInputsOfAudioNode),channelSplitterNodeConstructor=createChannelSplitterNodeConstructor(audioNodeConstructor,createChannelSplitterNodeRenderer,createNativeChannelSplitterNode,getNativeContext,isNativeOfflineAudioContext,sanitizeChannelSplitterOptions),createNativeConstantSourceNodeFaker=createNativeConstantSourceNodeFakerFactory(addSilentConnection,createNativeAudioBufferSourceNode,createNativeGainNode,monitorConnections),createNativeConstantSourceNode=createNativeConstantSourceNodeFactory(addSilentConnection,cacheTestResult,createNativeConstantSourceNodeFaker,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport),createConstantSourceNodeRenderer=createConstantSourceNodeRendererFactory(connectAudioParam,createNativeConstantSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),constantSourceNodeConstructor=createConstantSourceNodeConstructor(audioNodeConstructor,createAudioParam,createConstantSourceNodeRenderer,createNativeConstantSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createNativeConvolverNode=createNativeConvolverNodeFactory(createNotSupportedError,overwriteAccessors),createConvolverNodeRenderer=createConvolverNodeRendererFactory(createNativeConvolverNode,getNativeAudioNode,renderInputsOfAudioNode),convolverNodeConstructor=createConvolverNodeConstructor(audioNodeConstructor,createConvolverNodeRenderer,createNativeConvolverNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createDelayNodeRenderer=createDelayNodeRendererFactory(connectAudioParam,createNativeDelayNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),delayNodeConstructor=createDelayNodeConstructor(audioNodeConstructor,createAudioParam,createDelayNodeRenderer,createNativeDelayNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativeDynamicsCompressorNode=createNativeDynamicsCompressorNodeFactory(createNotSupportedError),createDynamicsCompressorNodeRenderer=createDynamicsCompressorNodeRendererFactory(connectAudioParam,createNativeDynamicsCompressorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),dynamicsCompressorNodeConstructor=createDynamicsCompressorNodeConstructor(audioNodeConstructor,createAudioParam,createDynamicsCompressorNodeRenderer,createNativeDynamicsCompressorNode,createNotSupportedError,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createGainNodeRenderer=createGainNodeRendererFactory(connectAudioParam,createNativeGainNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),gainNodeConstructor=createGainNodeConstructor(audioNodeConstructor,createAudioParam,createGainNodeRenderer,createNativeGainNode,getNativeContext,isNativeOfflineAudioContext),createNativeIIRFilterNodeFaker=createNativeIIRFilterNodeFakerFactory(createInvalidAccessError,createInvalidStateError,createNativeScriptProcessorNode,createNotSupportedError),renderNativeOfflineAudioContext=createRenderNativeOfflineAudioContext(cacheTestResult,createNativeGainNode,createNativeScriptProcessorNode,createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode,nativeOfflineAudioContextConstructor)),createIIRFilterNodeRenderer=createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderInputsOfAudioNode,renderNativeOfflineAudioContext),createNativeIIRFilterNode=createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker),iIRFilterNodeConstructor=createIIRFilterNodeConstructor(audioNodeConstructor,createNativeIIRFilterNode,createIIRFilterNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createAudioListener=createAudioListenerFactory(createAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeScriptProcessorNode,createNotSupportedError,getFirstSample,isNativeOfflineAudioContext,overwriteAccessors),unrenderedAudioWorkletNodeStore=new WeakMap,minimalBaseAudioContextConstructor=createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor,createAudioListener,eventTargetConstructor,isNativeOfflineAudioContext,unrenderedAudioWorkletNodeStore,wrapEventListener),createNativeOscillatorNode=createNativeOscillatorNodeFactory(addSilentConnection,cacheTestResult,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),createOscillatorNodeRenderer=createOscillatorNodeRendererFactory(connectAudioParam,createNativeOscillatorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),oscillatorNodeConstructor=createOscillatorNodeConstructor(audioNodeConstructor,createAudioParam,createNativeOscillatorNode,createOscillatorNodeRenderer,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createConnectedNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode),createNativeWaveShaperNodeFaker=createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeGainNode,isDCCurve,monitorConnections),createNativeWaveShaperNode=createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeWaveShaperNodeFaker,isDCCurve,monitorConnections,nativeAudioContextConstructor,overwriteAccessors),createNativePannerNodeFaker=createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode,createInvalidStateError,createNativeChannelMergerNode,createNativeGainNode,createNativeScriptProcessorNode,createNativeWaveShaperNode,createNotSupportedError,disconnectNativeAudioNodeFromNativeAudioNode,getFirstSample,monitorConnections),createNativePannerNode=createNativePannerNodeFactory(createNativePannerNodeFaker),createPannerNodeRenderer=createPannerNodeRendererFactory(connectAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeGainNode,createNativePannerNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),pannerNodeConstructor=createPannerNodeConstructor(audioNodeConstructor,createAudioParam,createNativePannerNode,createPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativePeriodicWave=createNativePeriodicWaveFactory(createIndexSizeError),periodicWaveConstructor=createPeriodicWaveConstructor(createNativePeriodicWave,getNativeContext,new WeakSet,sanitizePeriodicWaveOptions),nativeStereoPannerNodeFakerFactory=createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeGainNode,createNativeWaveShaperNode,createNotSupportedError,monitorConnections),createNativeStereoPannerNode=createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory,createNotSupportedError),createStereoPannerNodeRenderer=createStereoPannerNodeRendererFactory(connectAudioParam,createNativeStereoPannerNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),stereoPannerNodeConstructor=createStereoPannerNodeConstructor(audioNodeConstructor,createAudioParam,createNativeStereoPannerNode,createStereoPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext),createWaveShaperNodeRenderer=createWaveShaperNodeRendererFactory(createNativeWaveShaperNode,getNativeAudioNode,renderInputsOfAudioNode),waveShaperNodeConstructor=createWaveShaperNodeConstructor(audioNodeConstructor,createInvalidStateError,createNativeWaveShaperNode,createWaveShaperNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),isSecureContext=createIsSecureContext(window$1),exposeCurrentFrameAndCurrentTime=createExposeCurrentFrameAndCurrentTime(window$1),backupOfflineAudioContextStore=new WeakMap,getOrCreateBackupOfflineAudioContext=createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore,nativeOfflineAudioContextConstructor),addAudioWorkletModule=isSecureContext?createAddAudioWorkletModule(cacheTestResult,createNotSupportedError,createEvaluateSource(window$1),exposeCurrentFrameAndCurrentTime,createFetchSource(createAbortError),getNativeContext,getOrCreateBackupOfflineAudioContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,new WeakMap,new WeakMap,createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor),window$1):void 0,isNativeContext=createIsNativeContext(isNativeAudioContext,isNativeOfflineAudioContext),decodeAudioData=createDecodeAudioData(audioBufferStore,cacheTestResult,createDataCloneError,createEncodingError,new WeakSet,getNativeContext,isNativeContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,testPromiseSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),baseAudioContextConstructor=createBaseAudioContextConstructor(addAudioWorkletModule,analyserNodeConstructor,audioBufferConstructor,audioBufferSourceNodeConstructor,biquadFilterNodeConstructor,channelMergerNodeConstructor,channelSplitterNodeConstructor,constantSourceNodeConstructor,convolverNodeConstructor,decodeAudioData,delayNodeConstructor,dynamicsCompressorNodeConstructor,gainNodeConstructor,iIRFilterNodeConstructor,minimalBaseAudioContextConstructor,oscillatorNodeConstructor,pannerNodeConstructor,periodicWaveConstructor,stereoPannerNodeConstructor,waveShaperNodeConstructor),mediaElementAudioSourceNodeConstructor=createMediaElementAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaElementAudioSourceNode,getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioDestinationNodeConstructor=createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor,createNativeMediaStreamAudioDestinationNode,getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioSourceNodeConstructor=createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaStreamAudioSourceNode,getNativeContext,isNativeOfflineAudioContext),createNativeMediaStreamTrackAudioSourceNode=createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError,isNativeOfflineAudioContext),mediaStreamTrackAudioSourceNodeConstructor=createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor,createNativeMediaStreamTrackAudioSourceNode,getNativeContext),audioContextConstructor=createAudioContextConstructor(baseAudioContextConstructor,createInvalidStateError,createNotSupportedError,createUnknownError,mediaElementAudioSourceNodeConstructor,mediaStreamAudioDestinationNodeConstructor,mediaStreamAudioSourceNodeConstructor,mediaStreamTrackAudioSourceNodeConstructor,nativeAudioContextConstructor),getUnrenderedAudioWorkletNodes=createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore),addUnrenderedAudioWorkletNode=createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes),connectMultipleOutputs=createConnectMultipleOutputs(createIndexSizeError),deleteUnrenderedAudioWorkletNode=createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes),disconnectMultipleOutputs=createDisconnectMultipleOutputs(createIndexSizeError),activeAudioWorkletNodeInputsStore=new WeakMap,getActiveAudioWorkletNodeInputs=createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore,getValueForKey),createNativeAudioWorkletNodeFaker=createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs,createIndexSizeError,createInvalidStateError,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,createNativeScriptProcessorNode,createNotSupportedError,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getActiveAudioWorkletNodeInputs,monitorConnections),createNativeAudioWorkletNode=createNativeAudioWorkletNodeFactory(createInvalidStateError,createNativeAudioWorkletNodeFaker,createNativeGainNode,createNotSupportedError,monitorConnections),createAudioWorkletNodeRenderer=createAudioWorkletNodeRendererFactory(connectAudioParam,connectMultipleOutputs,createNativeAudioBufferSourceNode,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,deleteUnrenderedAudioWorkletNode,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getNativeAudioNode,nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),getBackupOfflineAudioContext=createGetBackupOfflineAudioContext(backupOfflineAudioContextStore),setActiveAudioWorkletNodeInputs=createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore),audioWorkletNodeConstructor=isSecureContext?createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode,audioNodeConstructor,createAudioParam,createAudioWorkletNodeRenderer,createNativeAudioWorkletNode,getAudioNodeConnections,getBackupOfflineAudioContext,getNativeContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,sanitizeAudioWorkletNodeOptions,setActiveAudioWorkletNodeInputs,testAudioWorkletNodeOptionsClonability,wrapEventListener):void 0,createNativeOfflineAudioContext=createCreateNativeOfflineAudioContext(createNotSupportedError,nativeOfflineAudioContextConstructor),startRendering=createStartRendering(audioBufferStore,cacheTestResult,getAudioNodeRenderer,getUnrenderedAudioWorkletNodes,renderNativeOfflineAudioContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),offlineAudioContextConstructor=createOfflineAudioContextConstructor(baseAudioContextConstructor,cacheTestResult,createInvalidStateError,createNativeOfflineAudioContext,startRendering),isAnyAudioContext=createIsAnyAudioContext(CONTEXT_STORE,isNativeAudioContext),isAnyAudioNode=createIsAnyAudioNode(AUDIO_NODE_STORE,isNativeAudioNode),isAnyAudioParam=createIsAnyAudioParam(AUDIO_PARAM_STORE,isNativeAudioParam),isAnyOfflineAudioContext=createIsAnyOfflineAudioContext(CONTEXT_STORE,isNativeOfflineAudioContext);function assert(c,i){if(!c)throw new Error(i)}function assertRange(c,i,s=1/0){if(!(i<=c&&c<=s))throw new RangeError(`Value must be within [${i}, ${s}], got: ${c}`)}function assertContextRunning(c){!c.isOffline&&c.state!=="running"&&warn('The AudioContext is "suspended". Invoke Tone.start() from a user action to start the audio.')}let defaultLogger=console;function log(...c){defaultLogger.log(...c)}function warn(...c){defaultLogger.warn(...c)}function isUndef(c){return typeof c>"u"}function isDefined(c){return!isUndef(c)}function isFunction(c){return typeof c=="function"}function isNumber(c){return typeof c=="number"}function isObject(c){return Object.prototype.toString.call(c)==="[object Object]"&&c.constructor===Object}function isBoolean(c){return typeof c=="boolean"}function isArray(c){return Array.isArray(c)}function isString(c){return typeof c=="string"}function isNote(c){return isString(c)&&/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(c)}function createAudioContext(c){return new audioContextConstructor(c)}function createOfflineAudioContext(c,i,s){return new offlineAudioContextConstructor(c,i,s)}const theWindow=typeof self=="object"?self:null,hasAudioContext=theWindow&&(theWindow.hasOwnProperty("AudioContext")||theWindow.hasOwnProperty("webkitAudioContext"));function createAudioWorkletNode(c,i,s){return assert(isDefined(audioWorkletNodeConstructor),"This node only works in a secure context (https or localhost)"),new audioWorkletNodeConstructor(c,i,s)}function __decorate(c,i,s,a){var u=arguments.length,l=u<3?i:a===null?a=Object.getOwnPropertyDescriptor(i,s):a,h;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")l=Reflect.decorate(c,i,s,a);else for(var f=c.length-1;f>=0;f--)(h=c[f])&&(l=(u<3?h(l):u>3?h(i,s,l):h(i,s))||l);return u>3&&l&&Object.defineProperty(i,s,l),l}function __awaiter(c,i,s,a){function u(l){return l instanceof s?l:new s(function(h){h(l)})}return new(s||(s=Promise))(function(l,h){function f(g){try{p(a.next(g))}catch(m){h(m)}}function d(g){try{p(a.throw(g))}catch(m){h(m)}}function p(g){g.done?l(g.value):u(g.value).then(f,d)}p((a=a.apply(c,i||[])).next())})}class Ticker{constructor(i,s,a){this._callback=i,this._type=s,this._updateInterval=a,this._createClock()}_createWorker(){const i=new Blob([`
			// the initial timeout time
			let timeoutTime =  ${(this._updateInterval*1e3).toFixed(1)};
			// onmessage callback
			self.onmessage = function(msg){
				timeoutTime = parseInt(msg.data);
			};
			// the tick function which posts a message
			// and schedules a new tick
			function tick(){
				setTimeout(tick, timeoutTime);
				self.postMessage('tick');
			}
			// call tick initially
			tick();
			`],{type:"text/javascript"}),s=URL.createObjectURL(i),a=new Worker(s);a.onmessage=this._callback.bind(this),this._worker=a}_createTimeout(){this._timeout=setTimeout(()=>{this._createTimeout(),this._callback()},this._updateInterval*1e3)}_createClock(){if(this._type==="worker")try{this._createWorker()}catch{this._type="timeout",this._createClock()}else this._type==="timeout"&&this._createTimeout()}_disposeClock(){this._timeout&&(clearTimeout(this._timeout),this._timeout=0),this._worker&&(this._worker.terminate(),this._worker.onmessage=null)}get updateInterval(){return this._updateInterval}set updateInterval(i){this._updateInterval=Math.max(i,128/44100),this._type==="worker"&&this._worker.postMessage(Math.max(i*1e3,1))}get type(){return this._type}set type(i){this._disposeClock(),this._type=i,this._createClock()}dispose(){this._disposeClock()}}function isAudioParam(c){return isAnyAudioParam(c)}function isAudioNode(c){return isAnyAudioNode(c)}function isOfflineAudioContext(c){return isAnyOfflineAudioContext(c)}function isAudioContext(c){return isAnyAudioContext(c)}function isAudioBuffer(c){return c instanceof AudioBuffer}function noCopy(c,i){return c==="value"||isAudioParam(i)||isAudioNode(i)||isAudioBuffer(i)}function deepMerge(c,...i){if(!i.length)return c;const s=i.shift();if(isObject(c)&&isObject(s))for(const a in s)noCopy(a,s[a])?c[a]=s[a]:isObject(s[a])?(c[a]||Object.assign(c,{[a]:{}}),deepMerge(c[a],s[a])):Object.assign(c,{[a]:s[a]});return deepMerge(c,...i)}function deepEquals(c,i){return c.length===i.length&&c.every((s,a)=>i[a]===s)}function optionsFromArguments(c,i,s=[],a){const u={},l=Array.from(i);if(isObject(l[0])&&a&&!Reflect.has(l[0],a)&&(Object.keys(l[0]).some(f=>Reflect.has(c,f))||(deepMerge(u,{[a]:l[0]}),s.splice(s.indexOf(a),1),l.shift())),l.length===1&&isObject(l[0]))deepMerge(u,l[0]);else for(let h=0;h<s.length;h++)isDefined(l[h])&&(u[s[h]]=l[h]);return deepMerge(c,u)}function getDefaultsFromInstance(c){return c.constructor.getDefaults()}function defaultArg(c,i){return isUndef(c)?i:c}function omitFromObject(c,i){return i.forEach(s=>{Reflect.has(c,s)&&delete c[s]}),c}/**
 * Tone.js
 * @author Yotam Mann
 * @license http://opensource.org/licenses/MIT MIT License
 * @copyright 2014-2019 Yotam Mann
 */class Tone{constructor(){this.debug=!1,this._wasDisposed=!1}static getDefaults(){return{}}log(...i){(this.debug||theWindow&&this.toString()===theWindow.TONE_DEBUG_CLASS)&&log(this,...i)}dispose(){return this._wasDisposed=!0,this}get disposed(){return this._wasDisposed}toString(){return this.name}}Tone.version=version;const EPSILON=1e-6;function GT(c,i){return c>i+EPSILON}function GTE(c,i){return GT(c,i)||EQ(c,i)}function LT(c,i){return c+EPSILON<i}function EQ(c,i){return Math.abs(c-i)<EPSILON}function clamp(c,i,s){return Math.max(Math.min(c,s),i)}class Timeline extends Tone{constructor(){super(),this.name="Timeline",this._timeline=[];const i=optionsFromArguments(Timeline.getDefaults(),arguments,["memory"]);this.memory=i.memory,this.increasing=i.increasing}static getDefaults(){return{memory:1/0,increasing:!1}}get length(){return this._timeline.length}add(i){if(assert(Reflect.has(i,"time"),"Timeline: events must have a time attribute"),i.time=i.time.valueOf(),this.increasing&&this.length){const s=this._timeline[this.length-1];assert(GTE(i.time,s.time),"The time must be greater than or equal to the last scheduled time"),this._timeline.push(i)}else{const s=this._search(i.time);this._timeline.splice(s+1,0,i)}if(this.length>this.memory){const s=this.length-this.memory;this._timeline.splice(0,s)}return this}remove(i){const s=this._timeline.indexOf(i);return s!==-1&&this._timeline.splice(s,1),this}get(i,s="time"){const a=this._search(i,s);return a!==-1?this._timeline[a]:null}peek(){return this._timeline[0]}shift(){return this._timeline.shift()}getAfter(i,s="time"){const a=this._search(i,s);return a+1<this._timeline.length?this._timeline[a+1]:null}getBefore(i){const s=this._timeline.length;if(s>0&&this._timeline[s-1].time<i)return this._timeline[s-1];const a=this._search(i);return a-1>=0?this._timeline[a-1]:null}cancel(i){if(this._timeline.length>1){let s=this._search(i);if(s>=0)if(EQ(this._timeline[s].time,i)){for(let a=s;a>=0&&EQ(this._timeline[a].time,i);a--)s=a;this._timeline=this._timeline.slice(0,s)}else this._timeline=this._timeline.slice(0,s+1);else this._timeline=[]}else this._timeline.length===1&&GTE(this._timeline[0].time,i)&&(this._timeline=[]);return this}cancelBefore(i){const s=this._search(i);return s>=0&&(this._timeline=this._timeline.slice(s+1)),this}previousEvent(i){const s=this._timeline.indexOf(i);return s>0?this._timeline[s-1]:null}_search(i,s="time"){if(this._timeline.length===0)return-1;let a=0;const u=this._timeline.length;let l=u;if(u>0&&this._timeline[u-1][s]<=i)return u-1;for(;a<l;){let h=Math.floor(a+(l-a)/2);const f=this._timeline[h],d=this._timeline[h+1];if(EQ(f[s],i)){for(let p=h;p<this._timeline.length;p++){const g=this._timeline[p];if(EQ(g[s],i))h=p;else break}return h}else{if(LT(f[s],i)&&GT(d[s],i))return h;GT(f[s],i)?l=h:a=h+1}}return-1}_iterate(i,s=0,a=this._timeline.length-1){this._timeline.slice(s,a+1).forEach(i)}forEach(i){return this._iterate(i),this}forEachBefore(i,s){const a=this._search(i);return a!==-1&&this._iterate(s,0,a),this}forEachAfter(i,s){const a=this._search(i);return this._iterate(s,a+1),this}forEachBetween(i,s,a){let u=this._search(i),l=this._search(s);return u!==-1&&l!==-1?(this._timeline[u].time!==i&&(u+=1),this._timeline[l].time===s&&(l-=1),this._iterate(a,u,l)):u===-1&&this._iterate(a,0,l),this}forEachFrom(i,s){let a=this._search(i);for(;a>=0&&this._timeline[a].time>=i;)a--;return this._iterate(s,a+1),this}forEachAtTime(i,s){const a=this._search(i);if(a!==-1&&EQ(this._timeline[a].time,i)){let u=a;for(let l=a;l>=0&&EQ(this._timeline[l].time,i);l--)u=l;this._iterate(l=>{s(l)},u,a)}return this}dispose(){return super.dispose(),this._timeline=[],this}}const notifyNewContext=[];function onContextInit(c){notifyNewContext.push(c)}function initializeContext(c){notifyNewContext.forEach(i=>i(c))}const notifyCloseContext=[];function onContextClose(c){notifyCloseContext.push(c)}function closeContext(c){notifyCloseContext.forEach(i=>i(c))}class Emitter extends Tone{constructor(){super(...arguments),this.name="Emitter"}on(i,s){return i.split(/\W+/).forEach(u=>{isUndef(this._events)&&(this._events={}),this._events.hasOwnProperty(u)||(this._events[u]=[]),this._events[u].push(s)}),this}once(i,s){const a=(...u)=>{s(...u),this.off(i,a)};return this.on(i,a),this}off(i,s){return i.split(/\W+/).forEach(u=>{if(isUndef(this._events)&&(this._events={}),this._events.hasOwnProperty(i))if(isUndef(s))this._events[i]=[];else{const l=this._events[i];for(let h=l.length-1;h>=0;h--)l[h]===s&&l.splice(h,1)}}),this}emit(i,...s){if(this._events&&this._events.hasOwnProperty(i)){const a=this._events[i].slice(0);for(let u=0,l=a.length;u<l;u++)a[u].apply(this,s)}return this}static mixin(i){["on","once","off","emit"].forEach(s=>{const a=Object.getOwnPropertyDescriptor(Emitter.prototype,s);Object.defineProperty(i.prototype,s,a)})}dispose(){return super.dispose(),this._events=void 0,this}}class BaseContext extends Emitter{constructor(){super(...arguments),this.isOffline=!1}toJSON(){return{}}}class Context extends BaseContext{constructor(){super(),this.name="Context",this._constants=new Map,this._timeouts=new Timeline,this._timeoutIds=0,this._initialized=!1,this.isOffline=!1,this._workletModules=new Map;const i=optionsFromArguments(Context.getDefaults(),arguments,["context"]);i.context?this._context=i.context:this._context=createAudioContext({latencyHint:i.latencyHint}),this._ticker=new Ticker(this.emit.bind(this,"tick"),i.clockSource,i.updateInterval),this.on("tick",this._timeoutLoop.bind(this)),this._context.onstatechange=()=>{this.emit("statechange",this.state)},this._setLatencyHint(i.latencyHint),this.lookAhead=i.lookAhead}static getDefaults(){return{clockSource:"worker",latencyHint:"interactive",lookAhead:.1,updateInterval:.05}}initialize(){return this._initialized||(initializeContext(this),this._initialized=!0),this}createAnalyser(){return this._context.createAnalyser()}createOscillator(){return this._context.createOscillator()}createBufferSource(){return this._context.createBufferSource()}createBiquadFilter(){return this._context.createBiquadFilter()}createBuffer(i,s,a){return this._context.createBuffer(i,s,a)}createChannelMerger(i){return this._context.createChannelMerger(i)}createChannelSplitter(i){return this._context.createChannelSplitter(i)}createConstantSource(){return this._context.createConstantSource()}createConvolver(){return this._context.createConvolver()}createDelay(i){return this._context.createDelay(i)}createDynamicsCompressor(){return this._context.createDynamicsCompressor()}createGain(){return this._context.createGain()}createIIRFilter(i,s){return this._context.createIIRFilter(i,s)}createPanner(){return this._context.createPanner()}createPeriodicWave(i,s,a){return this._context.createPeriodicWave(i,s,a)}createStereoPanner(){return this._context.createStereoPanner()}createWaveShaper(){return this._context.createWaveShaper()}createMediaStreamSource(i){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamSource(i)}createMediaElementSource(i){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaElementSource(i)}createMediaStreamDestination(){return assert(isAudioContext(this._context),"Not available if OfflineAudioContext"),this._context.createMediaStreamDestination()}decodeAudioData(i){return this._context.decodeAudioData(i)}get currentTime(){return this._context.currentTime}get state(){return this._context.state}get sampleRate(){return this._context.sampleRate}get listener(){return this.initialize(),this._listener}set listener(i){assert(!this._initialized,"The listener cannot be set after initialization."),this._listener=i}get transport(){return this.initialize(),this._transport}set transport(i){assert(!this._initialized,"The transport cannot be set after initialization."),this._transport=i}get draw(){return this.initialize(),this._draw}set draw(i){assert(!this._initialized,"Draw cannot be set after initialization."),this._draw=i}get destination(){return this.initialize(),this._destination}set destination(i){assert(!this._initialized,"The destination cannot be set after initialization."),this._destination=i}createAudioWorkletNode(i,s){return createAudioWorkletNode(this.rawContext,i,s)}addAudioWorkletModule(i,s){return __awaiter(this,void 0,void 0,function*(){assert(isDefined(this.rawContext.audioWorklet),"AudioWorkletNode is only available in a secure context (https or localhost)"),this._workletModules.has(s)||this._workletModules.set(s,this.rawContext.audioWorklet.addModule(i)),yield this._workletModules.get(s)})}workletsAreReady(){return __awaiter(this,void 0,void 0,function*(){const i=[];this._workletModules.forEach(s=>i.push(s)),yield Promise.all(i)})}get updateInterval(){return this._ticker.updateInterval}set updateInterval(i){this._ticker.updateInterval=i}get clockSource(){return this._ticker.type}set clockSource(i){this._ticker.type=i}get latencyHint(){return this._latencyHint}_setLatencyHint(i){let s=0;if(this._latencyHint=i,isString(i))switch(i){case"interactive":s=.1;break;case"playback":s=.5;break;case"balanced":s=.25;break}this.lookAhead=s,this.updateInterval=s/2}get rawContext(){return this._context}now(){return this._context.currentTime+this.lookAhead}immediate(){return this._context.currentTime}resume(){return isAudioContext(this._context)?this._context.resume():Promise.resolve()}close(){return __awaiter(this,void 0,void 0,function*(){isAudioContext(this._context)&&(yield this._context.close()),this._initialized&&closeContext(this)})}getConstant(i){if(this._constants.has(i))return this._constants.get(i);{const s=this._context.createBuffer(1,128,this._context.sampleRate),a=s.getChannelData(0);for(let l=0;l<a.length;l++)a[l]=i;const u=this._context.createBufferSource();return u.channelCount=1,u.channelCountMode="explicit",u.buffer=s,u.loop=!0,u.start(0),this._constants.set(i,u),u}}dispose(){return super.dispose(),this._ticker.dispose(),this._timeouts.dispose(),Object.keys(this._constants).map(i=>this._constants[i].disconnect()),this}_timeoutLoop(){const i=this.now();let s=this._timeouts.peek();for(;this._timeouts.length&&s&&s.time<=i;)s.callback(),this._timeouts.shift(),s=this._timeouts.peek()}setTimeout(i,s){this._timeoutIds++;const a=this.now();return this._timeouts.add({callback:i,id:this._timeoutIds,time:a+s}),this._timeoutIds}clearTimeout(i){return this._timeouts.forEach(s=>{s.id===i&&this._timeouts.remove(s)}),this}clearInterval(i){return this.clearTimeout(i)}setInterval(i,s){const a=++this._timeoutIds,u=()=>{const l=this.now();this._timeouts.add({callback:()=>{i(),u()},id:a,time:l+s})};return u(),a}}class DummyContext extends BaseContext{constructor(){super(...arguments),this.lookAhead=0,this.latencyHint=0,this.isOffline=!1}createAnalyser(){return{}}createOscillator(){return{}}createBufferSource(){return{}}createBiquadFilter(){return{}}createBuffer(i,s,a){return{}}createChannelMerger(i){return{}}createChannelSplitter(i){return{}}createConstantSource(){return{}}createConvolver(){return{}}createDelay(i){return{}}createDynamicsCompressor(){return{}}createGain(){return{}}createIIRFilter(i,s){return{}}createPanner(){return{}}createPeriodicWave(i,s,a){return{}}createStereoPanner(){return{}}createWaveShaper(){return{}}createMediaStreamSource(i){return{}}createMediaElementSource(i){return{}}createMediaStreamDestination(){return{}}decodeAudioData(i){return Promise.resolve({})}createAudioWorkletNode(i,s){return{}}get rawContext(){return{}}addAudioWorkletModule(i,s){return __awaiter(this,void 0,void 0,function*(){return Promise.resolve()})}resume(){return Promise.resolve()}setTimeout(i,s){return 0}clearTimeout(i){return this}setInterval(i,s){return 0}clearInterval(i){return this}getConstant(i){return{}}get currentTime(){return 0}get state(){return{}}get sampleRate(){return 0}get listener(){return{}}get transport(){return{}}get draw(){return{}}set draw(i){}get destination(){return{}}set destination(i){}now(){return 0}immediate(){return 0}}function readOnly(c,i){isArray(i)?i.forEach(s=>readOnly(c,s)):Object.defineProperty(c,i,{enumerable:!0,writable:!1})}function writable(c,i){isArray(i)?i.forEach(s=>writable(c,s)):Object.defineProperty(c,i,{writable:!0})}const noOp=()=>{};class ToneAudioBuffer extends Tone{constructor(){super(),this.name="ToneAudioBuffer",this.onload=noOp;const i=optionsFromArguments(ToneAudioBuffer.getDefaults(),arguments,["url","onload","onerror"]);this.reverse=i.reverse,this.onload=i.onload,i.url&&isAudioBuffer(i.url)||i.url instanceof ToneAudioBuffer?this.set(i.url):isString(i.url)&&this.load(i.url).catch(i.onerror)}static getDefaults(){return{onerror:noOp,onload:noOp,reverse:!1}}get sampleRate(){return this._buffer?this._buffer.sampleRate:getContext().sampleRate}set(i){return i instanceof ToneAudioBuffer?i.loaded?this._buffer=i.get():i.onload=()=>{this.set(i),this.onload(this)}:this._buffer=i,this._reversed&&this._reverse(),this}get(){return this._buffer}load(i){return __awaiter(this,void 0,void 0,function*(){const s=ToneAudioBuffer.load(i).then(a=>{this.set(a),this.onload(this)});ToneAudioBuffer.downloads.push(s);try{yield s}finally{const a=ToneAudioBuffer.downloads.indexOf(s);ToneAudioBuffer.downloads.splice(a,1)}return this})}dispose(){return super.dispose(),this._buffer=void 0,this}fromArray(i){const s=isArray(i)&&i[0].length>0,a=s?i.length:1,u=s?i[0].length:i.length,l=getContext(),h=l.createBuffer(a,u,l.sampleRate),f=!s&&a===1?[i]:i;for(let d=0;d<a;d++)h.copyToChannel(f[d],d);return this._buffer=h,this}toMono(i){if(isNumber(i))this.fromArray(this.toArray(i));else{let s=new Float32Array(this.length);const a=this.numberOfChannels;for(let u=0;u<a;u++){const l=this.toArray(u);for(let h=0;h<l.length;h++)s[h]+=l[h]}s=s.map(u=>u/a),this.fromArray(s)}return this}toArray(i){if(isNumber(i))return this.getChannelData(i);if(this.numberOfChannels===1)return this.toArray(0);{const s=[];for(let a=0;a<this.numberOfChannels;a++)s[a]=this.getChannelData(a);return s}}getChannelData(i){return this._buffer?this._buffer.getChannelData(i):new Float32Array(0)}slice(i,s=this.duration){const a=Math.floor(i*this.sampleRate),u=Math.floor(s*this.sampleRate);assert(a<u,"The start time must be less than the end time");const l=u-a,h=getContext().createBuffer(this.numberOfChannels,l,this.sampleRate);for(let f=0;f<this.numberOfChannels;f++)h.copyToChannel(this.getChannelData(f).subarray(a,u),f);return new ToneAudioBuffer(h)}_reverse(){if(this.loaded)for(let i=0;i<this.numberOfChannels;i++)this.getChannelData(i).reverse();return this}get loaded(){return this.length>0}get duration(){return this._buffer?this._buffer.duration:0}get length(){return this._buffer?this._buffer.length:0}get numberOfChannels(){return this._buffer?this._buffer.numberOfChannels:0}get reverse(){return this._reversed}set reverse(i){this._reversed!==i&&(this._reversed=i,this._reverse())}static fromArray(i){return new ToneAudioBuffer().fromArray(i)}static fromUrl(i){return __awaiter(this,void 0,void 0,function*(){return yield new ToneAudioBuffer().load(i)})}static load(i){return __awaiter(this,void 0,void 0,function*(){const s=i.match(/\[([^\]\[]+\|.+)\]$/);if(s){const f=s[1].split("|");let d=f[0];for(const p of f)if(ToneAudioBuffer.supportsType(p)){d=p;break}i=i.replace(s[0],d)}const a=ToneAudioBuffer.baseUrl===""||ToneAudioBuffer.baseUrl.endsWith("/")?ToneAudioBuffer.baseUrl:ToneAudioBuffer.baseUrl+"/",u=yield fetch(a+i);if(!u.ok)throw new Error(`could not load url: ${i}`);const l=yield u.arrayBuffer();return yield getContext().decodeAudioData(l)})}static supportsType(i){const s=i.split("."),a=s[s.length-1];return document.createElement("audio").canPlayType("audio/"+a)!==""}static loaded(){return __awaiter(this,void 0,void 0,function*(){for(yield Promise.resolve();ToneAudioBuffer.downloads.length;)yield ToneAudioBuffer.downloads[0]})}}ToneAudioBuffer.baseUrl="";ToneAudioBuffer.downloads=[];class OfflineContext extends Context{constructor(){super({clockSource:"offline",context:isOfflineAudioContext(arguments[0])?arguments[0]:createOfflineAudioContext(arguments[0],arguments[1]*arguments[2],arguments[2]),lookAhead:0,updateInterval:isOfflineAudioContext(arguments[0])?128/arguments[0].sampleRate:128/arguments[2]}),this.name="OfflineContext",this._currentTime=0,this.isOffline=!0,this._duration=isOfflineAudioContext(arguments[0])?arguments[0].length/arguments[0].sampleRate:arguments[1]}now(){return this._currentTime}get currentTime(){return this._currentTime}_renderClock(i){return __awaiter(this,void 0,void 0,function*(){let s=0;for(;this._duration-this._currentTime>=0;){this.emit("tick"),this._currentTime+=128/this.sampleRate,s++;const a=Math.floor(this.sampleRate/128);i&&s%a===0&&(yield new Promise(u=>setTimeout(u,1)))}})}render(i=!0){return __awaiter(this,void 0,void 0,function*(){yield this.workletsAreReady(),yield this._renderClock(i);const s=yield this._context.startRendering();return new ToneAudioBuffer(s)})}close(){return Promise.resolve()}}const dummyContext=new DummyContext;let globalContext=dummyContext;function getContext(){return globalContext===dummyContext&&hasAudioContext&&setContext(new Context),globalContext}function setContext(c){isAudioContext(c)?globalContext=new Context(c):isOfflineAudioContext(c)?globalContext=new OfflineContext(c):globalContext=c}if(theWindow&&!theWindow.TONE_SILENCE_LOGGING){const i=` * Tone.js v${version} * `;console.log(`%c${i}`,"background: #000; color: #fff")}function dbToGain(c){return Math.pow(10,c/20)}function gainToDb(c){return 20*(Math.log(c)/Math.LN10)}function intervalToFrequencyRatio(c){return Math.pow(2,c/12)}let A4=440;function getA4(){return A4}function setA4(c){A4=c}function ftom(c){return Math.round(ftomf(c))}function ftomf(c){return 69+12*Math.log2(c/A4)}function mtof(c){return A4*Math.pow(2,(c-69)/12)}class TimeBaseClass extends Tone{constructor(i,s,a){super(),this.defaultUnits="s",this._val=s,this._units=a,this.context=i,this._expressions=this._getExpressions()}_getExpressions(){return{hz:{method:i=>this._frequencyToUnits(parseFloat(i)),regexp:/^(\d+(?:\.\d+)?)hz$/i},i:{method:i=>this._ticksToUnits(parseInt(i,10)),regexp:/^(\d+)i$/i},m:{method:i=>this._beatsToUnits(parseInt(i,10)*this._getTimeSignature()),regexp:/^(\d+)m$/i},n:{method:(i,s)=>{const a=parseInt(i,10),u=s==="."?1.5:1;return a===1?this._beatsToUnits(this._getTimeSignature())*u:this._beatsToUnits(4/a)*u},regexp:/^(\d+)n(\.?)$/i},number:{method:i=>this._expressions[this.defaultUnits].method.call(this,i),regexp:/^(\d+(?:\.\d+)?)$/},s:{method:i=>this._secondsToUnits(parseFloat(i)),regexp:/^(\d+(?:\.\d+)?)s$/},samples:{method:i=>parseInt(i,10)/this.context.sampleRate,regexp:/^(\d+)samples$/},t:{method:i=>{const s=parseInt(i,10);return this._beatsToUnits(8/(Math.floor(s)*3))},regexp:/^(\d+)t$/i},tr:{method:(i,s,a)=>{let u=0;return i&&i!=="0"&&(u+=this._beatsToUnits(this._getTimeSignature()*parseFloat(i))),s&&s!=="0"&&(u+=this._beatsToUnits(parseFloat(s))),a&&a!=="0"&&(u+=this._beatsToUnits(parseFloat(a)/4)),u},regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?$/}}}valueOf(){if(this._val instanceof TimeBaseClass&&this.fromType(this._val),isUndef(this._val))return this._noArg();if(isString(this._val)&&isUndef(this._units)){for(const i in this._expressions)if(this._expressions[i].regexp.test(this._val.trim())){this._units=i;break}}else if(isObject(this._val)){let i=0;for(const s in this._val)if(isDefined(this._val[s])){const a=this._val[s],u=new this.constructor(this.context,s).valueOf()*a;i+=u}return i}if(isDefined(this._units)){const i=this._expressions[this._units],s=this._val.toString().trim().match(i.regexp);return s?i.method.apply(this,s.slice(1)):i.method.call(this,this._val)}else return isString(this._val)?parseFloat(this._val):this._val}_frequencyToUnits(i){return 1/i}_beatsToUnits(i){return 60/this._getBpm()*i}_secondsToUnits(i){return i}_ticksToUnits(i){return i*this._beatsToUnits(1)/this._getPPQ()}_noArg(){return this._now()}_getBpm(){return this.context.transport.bpm.value}_getTimeSignature(){return this.context.transport.timeSignature}_getPPQ(){return this.context.transport.PPQ}fromType(i){switch(this._units=void 0,this.defaultUnits){case"s":this._val=i.toSeconds();break;case"i":this._val=i.toTicks();break;case"hz":this._val=i.toFrequency();break;case"midi":this._val=i.toMidi();break}return this}toFrequency(){return 1/this.toSeconds()}toSamples(){return this.toSeconds()*this.context.sampleRate}toMilliseconds(){return this.toSeconds()*1e3}}class TimeClass extends TimeBaseClass{constructor(){super(...arguments),this.name="TimeClass"}_getExpressions(){return Object.assign(super._getExpressions(),{now:{method:i=>this._now()+new this.constructor(this.context,i).valueOf(),regexp:/^\+(.+)/},quantize:{method:i=>{const s=new TimeClass(this.context,i).valueOf();return this._secondsToUnits(this.context.transport.nextSubdivision(s))},regexp:/^@(.+)/}})}quantize(i,s=1){const a=new this.constructor(this.context,i).valueOf(),u=this.valueOf(),f=Math.round(u/a)*a-u;return u+f*s}toNotation(){const i=this.toSeconds(),s=["1m"];for(let l=1;l<9;l++){const h=Math.pow(2,l);s.push(h+"n."),s.push(h+"n"),s.push(h+"t")}s.push("0");let a=s[0],u=new TimeClass(this.context,s[0]).toSeconds();return s.forEach(l=>{const h=new TimeClass(this.context,l).toSeconds();Math.abs(h-i)<Math.abs(u-i)&&(a=l,u=h)}),a}toBarsBeatsSixteenths(){const i=this._beatsToUnits(1);let s=this.valueOf()/i;s=parseFloat(s.toFixed(4));const a=Math.floor(s/this._getTimeSignature());let u=s%1*4;s=Math.floor(s)%this._getTimeSignature();const l=u.toString();return l.length>3&&(u=parseFloat(parseFloat(l).toFixed(3))),[a,s,u].join(":")}toTicks(){const i=this._beatsToUnits(1),s=this.valueOf()/i;return Math.round(s*this._getPPQ())}toSeconds(){return this.valueOf()}toMidi(){return ftom(this.toFrequency())}_now(){return this.context.now()}}class FrequencyClass extends TimeClass{constructor(){super(...arguments),this.name="Frequency",this.defaultUnits="hz"}static get A4(){return getA4()}static set A4(i){setA4(i)}_getExpressions(){return Object.assign({},super._getExpressions(),{midi:{regexp:/^(\d+(?:\.\d+)?midi)/,method(i){return this.defaultUnits==="midi"?i:FrequencyClass.mtof(i)}},note:{regexp:/^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,method(i,s){const u=noteToScaleIndex[i.toLowerCase()]+(parseInt(s,10)+1)*12;return this.defaultUnits==="midi"?u:FrequencyClass.mtof(u)}},tr:{regexp:/^(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):?(\d+(?:\.\d+)?)?/,method(i,s,a){let u=1;return i&&i!=="0"&&(u*=this._beatsToUnits(this._getTimeSignature()*parseFloat(i))),s&&s!=="0"&&(u*=this._beatsToUnits(parseFloat(s))),a&&a!=="0"&&(u*=this._beatsToUnits(parseFloat(a)/4)),u}}})}transpose(i){return new FrequencyClass(this.context,this.valueOf()*intervalToFrequencyRatio(i))}harmonize(i){return i.map(s=>this.transpose(s))}toMidi(){return ftom(this.valueOf())}toNote(){const i=this.toFrequency(),s=Math.log2(i/FrequencyClass.A4);let a=Math.round(12*s)+57;const u=Math.floor(a/12);return u<0&&(a+=-12*u),scaleIndexToNote[a%12]+u.toString()}toSeconds(){return 1/super.toSeconds()}toTicks(){const i=this._beatsToUnits(1),s=this.valueOf()/i;return Math.floor(s*this._getPPQ())}_noArg(){return 0}_frequencyToUnits(i){return i}_ticksToUnits(i){return 1/(i*60/(this._getBpm()*this._getPPQ()))}_beatsToUnits(i){return 1/super._beatsToUnits(i)}_secondsToUnits(i){return 1/i}static mtof(i){return mtof(i)}static ftom(i){return ftom(i)}}const noteToScaleIndex={cbb:-2,cb:-1,c:0,"c#":1,cx:2,dbb:0,db:1,d:2,"d#":3,dx:4,ebb:2,eb:3,e:4,"e#":5,ex:6,fbb:3,fb:4,f:5,"f#":6,fx:7,gbb:5,gb:6,g:7,"g#":8,gx:9,abb:7,ab:8,a:9,"a#":10,ax:11,bbb:9,bb:10,b:11,"b#":12,bx:13},scaleIndexToNote=["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];class TransportTimeClass extends TimeClass{constructor(){super(...arguments),this.name="TransportTime"}_now(){return this.context.transport.seconds}}class ToneWithContext extends Tone{constructor(){super();const i=optionsFromArguments(ToneWithContext.getDefaults(),arguments,["context"]);this.defaultContext?this.context=this.defaultContext:this.context=i.context}static getDefaults(){return{context:getContext()}}now(){return this.context.currentTime+this.context.lookAhead}immediate(){return this.context.currentTime}get sampleTime(){return 1/this.context.sampleRate}get blockTime(){return 128/this.context.sampleRate}toSeconds(i){return new TimeClass(this.context,i).toSeconds()}toFrequency(i){return new FrequencyClass(this.context,i).toFrequency()}toTicks(i){return new TransportTimeClass(this.context,i).toTicks()}_getPartialProperties(i){const s=this.get();return Object.keys(s).forEach(a=>{isUndef(i[a])&&delete s[a]}),s}get(){const i=getDefaultsFromInstance(this);return Object.keys(i).forEach(s=>{if(Reflect.has(this,s)){const a=this[s];isDefined(a)&&isDefined(a.value)&&isDefined(a.setValueAtTime)?i[s]=a.value:a instanceof ToneWithContext?i[s]=a._getPartialProperties(i[s]):isArray(a)||isNumber(a)||isString(a)||isBoolean(a)?i[s]=a:delete i[s]}}),i}set(i){return Object.keys(i).forEach(s=>{Reflect.has(this,s)&&isDefined(this[s])&&(this[s]&&isDefined(this[s].value)&&isDefined(this[s].setValueAtTime)?this[s].value!==i[s]&&(this[s].value=i[s]):this[s]instanceof ToneWithContext?this[s].set(i[s]):this[s]=i[s])}),this}}class StateTimeline extends Timeline{constructor(i="stopped"){super(),this.name="StateTimeline",this._initial=i,this.setStateAtTime(this._initial,0)}getValueAtTime(i){const s=this.get(i);return s!==null?s.state:this._initial}setStateAtTime(i,s,a){return assertRange(s,0),this.add(Object.assign({},a,{state:i,time:s})),this}getLastState(i,s){const a=this._search(s);for(let u=a;u>=0;u--){const l=this._timeline[u];if(l.state===i)return l}}getNextState(i,s){const a=this._search(s);if(a!==-1)for(let u=a;u<this._timeline.length;u++){const l=this._timeline[u];if(l.state===i)return l}}}class Param extends ToneWithContext{constructor(){super(optionsFromArguments(Param.getDefaults(),arguments,["param","units","convert"])),this.name="Param",this.overridden=!1,this._minOutput=1e-7;const i=optionsFromArguments(Param.getDefaults(),arguments,["param","units","convert"]);for(assert(isDefined(i.param)&&(isAudioParam(i.param)||i.param instanceof Param),"param must be an AudioParam");!isAudioParam(i.param);)i.param=i.param._param;this._swappable=isDefined(i.swappable)?i.swappable:!1,this._swappable?(this.input=this.context.createGain(),this._param=i.param,this.input.connect(this._param)):this._param=this.input=i.param,this._events=new Timeline(1e3),this._initialValue=this._param.defaultValue,this.units=i.units,this.convert=i.convert,this._minValue=i.minValue,this._maxValue=i.maxValue,isDefined(i.value)&&i.value!==this._toType(this._initialValue)&&this.setValueAtTime(i.value,0)}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{convert:!0,units:"number"})}get value(){const i=this.now();return this.getValueAtTime(i)}set value(i){this.cancelScheduledValues(this.now()),this.setValueAtTime(i,this.now())}get minValue(){return isDefined(this._minValue)?this._minValue:this.units==="time"||this.units==="frequency"||this.units==="normalRange"||this.units==="positive"||this.units==="transportTime"||this.units==="ticks"||this.units==="bpm"||this.units==="hertz"||this.units==="samples"?0:this.units==="audioRange"?-1:this.units==="decibels"?-1/0:this._param.minValue}get maxValue(){return isDefined(this._maxValue)?this._maxValue:this.units==="normalRange"||this.units==="audioRange"?1:this._param.maxValue}_is(i,s){return this.units===s}_assertRange(i){return isDefined(this.maxValue)&&isDefined(this.minValue)&&assertRange(i,this._fromType(this.minValue),this._fromType(this.maxValue)),i}_fromType(i){return this.convert&&!this.overridden?this._is(i,"time")?this.toSeconds(i):this._is(i,"decibels")?dbToGain(i):this._is(i,"frequency")?this.toFrequency(i):i:this.overridden?0:i}_toType(i){return this.convert&&this.units==="decibels"?gainToDb(i):i}setValueAtTime(i,s){const a=this.toSeconds(s),u=this._fromType(i);return assert(isFinite(u)&&isFinite(a),`Invalid argument(s) to setValueAtTime: ${JSON.stringify(i)}, ${JSON.stringify(s)}`),this._assertRange(u),this.log(this.units,"setValueAtTime",i,a),this._events.add({time:a,type:"setValueAtTime",value:u}),this._param.setValueAtTime(u,a),this}getValueAtTime(i){const s=Math.max(this.toSeconds(i),0),a=this._events.getAfter(s),u=this._events.get(s);let l=this._initialValue;if(u===null)l=this._initialValue;else if(u.type==="setTargetAtTime"&&(a===null||a.type==="setValueAtTime")){const h=this._events.getBefore(u.time);let f;h===null?f=this._initialValue:f=h.value,u.type==="setTargetAtTime"&&(l=this._exponentialApproach(u.time,f,u.value,u.constant,s))}else if(a===null)l=u.value;else if(a.type==="linearRampToValueAtTime"||a.type==="exponentialRampToValueAtTime"){let h=u.value;if(u.type==="setTargetAtTime"){const f=this._events.getBefore(u.time);f===null?h=this._initialValue:h=f.value}a.type==="linearRampToValueAtTime"?l=this._linearInterpolate(u.time,h,a.time,a.value,s):l=this._exponentialInterpolate(u.time,h,a.time,a.value,s)}else l=u.value;return this._toType(l)}setRampPoint(i){i=this.toSeconds(i);let s=this.getValueAtTime(i);return this.cancelAndHoldAtTime(i),this._fromType(s)===0&&(s=this._toType(this._minOutput)),this.setValueAtTime(s,i),this}linearRampToValueAtTime(i,s){const a=this._fromType(i),u=this.toSeconds(s);return assert(isFinite(a)&&isFinite(u),`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(i)}, ${JSON.stringify(s)}`),this._assertRange(a),this._events.add({time:u,type:"linearRampToValueAtTime",value:a}),this.log(this.units,"linearRampToValueAtTime",i,u),this._param.linearRampToValueAtTime(a,u),this}exponentialRampToValueAtTime(i,s){let a=this._fromType(i);a=EQ(a,0)?this._minOutput:a,this._assertRange(a);const u=this.toSeconds(s);return assert(isFinite(a)&&isFinite(u),`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(i)}, ${JSON.stringify(s)}`),this._events.add({time:u,type:"exponentialRampToValueAtTime",value:a}),this.log(this.units,"exponentialRampToValueAtTime",i,u),this._param.exponentialRampToValueAtTime(a,u),this}exponentialRampTo(i,s,a){return a=this.toSeconds(a),this.setRampPoint(a),this.exponentialRampToValueAtTime(i,a+this.toSeconds(s)),this}linearRampTo(i,s,a){return a=this.toSeconds(a),this.setRampPoint(a),this.linearRampToValueAtTime(i,a+this.toSeconds(s)),this}targetRampTo(i,s,a){return a=this.toSeconds(a),this.setRampPoint(a),this.exponentialApproachValueAtTime(i,a,s),this}exponentialApproachValueAtTime(i,s,a){s=this.toSeconds(s),a=this.toSeconds(a);const u=Math.log(a+1)/Math.log(200);return this.setTargetAtTime(i,s,u),this.cancelAndHoldAtTime(s+a*.9),this.linearRampToValueAtTime(i,s+a),this}setTargetAtTime(i,s,a){const u=this._fromType(i);assert(isFinite(a)&&a>0,"timeConstant must be a number greater than 0");const l=this.toSeconds(s);return this._assertRange(u),assert(isFinite(u)&&isFinite(l),`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(i)}, ${JSON.stringify(s)}`),this._events.add({constant:a,time:l,type:"setTargetAtTime",value:u}),this.log(this.units,"setTargetAtTime",i,l,a),this._param.setTargetAtTime(u,l,a),this}setValueCurveAtTime(i,s,a,u=1){a=this.toSeconds(a),s=this.toSeconds(s);const l=this._fromType(i[0])*u;this.setValueAtTime(this._toType(l),s);const h=a/(i.length-1);for(let f=1;f<i.length;f++){const d=this._fromType(i[f])*u;this.linearRampToValueAtTime(this._toType(d),s+f*h)}return this}cancelScheduledValues(i){const s=this.toSeconds(i);return assert(isFinite(s),`Invalid argument to cancelScheduledValues: ${JSON.stringify(i)}`),this._events.cancel(s),this._param.cancelScheduledValues(s),this.log(this.units,"cancelScheduledValues",s),this}cancelAndHoldAtTime(i){const s=this.toSeconds(i),a=this._fromType(this.getValueAtTime(s));assert(isFinite(s),`Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(i)}`),this.log(this.units,"cancelAndHoldAtTime",s,"value="+a);const u=this._events.get(s),l=this._events.getAfter(s);return u&&EQ(u.time,s)?l?(this._param.cancelScheduledValues(l.time),this._events.cancel(l.time)):(this._param.cancelAndHoldAtTime(s),this._events.cancel(s+this.sampleTime)):l&&(this._param.cancelScheduledValues(l.time),this._events.cancel(l.time),l.type==="linearRampToValueAtTime"?this.linearRampToValueAtTime(this._toType(a),s):l.type==="exponentialRampToValueAtTime"&&this.exponentialRampToValueAtTime(this._toType(a),s)),this._events.add({time:s,type:"setValueAtTime",value:a}),this._param.setValueAtTime(a,s),this}rampTo(i,s=.1,a){return this.units==="frequency"||this.units==="bpm"||this.units==="decibels"?this.exponentialRampTo(i,s,a):this.linearRampTo(i,s,a),this}apply(i){const s=this.context.currentTime;i.setValueAtTime(this.getValueAtTime(s),s);const a=this._events.get(s);if(a&&a.type==="setTargetAtTime"){const u=this._events.getAfter(a.time),l=u?u.time:s+2,h=(l-s)/10;for(let f=s;f<l;f+=h)i.linearRampToValueAtTime(this.getValueAtTime(f),f)}return this._events.forEachAfter(this.context.currentTime,u=>{u.type==="cancelScheduledValues"?i.cancelScheduledValues(u.time):u.type==="setTargetAtTime"?i.setTargetAtTime(u.value,u.time,u.constant):i[u.type](u.value,u.time)}),this}setParam(i){assert(this._swappable,"The Param must be assigned as 'swappable' in the constructor");const s=this.input;return s.disconnect(this._param),this.apply(i),this._param=i,s.connect(this._param),this}dispose(){return super.dispose(),this._events.dispose(),this}get defaultValue(){return this._toType(this._param.defaultValue)}_exponentialApproach(i,s,a,u,l){return a+(s-a)*Math.exp(-(l-i)/u)}_linearInterpolate(i,s,a,u,l){return s+(u-s)*((l-i)/(a-i))}_exponentialInterpolate(i,s,a,u,l){return s*Math.pow(u/s,(l-i)/(a-i))}}class ToneAudioNode extends ToneWithContext{constructor(){super(...arguments),this.name="ToneAudioNode",this._internalChannels=[]}get numberOfInputs(){return isDefined(this.input)?isAudioParam(this.input)||this.input instanceof Param?1:this.input.numberOfInputs:0}get numberOfOutputs(){return isDefined(this.output)?this.output.numberOfOutputs:0}_isAudioNode(i){return isDefined(i)&&(i instanceof ToneAudioNode||isAudioNode(i))}_getInternalNodes(){const i=this._internalChannels.slice(0);return this._isAudioNode(this.input)&&i.push(this.input),this._isAudioNode(this.output)&&this.input!==this.output&&i.push(this.output),i}_setChannelProperties(i){this._getInternalNodes().forEach(a=>{a.channelCount=i.channelCount,a.channelCountMode=i.channelCountMode,a.channelInterpretation=i.channelInterpretation})}_getChannelProperties(){const i=this._getInternalNodes();assert(i.length>0,"ToneAudioNode does not have any internal nodes");const s=i[0];return{channelCount:s.channelCount,channelCountMode:s.channelCountMode,channelInterpretation:s.channelInterpretation}}get channelCount(){return this._getChannelProperties().channelCount}set channelCount(i){const s=this._getChannelProperties();this._setChannelProperties(Object.assign(s,{channelCount:i}))}get channelCountMode(){return this._getChannelProperties().channelCountMode}set channelCountMode(i){const s=this._getChannelProperties();this._setChannelProperties(Object.assign(s,{channelCountMode:i}))}get channelInterpretation(){return this._getChannelProperties().channelInterpretation}set channelInterpretation(i){const s=this._getChannelProperties();this._setChannelProperties(Object.assign(s,{channelInterpretation:i}))}connect(i,s=0,a=0){return connect(this,i,s,a),this}toDestination(){return this.connect(this.context.destination),this}toMaster(){return warn("toMaster() has been renamed toDestination()"),this.toDestination()}disconnect(i,s=0,a=0){return disconnect(this,i,s,a),this}chain(...i){return connectSeries(this,...i),this}fan(...i){return i.forEach(s=>this.connect(s)),this}dispose(){return super.dispose(),isDefined(this.input)&&(this.input instanceof ToneAudioNode?this.input.dispose():isAudioNode(this.input)&&this.input.disconnect()),isDefined(this.output)&&(this.output instanceof ToneAudioNode?this.output.dispose():isAudioNode(this.output)&&this.output.disconnect()),this._internalChannels=[],this}}function connectSeries(...c){const i=c.shift();c.reduce((s,a)=>(s instanceof ToneAudioNode?s.connect(a):isAudioNode(s)&&connect(s,a),a),i)}function connect(c,i,s=0,a=0){for(assert(isDefined(c),"Cannot connect from undefined node"),assert(isDefined(i),"Cannot connect to undefined node"),(i instanceof ToneAudioNode||isAudioNode(i))&&assert(i.numberOfInputs>0,"Cannot connect to node with no inputs"),assert(c.numberOfOutputs>0,"Cannot connect from node with no outputs");i instanceof ToneAudioNode||i instanceof Param;)isDefined(i.input)&&(i=i.input);for(;c instanceof ToneAudioNode;)isDefined(c.output)&&(c=c.output);isAudioParam(i)?c.connect(i,s):c.connect(i,s,a)}function disconnect(c,i,s=0,a=0){if(isDefined(i))for(;i instanceof ToneAudioNode;)i=i.input;for(;!isAudioNode(c);)isDefined(c.output)&&(c=c.output);isAudioParam(i)?c.disconnect(i,s):isAudioNode(i)?c.disconnect(i,s,a):c.disconnect()}class Gain extends ToneAudioNode{constructor(){super(optionsFromArguments(Gain.getDefaults(),arguments,["gain","units"])),this.name="Gain",this._gainNode=this.context.createGain(),this.input=this._gainNode,this.output=this._gainNode;const i=optionsFromArguments(Gain.getDefaults(),arguments,["gain","units"]);this.gain=new Param({context:this.context,convert:i.convert,param:this._gainNode.gain,units:i.units,value:i.gain,minValue:i.minValue,maxValue:i.maxValue}),readOnly(this,"gain")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{convert:!0,gain:1,units:"gain"})}dispose(){return super.dispose(),this._gainNode.disconnect(),this.gain.dispose(),this}}class OneShotSource extends ToneAudioNode{constructor(i){super(i),this.onended=noOp,this._startTime=-1,this._stopTime=-1,this._timeout=-1,this.output=new Gain({context:this.context,gain:0}),this._gainNode=this.output,this.getStateAtTime=function(s){const a=this.toSeconds(s);return this._startTime!==-1&&a>=this._startTime&&(this._stopTime===-1||a<=this._stopTime)?"started":"stopped"},this._fadeIn=i.fadeIn,this._fadeOut=i.fadeOut,this._curve=i.curve,this.onended=i.onended}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{curve:"linear",fadeIn:0,fadeOut:0,onended:noOp})}_startGain(i,s=1){assert(this._startTime===-1,"Source cannot be started more than once");const a=this.toSeconds(this._fadeIn);return this._startTime=i+a,this._startTime=Math.max(this._startTime,this.context.currentTime),a>0?(this._gainNode.gain.setValueAtTime(0,i),this._curve==="linear"?this._gainNode.gain.linearRampToValueAtTime(s,i+a):this._gainNode.gain.exponentialApproachValueAtTime(s,i,a)):this._gainNode.gain.setValueAtTime(s,i),this}stop(i){return this.log("stop",i),this._stopGain(this.toSeconds(i)),this}_stopGain(i){assert(this._startTime!==-1,"'start' must be called before 'stop'"),this.cancelStop();const s=this.toSeconds(this._fadeOut);return this._stopTime=this.toSeconds(i)+s,this._stopTime=Math.max(this._stopTime,this.context.currentTime),s>0?this._curve==="linear"?this._gainNode.gain.linearRampTo(0,s,i):this._gainNode.gain.targetRampTo(0,s,i):(this._gainNode.gain.cancelAndHoldAtTime(i),this._gainNode.gain.setValueAtTime(0,i)),this.context.clearTimeout(this._timeout),this._timeout=this.context.setTimeout(()=>{const a=this._curve==="exponential"?s*2:0;this._stopSource(this.now()+a),this._onended()},this._stopTime-this.context.currentTime),this}_onended(){if(this.onended!==noOp&&(this.onended(this),this.onended=noOp,!this.context.isOffline)){const i=()=>this.dispose();typeof window.requestIdleCallback<"u"?window.requestIdleCallback(i):setTimeout(i,1e3)}}get state(){return this.getStateAtTime(this.now())}cancelStop(){return this.log("cancelStop"),assert(this._startTime!==-1,"Source is not started"),this._gainNode.gain.cancelScheduledValues(this._startTime+this.sampleTime),this.context.clearTimeout(this._timeout),this._stopTime=-1,this}dispose(){return super.dispose(),this._gainNode.disconnect(),this}}class ToneConstantSource extends OneShotSource{constructor(){super(optionsFromArguments(ToneConstantSource.getDefaults(),arguments,["offset"])),this.name="ToneConstantSource",this._source=this.context.createConstantSource();const i=optionsFromArguments(ToneConstantSource.getDefaults(),arguments,["offset"]);connect(this._source,this._gainNode),this.offset=new Param({context:this.context,convert:i.convert,param:this._source.offset,units:i.units,value:i.offset,minValue:i.minValue,maxValue:i.maxValue})}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{convert:!0,offset:1,units:"number"})}start(i){const s=this.toSeconds(i);return this.log("start",s),this._startGain(s),this._source.start(s),this}_stopSource(i){this._source.stop(i)}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._source.disconnect(),this.offset.dispose(),this}}class Signal extends ToneAudioNode{constructor(){super(optionsFromArguments(Signal.getDefaults(),arguments,["value","units"])),this.name="Signal",this.override=!0;const i=optionsFromArguments(Signal.getDefaults(),arguments,["value","units"]);this.output=this._constantSource=new ToneConstantSource({context:this.context,convert:i.convert,offset:i.value,units:i.units,minValue:i.minValue,maxValue:i.maxValue}),this._constantSource.start(0),this.input=this._param=this._constantSource.offset}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{convert:!0,units:"number",value:0})}connect(i,s=0,a=0){return connectSignal(this,i,s,a),this}dispose(){return super.dispose(),this._param.dispose(),this._constantSource.dispose(),this}setValueAtTime(i,s){return this._param.setValueAtTime(i,s),this}getValueAtTime(i){return this._param.getValueAtTime(i)}setRampPoint(i){return this._param.setRampPoint(i),this}linearRampToValueAtTime(i,s){return this._param.linearRampToValueAtTime(i,s),this}exponentialRampToValueAtTime(i,s){return this._param.exponentialRampToValueAtTime(i,s),this}exponentialRampTo(i,s,a){return this._param.exponentialRampTo(i,s,a),this}linearRampTo(i,s,a){return this._param.linearRampTo(i,s,a),this}targetRampTo(i,s,a){return this._param.targetRampTo(i,s,a),this}exponentialApproachValueAtTime(i,s,a){return this._param.exponentialApproachValueAtTime(i,s,a),this}setTargetAtTime(i,s,a){return this._param.setTargetAtTime(i,s,a),this}setValueCurveAtTime(i,s,a,u){return this._param.setValueCurveAtTime(i,s,a,u),this}cancelScheduledValues(i){return this._param.cancelScheduledValues(i),this}cancelAndHoldAtTime(i){return this._param.cancelAndHoldAtTime(i),this}rampTo(i,s,a){return this._param.rampTo(i,s,a),this}get value(){return this._param.value}set value(i){this._param.value=i}get convert(){return this._param.convert}set convert(i){this._param.convert=i}get units(){return this._param.units}get overridden(){return this._param.overridden}set overridden(i){this._param.overridden=i}get maxValue(){return this._param.maxValue}get minValue(){return this._param.minValue}apply(i){return this._param.apply(i),this}}function connectSignal(c,i,s,a){(i instanceof Param||isAudioParam(i)||i instanceof Signal&&i.override)&&(i.cancelScheduledValues(0),i.setValueAtTime(0,0),i instanceof Signal&&(i.overridden=!0)),connect(c,i,s,a)}class TickParam extends Param{constructor(){super(optionsFromArguments(TickParam.getDefaults(),arguments,["value"])),this.name="TickParam",this._events=new Timeline(1/0),this._multiplier=1;const i=optionsFromArguments(TickParam.getDefaults(),arguments,["value"]);this._multiplier=i.multiplier,this._events.cancel(0),this._events.add({ticks:0,time:0,type:"setValueAtTime",value:this._fromType(i.value)}),this.setValueAtTime(i.value,0)}static getDefaults(){return Object.assign(Param.getDefaults(),{multiplier:1,units:"hertz",value:1})}setTargetAtTime(i,s,a){s=this.toSeconds(s),this.setRampPoint(s);const u=this._fromType(i),l=this._events.get(s),h=Math.round(Math.max(1/a,1));for(let f=0;f<=h;f++){const d=a*f+s,p=this._exponentialApproach(l.time,l.value,u,a,d);this.linearRampToValueAtTime(this._toType(p),d)}return this}setValueAtTime(i,s){const a=this.toSeconds(s);super.setValueAtTime(i,s);const u=this._events.get(a),l=this._events.previousEvent(u),h=this._getTicksUntilEvent(l,a);return u.ticks=Math.max(h,0),this}linearRampToValueAtTime(i,s){const a=this.toSeconds(s);super.linearRampToValueAtTime(i,s);const u=this._events.get(a),l=this._events.previousEvent(u),h=this._getTicksUntilEvent(l,a);return u.ticks=Math.max(h,0),this}exponentialRampToValueAtTime(i,s){s=this.toSeconds(s);const a=this._fromType(i),u=this._events.get(s),l=Math.round(Math.max((s-u.time)*10,1)),h=(s-u.time)/l;for(let f=0;f<=l;f++){const d=h*f+u.time,p=this._exponentialInterpolate(u.time,u.value,s,a,d);this.linearRampToValueAtTime(this._toType(p),d)}return this}_getTicksUntilEvent(i,s){if(i===null)i={ticks:0,time:0,type:"setValueAtTime",value:0};else if(isUndef(i.ticks)){const h=this._events.previousEvent(i);i.ticks=this._getTicksUntilEvent(h,i.time)}const a=this._fromType(this.getValueAtTime(i.time));let u=this._fromType(this.getValueAtTime(s));const l=this._events.get(s);return l&&l.time===s&&l.type==="setValueAtTime"&&(u=this._fromType(this.getValueAtTime(s-this.sampleTime))),.5*(s-i.time)*(a+u)+i.ticks}getTicksAtTime(i){const s=this.toSeconds(i),a=this._events.get(s);return Math.max(this._getTicksUntilEvent(a,s),0)}getDurationOfTicks(i,s){const a=this.toSeconds(s),u=this.getTicksAtTime(s);return this.getTimeOfTick(u+i)-a}getTimeOfTick(i){const s=this._events.get(i,"ticks"),a=this._events.getAfter(i,"ticks");if(s&&s.ticks===i)return s.time;if(s&&a&&a.type==="linearRampToValueAtTime"&&s.value!==a.value){const u=this._fromType(this.getValueAtTime(s.time)),h=(this._fromType(this.getValueAtTime(a.time))-u)/(a.time-s.time),f=Math.sqrt(Math.pow(u,2)-2*h*(s.ticks-i)),d=(-u+f)/h,p=(-u-f)/h;return(d>0?d:p)+s.time}else return s?s.value===0?1/0:s.time+(i-s.ticks)/s.value:i/this._initialValue}ticksToTime(i,s){return this.getDurationOfTicks(i,s)}timeToTicks(i,s){const a=this.toSeconds(s),u=this.toSeconds(i),l=this.getTicksAtTime(a);return this.getTicksAtTime(a+u)-l}_fromType(i){return this.units==="bpm"&&this.multiplier?1/(60/i/this.multiplier):super._fromType(i)}_toType(i){return this.units==="bpm"&&this.multiplier?i/this.multiplier*60:super._toType(i)}get multiplier(){return this._multiplier}set multiplier(i){const s=this.value;this._multiplier=i,this.cancelScheduledValues(0),this.setValueAtTime(s,0)}}class TickSignal extends Signal{constructor(){super(optionsFromArguments(TickSignal.getDefaults(),arguments,["value"])),this.name="TickSignal";const i=optionsFromArguments(TickSignal.getDefaults(),arguments,["value"]);this.input=this._param=new TickParam({context:this.context,convert:i.convert,multiplier:i.multiplier,param:this._constantSource.offset,units:i.units,value:i.value})}static getDefaults(){return Object.assign(Signal.getDefaults(),{multiplier:1,units:"hertz",value:1})}ticksToTime(i,s){return this._param.ticksToTime(i,s)}timeToTicks(i,s){return this._param.timeToTicks(i,s)}getTimeOfTick(i){return this._param.getTimeOfTick(i)}getDurationOfTicks(i,s){return this._param.getDurationOfTicks(i,s)}getTicksAtTime(i){return this._param.getTicksAtTime(i)}get multiplier(){return this._param.multiplier}set multiplier(i){this._param.multiplier=i}dispose(){return super.dispose(),this._param.dispose(),this}}class TickSource extends ToneWithContext{constructor(){super(optionsFromArguments(TickSource.getDefaults(),arguments,["frequency"])),this.name="TickSource",this._state=new StateTimeline,this._tickOffset=new Timeline;const i=optionsFromArguments(TickSource.getDefaults(),arguments,["frequency"]);this.frequency=new TickSignal({context:this.context,units:i.units,value:i.frequency}),readOnly(this,"frequency"),this._state.setStateAtTime("stopped",0),this.setTicksAtTime(0,0)}static getDefaults(){return Object.assign({frequency:1,units:"hertz"},ToneWithContext.getDefaults())}get state(){return this.getStateAtTime(this.now())}start(i,s){const a=this.toSeconds(i);return this._state.getValueAtTime(a)!=="started"&&(this._state.setStateAtTime("started",a),isDefined(s)&&this.setTicksAtTime(s,a)),this}stop(i){const s=this.toSeconds(i);if(this._state.getValueAtTime(s)==="stopped"){const a=this._state.get(s);a&&a.time>0&&(this._tickOffset.cancel(a.time),this._state.cancel(a.time))}return this._state.cancel(s),this._state.setStateAtTime("stopped",s),this.setTicksAtTime(0,s),this}pause(i){const s=this.toSeconds(i);return this._state.getValueAtTime(s)==="started"&&this._state.setStateAtTime("paused",s),this}cancel(i){return i=this.toSeconds(i),this._state.cancel(i),this._tickOffset.cancel(i),this}getTicksAtTime(i){const s=this.toSeconds(i),a=this._state.getLastState("stopped",s),u={state:"paused",time:s};this._state.add(u);let l=a,h=0;return this._state.forEachBetween(a.time,s+this.sampleTime,f=>{let d=l.time;const p=this._tickOffset.get(f.time);p&&p.time>=l.time&&(h=p.ticks,d=p.time),l.state==="started"&&f.state!=="started"&&(h+=this.frequency.getTicksAtTime(f.time)-this.frequency.getTicksAtTime(d)),l=f}),this._state.remove(u),h}get ticks(){return this.getTicksAtTime(this.now())}set ticks(i){this.setTicksAtTime(i,this.now())}get seconds(){return this.getSecondsAtTime(this.now())}set seconds(i){const s=this.now(),a=this.frequency.timeToTicks(i,s);this.setTicksAtTime(a,s)}getSecondsAtTime(i){i=this.toSeconds(i);const s=this._state.getLastState("stopped",i),a={state:"paused",time:i};this._state.add(a);let u=s,l=0;return this._state.forEachBetween(s.time,i+this.sampleTime,h=>{let f=u.time;const d=this._tickOffset.get(h.time);d&&d.time>=u.time&&(l=d.seconds,f=d.time),u.state==="started"&&h.state!=="started"&&(l+=h.time-f),u=h}),this._state.remove(a),l}setTicksAtTime(i,s){return s=this.toSeconds(s),this._tickOffset.cancel(s),this._tickOffset.add({seconds:this.frequency.getDurationOfTicks(i,s),ticks:i,time:s}),this}getStateAtTime(i){return i=this.toSeconds(i),this._state.getValueAtTime(i)}getTimeOfTick(i,s=this.now()){const a=this._tickOffset.get(s),u=this._state.get(s),l=Math.max(a.time,u.time),h=this.frequency.getTicksAtTime(l)+i-a.ticks;return this.frequency.getTimeOfTick(h)}forEachTickBetween(i,s,a){let u=this._state.get(i);this._state.forEachBetween(i,s,h=>{u&&u.state==="started"&&h.state!=="started"&&this.forEachTickBetween(Math.max(u.time,i),h.time-this.sampleTime,a),u=h});let l=null;if(u&&u.state==="started"){const h=Math.max(u.time,i),f=this.frequency.getTicksAtTime(h),d=this.frequency.getTicksAtTime(u.time),p=f-d;let g=Math.ceil(p)-p;g=EQ(g,1)?0:g;let m=this.frequency.getTimeOfTick(f+g);for(;m<s;){try{a(m,Math.round(this.getTicksAtTime(m)))}catch(y){l=y;break}m+=this.frequency.getDurationOfTicks(1,m)}}if(l)throw l;return this}dispose(){return super.dispose(),this._state.dispose(),this._tickOffset.dispose(),this.frequency.dispose(),this}}class Clock extends ToneWithContext{constructor(){super(optionsFromArguments(Clock.getDefaults(),arguments,["callback","frequency"])),this.name="Clock",this.callback=noOp,this._lastUpdate=0,this._state=new StateTimeline("stopped"),this._boundLoop=this._loop.bind(this);const i=optionsFromArguments(Clock.getDefaults(),arguments,["callback","frequency"]);this.callback=i.callback,this._tickSource=new TickSource({context:this.context,frequency:i.frequency,units:i.units}),this._lastUpdate=0,this.frequency=this._tickSource.frequency,readOnly(this,"frequency"),this._state.setStateAtTime("stopped",0),this.context.on("tick",this._boundLoop)}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{callback:noOp,frequency:1,units:"hertz"})}get state(){return this._state.getValueAtTime(this.now())}start(i,s){assertContextRunning(this.context);const a=this.toSeconds(i);return this.log("start",a),this._state.getValueAtTime(a)!=="started"&&(this._state.setStateAtTime("started",a),this._tickSource.start(a,s),a<this._lastUpdate&&this.emit("start",a,s)),this}stop(i){const s=this.toSeconds(i);return this.log("stop",s),this._state.cancel(s),this._state.setStateAtTime("stopped",s),this._tickSource.stop(s),s<this._lastUpdate&&this.emit("stop",s),this}pause(i){const s=this.toSeconds(i);return this._state.getValueAtTime(s)==="started"&&(this._state.setStateAtTime("paused",s),this._tickSource.pause(s),s<this._lastUpdate&&this.emit("pause",s)),this}get ticks(){return Math.ceil(this.getTicksAtTime(this.now()))}set ticks(i){this._tickSource.ticks=i}get seconds(){return this._tickSource.seconds}set seconds(i){this._tickSource.seconds=i}getSecondsAtTime(i){return this._tickSource.getSecondsAtTime(i)}setTicksAtTime(i,s){return this._tickSource.setTicksAtTime(i,s),this}getTimeOfTick(i,s=this.now()){return this._tickSource.getTimeOfTick(i,s)}getTicksAtTime(i){return this._tickSource.getTicksAtTime(i)}nextTickTime(i,s){const a=this.toSeconds(s),u=this.getTicksAtTime(a);return this._tickSource.getTimeOfTick(u+i,a)}_loop(){const i=this._lastUpdate,s=this.now();this._lastUpdate=s,this.log("loop",i,s),i!==s&&(this._state.forEachBetween(i,s,a=>{switch(a.state){case"started":const u=this._tickSource.getTicksAtTime(a.time);this.emit("start",a.time,u);break;case"stopped":a.time!==0&&this.emit("stop",a.time);break;case"paused":this.emit("pause",a.time);break}}),this._tickSource.forEachTickBetween(i,s,(a,u)=>{this.callback(a,u)}))}getStateAtTime(i){const s=this.toSeconds(i);return this._state.getValueAtTime(s)}dispose(){return super.dispose(),this.context.off("tick",this._boundLoop),this._tickSource.dispose(),this._state.dispose(),this}}Emitter.mixin(Clock);class ToneAudioBuffers extends Tone{constructor(){super(),this.name="ToneAudioBuffers",this._buffers=new Map,this._loadingCount=0;const i=optionsFromArguments(ToneAudioBuffers.getDefaults(),arguments,["urls","onload","baseUrl"],"urls");this.baseUrl=i.baseUrl,Object.keys(i.urls).forEach(s=>{this._loadingCount++;const a=i.urls[s];this.add(s,a,this._bufferLoaded.bind(this,i.onload),i.onerror)})}static getDefaults(){return{baseUrl:"",onerror:noOp,onload:noOp,urls:{}}}has(i){return this._buffers.has(i.toString())}get(i){return assert(this.has(i),`ToneAudioBuffers has no buffer named: ${i}`),this._buffers.get(i.toString())}_bufferLoaded(i){this._loadingCount--,this._loadingCount===0&&i&&i()}get loaded(){return Array.from(this._buffers).every(([i,s])=>s.loaded)}add(i,s,a=noOp,u=noOp){return isString(s)?this._buffers.set(i.toString(),new ToneAudioBuffer(this.baseUrl+s,a,u)):this._buffers.set(i.toString(),new ToneAudioBuffer(s,a,u)),this}dispose(){return super.dispose(),this._buffers.forEach(i=>i.dispose()),this._buffers.clear(),this}}class TicksClass extends TransportTimeClass{constructor(){super(...arguments),this.name="Ticks",this.defaultUnits="i"}_now(){return this.context.transport.ticks}_beatsToUnits(i){return this._getPPQ()*i}_secondsToUnits(i){return Math.floor(i/(60/this._getBpm())*this._getPPQ())}_ticksToUnits(i){return i}toTicks(){return this.valueOf()}toSeconds(){return this.valueOf()/this._getPPQ()*(60/this._getBpm())}}class Draw extends ToneWithContext{constructor(){super(...arguments),this.name="Draw",this.expiration=.25,this.anticipation=.008,this._events=new Timeline,this._boundDrawLoop=this._drawLoop.bind(this),this._animationFrame=-1}schedule(i,s){return this._events.add({callback:i,time:this.toSeconds(s)}),this._events.length===1&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop)),this}cancel(i){return this._events.cancel(this.toSeconds(i)),this}_drawLoop(){const i=this.context.currentTime;for(;this._events.length&&this._events.peek().time-this.anticipation<=i;){const s=this._events.shift();s&&i-s.time<=this.expiration&&s.callback()}this._events.length>0&&(this._animationFrame=requestAnimationFrame(this._boundDrawLoop))}dispose(){return super.dispose(),this._events.dispose(),cancelAnimationFrame(this._animationFrame),this}}onContextInit(c=>{c.draw=new Draw({context:c})});onContextClose(c=>{c.draw.dispose()});class IntervalTimeline extends Tone{constructor(){super(...arguments),this.name="IntervalTimeline",this._root=null,this._length=0}add(i){assert(isDefined(i.time),"Events must have a time property"),assert(isDefined(i.duration),"Events must have a duration parameter"),i.time=i.time.valueOf();let s=new IntervalNode(i.time,i.time+i.duration,i);for(this._root===null?this._root=s:this._root.insert(s),this._length++;s!==null;)s.updateHeight(),s.updateMax(),this._rebalance(s),s=s.parent;return this}remove(i){if(this._root!==null){const s=[];this._root.search(i.time,s);for(const a of s)if(a.event===i){this._removeNode(a),this._length--;break}}return this}get length(){return this._length}cancel(i){return this.forEachFrom(i,s=>this.remove(s)),this}_setRoot(i){this._root=i,this._root!==null&&(this._root.parent=null)}_replaceNodeInParent(i,s){i.parent!==null?(i.isLeftChild()?i.parent.left=s:i.parent.right=s,this._rebalance(i.parent)):this._setRoot(s)}_removeNode(i){if(i.left===null&&i.right===null)this._replaceNodeInParent(i,null);else if(i.right===null)this._replaceNodeInParent(i,i.left);else if(i.left===null)this._replaceNodeInParent(i,i.right);else{const s=i.getBalance();let a,u=null;if(s>0)if(i.left.right===null)a=i.left,a.right=i.right,u=a;else{for(a=i.left.right;a.right!==null;)a=a.right;a.parent&&(a.parent.right=a.left,u=a.parent,a.left=i.left,a.right=i.right)}else if(i.right.left===null)a=i.right,a.left=i.left,u=a;else{for(a=i.right.left;a.left!==null;)a=a.left;a.parent&&(a.parent.left=a.right,u=a.parent,a.left=i.left,a.right=i.right)}i.parent!==null?i.isLeftChild()?i.parent.left=a:i.parent.right=a:this._setRoot(a),u&&this._rebalance(u)}i.dispose()}_rotateLeft(i){const s=i.parent,a=i.isLeftChild(),u=i.right;u&&(i.right=u.left,u.left=i),s!==null?a?s.left=u:s.right=u:this._setRoot(u)}_rotateRight(i){const s=i.parent,a=i.isLeftChild(),u=i.left;u&&(i.left=u.right,u.right=i),s!==null?a?s.left=u:s.right=u:this._setRoot(u)}_rebalance(i){const s=i.getBalance();s>1&&i.left?i.left.getBalance()<0?this._rotateLeft(i.left):this._rotateRight(i):s<-1&&i.right&&(i.right.getBalance()>0?this._rotateRight(i.right):this._rotateLeft(i))}get(i){if(this._root!==null){const s=[];if(this._root.search(i,s),s.length>0){let a=s[0];for(let u=1;u<s.length;u++)s[u].low>a.low&&(a=s[u]);return a.event}}return null}forEach(i){if(this._root!==null){const s=[];this._root.traverse(a=>s.push(a)),s.forEach(a=>{a.event&&i(a.event)})}return this}forEachAtTime(i,s){if(this._root!==null){const a=[];this._root.search(i,a),a.forEach(u=>{u.event&&s(u.event)})}return this}forEachFrom(i,s){if(this._root!==null){const a=[];this._root.searchAfter(i,a),a.forEach(u=>{u.event&&s(u.event)})}return this}dispose(){return super.dispose(),this._root!==null&&this._root.traverse(i=>i.dispose()),this._root=null,this}}class IntervalNode{constructor(i,s,a){this._left=null,this._right=null,this.parent=null,this.height=0,this.event=a,this.low=i,this.high=s,this.max=this.high}insert(i){i.low<=this.low?this.left===null?this.left=i:this.left.insert(i):this.right===null?this.right=i:this.right.insert(i)}search(i,s){i>this.max||(this.left!==null&&this.left.search(i,s),this.low<=i&&this.high>i&&s.push(this),!(this.low>i)&&this.right!==null&&this.right.search(i,s))}searchAfter(i,s){this.low>=i&&(s.push(this),this.left!==null&&this.left.searchAfter(i,s)),this.right!==null&&this.right.searchAfter(i,s)}traverse(i){i(this),this.left!==null&&this.left.traverse(i),this.right!==null&&this.right.traverse(i)}updateHeight(){this.left!==null&&this.right!==null?this.height=Math.max(this.left.height,this.right.height)+1:this.right!==null?this.height=this.right.height+1:this.left!==null?this.height=this.left.height+1:this.height=0}updateMax(){this.max=this.high,this.left!==null&&(this.max=Math.max(this.max,this.left.max)),this.right!==null&&(this.max=Math.max(this.max,this.right.max))}getBalance(){let i=0;return this.left!==null&&this.right!==null?i=this.left.height-this.right.height:this.left!==null?i=this.left.height+1:this.right!==null&&(i=-(this.right.height+1)),i}isLeftChild(){return this.parent!==null&&this.parent.left===this}get left(){return this._left}set left(i){this._left=i,i!==null&&(i.parent=this),this.updateHeight(),this.updateMax()}get right(){return this._right}set right(i){this._right=i,i!==null&&(i.parent=this),this.updateHeight(),this.updateMax()}dispose(){this.parent=null,this._left=null,this._right=null,this.event=null}}class Volume extends ToneAudioNode{constructor(){super(optionsFromArguments(Volume.getDefaults(),arguments,["volume"])),this.name="Volume";const i=optionsFromArguments(Volume.getDefaults(),arguments,["volume"]);this.input=this.output=new Gain({context:this.context,gain:i.volume,units:"decibels"}),this.volume=this.output.gain,readOnly(this,"volume"),this._unmutedVolume=i.volume,this.mute=i.mute}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,volume:0})}get mute(){return this.volume.value===-1/0}set mute(i){!this.mute&&i?(this._unmutedVolume=this.volume.value,this.volume.value=-1/0):this.mute&&!i&&(this.volume.value=this._unmutedVolume)}dispose(){return super.dispose(),this.input.dispose(),this.volume.dispose(),this}}class Destination extends ToneAudioNode{constructor(){super(optionsFromArguments(Destination.getDefaults(),arguments)),this.name="Destination",this.input=new Volume({context:this.context}),this.output=new Gain({context:this.context}),this.volume=this.input.volume;const i=optionsFromArguments(Destination.getDefaults(),arguments);connectSeries(this.input,this.output,this.context.rawContext.destination),this.mute=i.mute,this._internalChannels=[this.input,this.context.rawContext.destination,this.output]}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,volume:0})}get mute(){return this.input.mute}set mute(i){this.input.mute=i}chain(...i){return this.input.disconnect(),i.unshift(this.input),i.push(this.output),connectSeries(...i),this}get maxChannelCount(){return this.context.rawContext.destination.maxChannelCount}dispose(){return super.dispose(),this.volume.dispose(),this}}onContextInit(c=>{c.destination=new Destination({context:c})});onContextClose(c=>{c.destination.dispose()});class TimelineValue extends Tone{constructor(i){super(),this.name="TimelineValue",this._timeline=new Timeline({memory:10}),this._initialValue=i}set(i,s){return this._timeline.add({value:i,time:s}),this}get(i){const s=this._timeline.get(i);return s?s.value:this._initialValue}}class TransportEvent{constructor(i,s){this.id=TransportEvent._eventId++;const a=Object.assign(TransportEvent.getDefaults(),s);this.transport=i,this.callback=a.callback,this._once=a.once,this.time=a.time}static getDefaults(){return{callback:noOp,once:!1,time:0}}invoke(i){this.callback&&(this.callback(i),this._once&&this.transport.clear(this.id))}dispose(){return this.callback=void 0,this}}TransportEvent._eventId=0;class TransportRepeatEvent extends TransportEvent{constructor(i,s){super(i,s),this._currentId=-1,this._nextId=-1,this._nextTick=this.time,this._boundRestart=this._restart.bind(this);const a=Object.assign(TransportRepeatEvent.getDefaults(),s);this.duration=new TicksClass(i.context,a.duration).valueOf(),this._interval=new TicksClass(i.context,a.interval).valueOf(),this._nextTick=a.time,this.transport.on("start",this._boundRestart),this.transport.on("loopStart",this._boundRestart),this.context=this.transport.context,this._restart()}static getDefaults(){return Object.assign({},TransportEvent.getDefaults(),{duration:1/0,interval:1,once:!1})}invoke(i){this._createEvents(i),super.invoke(i)}_createEvents(i){const s=this.transport.getTicksAtTime(i);s>=this.time&&s>=this._nextTick&&this._nextTick+this._interval<this.time+this.duration&&(this._nextTick+=this._interval,this._currentId=this._nextId,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds()))}_restart(i){this.transport.clear(this._currentId),this.transport.clear(this._nextId),this._nextTick=this.time;const s=this.transport.getTicksAtTime(i);s>this.time&&(this._nextTick=this.time+Math.ceil((s-this.time)/this._interval)*this._interval),this._currentId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds()),this._nextTick+=this._interval,this._nextId=this.transport.scheduleOnce(this.invoke.bind(this),new TicksClass(this.context,this._nextTick).toSeconds())}dispose(){return super.dispose(),this.transport.clear(this._currentId),this.transport.clear(this._nextId),this.transport.off("start",this._boundRestart),this.transport.off("loopStart",this._boundRestart),this}}class Transport extends ToneWithContext{constructor(){super(optionsFromArguments(Transport.getDefaults(),arguments)),this.name="Transport",this._loop=new TimelineValue(!1),this._loopStart=0,this._loopEnd=0,this._scheduledEvents={},this._timeline=new Timeline,this._repeatedEvents=new IntervalTimeline,this._syncedSignals=[],this._swingAmount=0;const i=optionsFromArguments(Transport.getDefaults(),arguments);this._ppq=i.ppq,this._clock=new Clock({callback:this._processTick.bind(this),context:this.context,frequency:0,units:"bpm"}),this._bindClockEvents(),this.bpm=this._clock.frequency,this._clock.frequency.multiplier=i.ppq,this.bpm.setValueAtTime(i.bpm,0),readOnly(this,"bpm"),this._timeSignature=i.timeSignature,this._swingTicks=i.ppq/2}static getDefaults(){return Object.assign(ToneWithContext.getDefaults(),{bpm:120,loopEnd:"4m",loopStart:0,ppq:192,swing:0,swingSubdivision:"8n",timeSignature:4})}_processTick(i,s){if(this._loop.get(i)&&s>=this._loopEnd&&(this.emit("loopEnd",i),this._clock.setTicksAtTime(this._loopStart,i),s=this._loopStart,this.emit("loopStart",i,this._clock.getSecondsAtTime(i)),this.emit("loop",i)),this._swingAmount>0&&s%this._ppq!==0&&s%(this._swingTicks*2)!==0){const a=s%(this._swingTicks*2)/(this._swingTicks*2),u=Math.sin(a*Math.PI)*this._swingAmount;i+=new TicksClass(this.context,this._swingTicks*2/3).toSeconds()*u}this._timeline.forEachAtTime(s,a=>a.invoke(i))}schedule(i,s){const a=new TransportEvent(this,{callback:i,time:new TransportTimeClass(this.context,s).toTicks()});return this._addEvent(a,this._timeline)}scheduleRepeat(i,s,a,u=1/0){const l=new TransportRepeatEvent(this,{callback:i,duration:new TimeClass(this.context,u).toTicks(),interval:new TimeClass(this.context,s).toTicks(),time:new TransportTimeClass(this.context,a).toTicks()});return this._addEvent(l,this._repeatedEvents)}scheduleOnce(i,s){const a=new TransportEvent(this,{callback:i,once:!0,time:new TransportTimeClass(this.context,s).toTicks()});return this._addEvent(a,this._timeline)}clear(i){if(this._scheduledEvents.hasOwnProperty(i)){const s=this._scheduledEvents[i.toString()];s.timeline.remove(s.event),s.event.dispose(),delete this._scheduledEvents[i.toString()]}return this}_addEvent(i,s){return this._scheduledEvents[i.id.toString()]={event:i,timeline:s},s.add(i),i.id}cancel(i=0){const s=this.toTicks(i);return this._timeline.forEachFrom(s,a=>this.clear(a.id)),this._repeatedEvents.forEachFrom(s,a=>this.clear(a.id)),this}_bindClockEvents(){this._clock.on("start",(i,s)=>{s=new TicksClass(this.context,s).toSeconds(),this.emit("start",i,s)}),this._clock.on("stop",i=>{this.emit("stop",i)}),this._clock.on("pause",i=>{this.emit("pause",i)})}get state(){return this._clock.getStateAtTime(this.now())}start(i,s){let a;return isDefined(s)&&(a=this.toTicks(s)),this._clock.start(i,a),this}stop(i){return this._clock.stop(i),this}pause(i){return this._clock.pause(i),this}toggle(i){return i=this.toSeconds(i),this._clock.getStateAtTime(i)!=="started"?this.start(i):this.stop(i),this}get timeSignature(){return this._timeSignature}set timeSignature(i){isArray(i)&&(i=i[0]/i[1]*4),this._timeSignature=i}get loopStart(){return new TimeClass(this.context,this._loopStart,"i").toSeconds()}set loopStart(i){this._loopStart=this.toTicks(i)}get loopEnd(){return new TimeClass(this.context,this._loopEnd,"i").toSeconds()}set loopEnd(i){this._loopEnd=this.toTicks(i)}get loop(){return this._loop.get(this.now())}set loop(i){this._loop.set(i,this.now())}setLoopPoints(i,s){return this.loopStart=i,this.loopEnd=s,this}get swing(){return this._swingAmount}set swing(i){this._swingAmount=i}get swingSubdivision(){return new TicksClass(this.context,this._swingTicks).toNotation()}set swingSubdivision(i){this._swingTicks=this.toTicks(i)}get position(){const i=this.now(),s=this._clock.getTicksAtTime(i);return new TicksClass(this.context,s).toBarsBeatsSixteenths()}set position(i){const s=this.toTicks(i);this.ticks=s}get seconds(){return this._clock.seconds}set seconds(i){const s=this.now(),a=this._clock.frequency.timeToTicks(i,s);this.ticks=a}get progress(){if(this.loop){const i=this.now();return(this._clock.getTicksAtTime(i)-this._loopStart)/(this._loopEnd-this._loopStart)}else return 0}get ticks(){return this._clock.ticks}set ticks(i){if(this._clock.ticks!==i){const s=this.now();if(this.state==="started"){const a=this._clock.getTicksAtTime(s),u=this._clock.frequency.getDurationOfTicks(Math.ceil(a)-a,s),l=s+u;this.emit("stop",l),this._clock.setTicksAtTime(i,l),this.emit("start",l,this._clock.getSecondsAtTime(l))}else this._clock.setTicksAtTime(i,s)}}getTicksAtTime(i){return Math.round(this._clock.getTicksAtTime(i))}getSecondsAtTime(i){return this._clock.getSecondsAtTime(i)}get PPQ(){return this._clock.frequency.multiplier}set PPQ(i){this._clock.frequency.multiplier=i}nextSubdivision(i){if(i=this.toTicks(i),this.state!=="started")return 0;{const s=this.now(),a=this.getTicksAtTime(s),u=i-a%i;return this._clock.nextTickTime(u,s)}}syncSignal(i,s){if(!s){const u=this.now();if(i.getValueAtTime(u)!==0){const h=1/(60/this.bpm.getValueAtTime(u)/this.PPQ);s=i.getValueAtTime(u)/h}else s=0}const a=new Gain(s);return this.bpm.connect(a),a.connect(i._param),this._syncedSignals.push({initial:i.value,ratio:a,signal:i}),i.value=0,this}unsyncSignal(i){for(let s=this._syncedSignals.length-1;s>=0;s--){const a=this._syncedSignals[s];a.signal===i&&(a.ratio.dispose(),a.signal.value=a.initial,this._syncedSignals.splice(s,1))}return this}dispose(){return super.dispose(),this._clock.dispose(),writable(this,"bpm"),this._timeline.dispose(),this._repeatedEvents.dispose(),this}}Emitter.mixin(Transport);onContextInit(c=>{c.transport=new Transport({context:c})});onContextClose(c=>{c.transport.dispose()});class Source extends ToneAudioNode{constructor(i){super(i),this.input=void 0,this._state=new StateTimeline("stopped"),this._synced=!1,this._scheduled=[],this._syncedStart=noOp,this._syncedStop=noOp,this._state.memory=100,this._state.increasing=!0,this._volume=this.output=new Volume({context:this.context,mute:i.mute,volume:i.volume}),this.volume=this._volume.volume,readOnly(this,"volume"),this.onstop=i.onstop}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,onstop:noOp,volume:0})}get state(){return this._synced?this.context.transport.state==="started"?this._state.getValueAtTime(this.context.transport.seconds):"stopped":this._state.getValueAtTime(this.now())}get mute(){return this._volume.mute}set mute(i){this._volume.mute=i}_clampToCurrentTime(i){return this._synced?i:Math.max(i,this.context.currentTime)}start(i,s,a){let u=isUndef(i)&&this._synced?this.context.transport.seconds:this.toSeconds(i);if(u=this._clampToCurrentTime(u),!this._synced&&this._state.getValueAtTime(u)==="started")assert(GT(u,this._state.get(u).time),"Start time must be strictly greater than previous start time"),this._state.cancel(u),this._state.setStateAtTime("started",u),this.log("restart",u),this.restart(u,s,a);else if(this.log("start",u),this._state.setStateAtTime("started",u),this._synced){const l=this._state.get(u);l&&(l.offset=this.toSeconds(defaultArg(s,0)),l.duration=a?this.toSeconds(a):void 0);const h=this.context.transport.schedule(f=>{this._start(f,s,a)},u);this._scheduled.push(h),this.context.transport.state==="started"&&this.context.transport.getSecondsAtTime(this.immediate())>u&&this._syncedStart(this.now(),this.context.transport.seconds)}else assertContextRunning(this.context),this._start(u,s,a);return this}stop(i){let s=isUndef(i)&&this._synced?this.context.transport.seconds:this.toSeconds(i);if(s=this._clampToCurrentTime(s),this._state.getValueAtTime(s)==="started"||isDefined(this._state.getNextState("started",s))){if(this.log("stop",s),!this._synced)this._stop(s);else{const a=this.context.transport.schedule(this._stop.bind(this),s);this._scheduled.push(a)}this._state.cancel(s),this._state.setStateAtTime("stopped",s)}return this}restart(i,s,a){return i=this.toSeconds(i),this._state.getValueAtTime(i)==="started"&&(this._state.cancel(i),this._restart(i,s,a)),this}sync(){return this._synced||(this._synced=!0,this._syncedStart=(i,s)=>{if(s>0){const a=this._state.get(s);if(a&&a.state==="started"&&a.time!==s){const u=s-this.toSeconds(a.time);let l;a.duration&&(l=this.toSeconds(a.duration)-u),this._start(i,this.toSeconds(a.offset)+u,l)}}},this._syncedStop=i=>{const s=this.context.transport.getSecondsAtTime(Math.max(i-this.sampleTime,0));this._state.getValueAtTime(s)==="started"&&this._stop(i)},this.context.transport.on("start",this._syncedStart),this.context.transport.on("loopStart",this._syncedStart),this.context.transport.on("stop",this._syncedStop),this.context.transport.on("pause",this._syncedStop),this.context.transport.on("loopEnd",this._syncedStop)),this}unsync(){return this._synced&&(this.context.transport.off("stop",this._syncedStop),this.context.transport.off("pause",this._syncedStop),this.context.transport.off("loopEnd",this._syncedStop),this.context.transport.off("start",this._syncedStart),this.context.transport.off("loopStart",this._syncedStart)),this._synced=!1,this._scheduled.forEach(i=>this.context.transport.clear(i)),this._scheduled=[],this._state.cancel(0),this._stop(0),this}dispose(){return super.dispose(),this.onstop=noOp,this.unsync(),this._volume.dispose(),this._state.dispose(),this}}class ToneBufferSource extends OneShotSource{constructor(){super(optionsFromArguments(ToneBufferSource.getDefaults(),arguments,["url","onload"])),this.name="ToneBufferSource",this._source=this.context.createBufferSource(),this._internalChannels=[this._source],this._sourceStarted=!1,this._sourceStopped=!1;const i=optionsFromArguments(ToneBufferSource.getDefaults(),arguments,["url","onload"]);connect(this._source,this._gainNode),this._source.onended=()=>this._stopSource(),this.playbackRate=new Param({context:this.context,param:this._source.playbackRate,units:"positive",value:i.playbackRate}),this.loop=i.loop,this.loopStart=i.loopStart,this.loopEnd=i.loopEnd,this._buffer=new ToneAudioBuffer(i.url,i.onload,i.onerror),this._internalChannels.push(this._source)}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{url:new ToneAudioBuffer,loop:!1,loopEnd:0,loopStart:0,onload:noOp,onerror:noOp,playbackRate:1})}get fadeIn(){return this._fadeIn}set fadeIn(i){this._fadeIn=i}get fadeOut(){return this._fadeOut}set fadeOut(i){this._fadeOut=i}get curve(){return this._curve}set curve(i){this._curve=i}start(i,s,a,u=1){assert(this.buffer.loaded,"buffer is either not set or not loaded");const l=this.toSeconds(i);this._startGain(l,u),this.loop?s=defaultArg(s,this.loopStart):s=defaultArg(s,0);let h=Math.max(this.toSeconds(s),0);if(this.loop){const f=this.toSeconds(this.loopEnd)||this.buffer.duration,d=this.toSeconds(this.loopStart),p=f-d;GTE(h,f)&&(h=(h-d)%p+d),EQ(h,this.buffer.duration)&&(h=0)}if(this._source.buffer=this.buffer.get(),this._source.loopEnd=this.toSeconds(this.loopEnd)||this.buffer.duration,LT(h,this.buffer.duration)&&(this._sourceStarted=!0,this._source.start(l,h)),isDefined(a)){let f=this.toSeconds(a);f=Math.max(f,0),this.stop(l+f)}return this}_stopSource(i){!this._sourceStopped&&this._sourceStarted&&(this._sourceStopped=!0,this._source.stop(this.toSeconds(i)),this._onended())}get loopStart(){return this._source.loopStart}set loopStart(i){this._source.loopStart=this.toSeconds(i)}get loopEnd(){return this._source.loopEnd}set loopEnd(i){this._source.loopEnd=this.toSeconds(i)}get buffer(){return this._buffer}set buffer(i){this._buffer.set(i)}get loop(){return this._source.loop}set loop(i){this._source.loop=i,this._sourceStarted&&this.cancelStop()}dispose(){return super.dispose(),this._source.onended=null,this._source.disconnect(),this._buffer.dispose(),this.playbackRate.dispose(),this}}class Noise extends Source{constructor(){super(optionsFromArguments(Noise.getDefaults(),arguments,["type"])),this.name="Noise",this._source=null;const i=optionsFromArguments(Noise.getDefaults(),arguments,["type"]);this._playbackRate=i.playbackRate,this.type=i.type,this._fadeIn=i.fadeIn,this._fadeOut=i.fadeOut}static getDefaults(){return Object.assign(Source.getDefaults(),{fadeIn:0,fadeOut:0,playbackRate:1,type:"white"})}get type(){return this._type}set type(i){if(assert(i in _noiseBuffers,"Noise: invalid type: "+i),this._type!==i&&(this._type=i,this.state==="started")){const s=this.now();this._stop(s),this._start(s)}}get playbackRate(){return this._playbackRate}set playbackRate(i){this._playbackRate=i,this._source&&(this._source.playbackRate.value=i)}_start(i){const s=_noiseBuffers[this._type];this._source=new ToneBufferSource({url:s,context:this.context,fadeIn:this._fadeIn,fadeOut:this._fadeOut,loop:!0,onended:()=>this.onstop(this),playbackRate:this._playbackRate}).connect(this.output),this._source.start(this.toSeconds(i),Math.random()*(s.duration-.001))}_stop(i){this._source&&(this._source.stop(this.toSeconds(i)),this._source=null)}get fadeIn(){return this._fadeIn}set fadeIn(i){this._fadeIn=i,this._source&&(this._source.fadeIn=this._fadeIn)}get fadeOut(){return this._fadeOut}set fadeOut(i){this._fadeOut=i,this._source&&(this._source.fadeOut=this._fadeOut)}_restart(i){this._stop(i),this._start(i)}dispose(){return super.dispose(),this._source&&this._source.disconnect(),this}}const BUFFER_LENGTH=44100*5,NUM_CHANNELS=2,_noiseCache={brown:null,pink:null,white:null},_noiseBuffers={get brown(){if(!_noiseCache.brown){const c=[];for(let i=0;i<NUM_CHANNELS;i++){const s=new Float32Array(BUFFER_LENGTH);c[i]=s;let a=0;for(let u=0;u<BUFFER_LENGTH;u++){const l=Math.random()*2-1;s[u]=(a+.02*l)/1.02,a=s[u],s[u]*=3.5}}_noiseCache.brown=new ToneAudioBuffer().fromArray(c)}return _noiseCache.brown},get pink(){if(!_noiseCache.pink){const c=[];for(let i=0;i<NUM_CHANNELS;i++){const s=new Float32Array(BUFFER_LENGTH);c[i]=s;let a,u,l,h,f,d,p;a=u=l=h=f=d=p=0;for(let g=0;g<BUFFER_LENGTH;g++){const m=Math.random()*2-1;a=.99886*a+m*.0555179,u=.99332*u+m*.0750759,l=.969*l+m*.153852,h=.8665*h+m*.3104856,f=.55*f+m*.5329522,d=-.7616*d-m*.016898,s[g]=a+u+l+h+f+d+p+m*.5362,s[g]*=.11,p=m*.115926}}_noiseCache.pink=new ToneAudioBuffer().fromArray(c)}return _noiseCache.pink},get white(){if(!_noiseCache.white){const c=[];for(let i=0;i<NUM_CHANNELS;i++){const s=new Float32Array(BUFFER_LENGTH);c[i]=s;for(let a=0;a<BUFFER_LENGTH;a++)s[a]=Math.random()*2-1}_noiseCache.white=new ToneAudioBuffer().fromArray(c)}return _noiseCache.white}};function generateWaveform(c,i){return __awaiter(this,void 0,void 0,function*(){const s=i/c.context.sampleRate,a=new OfflineContext(1,s,c.context.sampleRate);return new c.constructor(Object.assign(c.get(),{frequency:2/s,detune:0,context:a})).toDestination().start(0),(yield a.render()).getChannelData(0)})}class ToneOscillatorNode extends OneShotSource{constructor(){super(optionsFromArguments(ToneOscillatorNode.getDefaults(),arguments,["frequency","type"])),this.name="ToneOscillatorNode",this._oscillator=this.context.createOscillator(),this._internalChannels=[this._oscillator];const i=optionsFromArguments(ToneOscillatorNode.getDefaults(),arguments,["frequency","type"]);connect(this._oscillator,this._gainNode),this.type=i.type,this.frequency=new Param({context:this.context,param:this._oscillator.frequency,units:"frequency",value:i.frequency}),this.detune=new Param({context:this.context,param:this._oscillator.detune,units:"cents",value:i.detune}),readOnly(this,["frequency","detune"])}static getDefaults(){return Object.assign(OneShotSource.getDefaults(),{detune:0,frequency:440,type:"sine"})}start(i){const s=this.toSeconds(i);return this.log("start",s),this._startGain(s),this._oscillator.start(s),this}_stopSource(i){this._oscillator.stop(i)}setPeriodicWave(i){return this._oscillator.setPeriodicWave(i),this}get type(){return this._oscillator.type}set type(i){this._oscillator.type=i}dispose(){return super.dispose(),this.state==="started"&&this.stop(),this._oscillator.disconnect(),this.frequency.dispose(),this.detune.dispose(),this}}class Oscillator extends Source{constructor(){super(optionsFromArguments(Oscillator.getDefaults(),arguments,["frequency","type"])),this.name="Oscillator",this._oscillator=null;const i=optionsFromArguments(Oscillator.getDefaults(),arguments,["frequency","type"]);this.frequency=new Signal({context:this.context,units:"frequency",value:i.frequency}),readOnly(this,"frequency"),this.detune=new Signal({context:this.context,units:"cents",value:i.detune}),readOnly(this,"detune"),this._partials=i.partials,this._partialCount=i.partialCount,this._type=i.type,i.partialCount&&i.type!=="custom"&&(this._type=this.baseType+i.partialCount.toString()),this.phase=i.phase}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,partialCount:0,partials:[],phase:0,type:"sine"})}_start(i){const s=this.toSeconds(i),a=new ToneOscillatorNode({context:this.context,onended:()=>this.onstop(this)});this._oscillator=a,this._wave?this._oscillator.setPeriodicWave(this._wave):this._oscillator.type=this._type,this._oscillator.connect(this.output),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.start(s)}_stop(i){const s=this.toSeconds(i);this._oscillator&&this._oscillator.stop(s)}_restart(i){const s=this.toSeconds(i);return this.log("restart",s),this._oscillator&&this._oscillator.cancelStop(),this._state.cancel(s),this}syncFrequency(){return this.context.transport.syncSignal(this.frequency),this}unsyncFrequency(){return this.context.transport.unsyncSignal(this.frequency),this}_getCachedPeriodicWave(){if(this._type==="custom")return Oscillator._periodicWaveCache.find(s=>s.phase===this._phase&&deepEquals(s.partials,this._partials));{const i=Oscillator._periodicWaveCache.find(s=>s.type===this._type&&s.phase===this._phase);return this._partialCount=i?i.partialCount:this._partialCount,i}}get type(){return this._type}set type(i){this._type=i;const s=["sine","square","sawtooth","triangle"].indexOf(i)!==-1;if(this._phase===0&&s)this._wave=void 0,this._partialCount=0,this._oscillator!==null&&(this._oscillator.type=i);else{const a=this._getCachedPeriodicWave();if(isDefined(a)){const{partials:u,wave:l}=a;this._wave=l,this._partials=u,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave)}else{const[u,l]=this._getRealImaginary(i,this._phase),h=this.context.createPeriodicWave(u,l);this._wave=h,this._oscillator!==null&&this._oscillator.setPeriodicWave(this._wave),Oscillator._periodicWaveCache.push({imag:l,partialCount:this._partialCount,partials:this._partials,phase:this._phase,real:u,type:this._type,wave:this._wave}),Oscillator._periodicWaveCache.length>100&&Oscillator._periodicWaveCache.shift()}}}get baseType(){return this._type.replace(this.partialCount.toString(),"")}set baseType(i){this.partialCount&&this._type!=="custom"&&i!=="custom"?this.type=i+this.partialCount:this.type=i}get partialCount(){return this._partialCount}set partialCount(i){assertRange(i,0);let s=this._type;const a=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(this._type);if(a&&(s=a[1]),this._type!=="custom")i===0?this.type=s:this.type=s+i.toString();else{const u=new Float32Array(i);this._partials.forEach((l,h)=>u[h]=l),this._partials=Array.from(u),this.type=this._type}}_getRealImaginary(i,s){let u=2048;const l=new Float32Array(u),h=new Float32Array(u);let f=1;if(i==="custom"){if(f=this._partials.length+1,this._partialCount=this._partials.length,u=f,this._partials.length===0)return[l,h]}else{const d=/^(sine|triangle|square|sawtooth)(\d+)$/.exec(i);d?(f=parseInt(d[2],10)+1,this._partialCount=parseInt(d[2],10),i=d[1],f=Math.max(f,2),u=f):this._partialCount=0,this._partials=[]}for(let d=1;d<u;++d){const p=2/(d*Math.PI);let g;switch(i){case"sine":g=d<=f?1:0,this._partials[d-1]=g;break;case"square":g=d&1?2*p:0,this._partials[d-1]=g;break;case"sawtooth":g=p*(d&1?1:-1),this._partials[d-1]=g;break;case"triangle":d&1?g=2*(p*p)*(d-1>>1&1?-1:1):g=0,this._partials[d-1]=g;break;case"custom":g=this._partials[d-1];break;default:throw new TypeError("Oscillator: invalid type: "+i)}g!==0?(l[d]=-g*Math.sin(s*d),h[d]=g*Math.cos(s*d)):(l[d]=0,h[d]=0)}return[l,h]}_inverseFFT(i,s,a){let u=0;const l=i.length;for(let h=0;h<l;h++)u+=i[h]*Math.cos(h*a)+s[h]*Math.sin(h*a);return u}getInitialValue(){const[i,s]=this._getRealImaginary(this._type,0);let a=0;const u=Math.PI*2,l=32;for(let h=0;h<l;h++)a=Math.max(this._inverseFFT(i,s,h/l*u),a);return clamp(-this._inverseFFT(i,s,this._phase)/a,-1,1)}get partials(){return this._partials.slice(0,this.partialCount)}set partials(i){this._partials=i,this._partialCount=this._partials.length,i.length&&(this.type="custom")}get phase(){return this._phase*(180/Math.PI)}set phase(i){this._phase=i*Math.PI/180,this.type=this._type}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this._oscillator!==null&&this._oscillator.dispose(),this._wave=void 0,this.frequency.dispose(),this.detune.dispose(),this}}Oscillator._periodicWaveCache=[];class SignalOperator extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(SignalOperator.getDefaults(),arguments,["context"])))}connect(i,s=0,a=0){return connectSignal(this,i,s,a),this}}class WaveShaper extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(WaveShaper.getDefaults(),arguments,["mapping","length"]))),this.name="WaveShaper",this._shaper=this.context.createWaveShaper(),this.input=this._shaper,this.output=this._shaper;const i=optionsFromArguments(WaveShaper.getDefaults(),arguments,["mapping","length"]);isArray(i.mapping)||i.mapping instanceof Float32Array?this.curve=Float32Array.from(i.mapping):isFunction(i.mapping)&&this.setMap(i.mapping,i.length)}static getDefaults(){return Object.assign(Signal.getDefaults(),{length:1024})}setMap(i,s=1024){const a=new Float32Array(s);for(let u=0,l=s;u<l;u++){const h=u/(l-1)*2-1;a[u]=i(h,u)}return this.curve=a,this}get curve(){return this._shaper.curve}set curve(i){this._shaper.curve=i}get oversample(){return this._shaper.oversample}set oversample(i){const s=["none","2x","4x"].some(a=>a.includes(i));assert(s,"oversampling must be either 'none', '2x', or '4x'"),this._shaper.oversample=i}dispose(){return super.dispose(),this._shaper.disconnect(),this}}class AudioToGain extends SignalOperator{constructor(){super(...arguments),this.name="AudioToGain",this._norm=new WaveShaper({context:this.context,mapping:i=>(i+1)/2}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Multiply extends Signal{constructor(){super(Object.assign(optionsFromArguments(Multiply.getDefaults(),arguments,["value"]))),this.name="Multiply",this.override=!1;const i=optionsFromArguments(Multiply.getDefaults(),arguments,["value"]);this._mult=this.input=this.output=new Gain({context:this.context,minValue:i.minValue,maxValue:i.maxValue}),this.factor=this._param=this._mult.gain,this.factor.setValueAtTime(i.value,0)}static getDefaults(){return Object.assign(Signal.getDefaults(),{value:0})}dispose(){return super.dispose(),this._mult.dispose(),this}}class AMOscillator extends Source{constructor(){super(optionsFromArguments(AMOscillator.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="AMOscillator",this._modulationScale=new AudioToGain({context:this.context}),this._modulationNode=new Gain({context:this.context});const i=optionsFromArguments(AMOscillator.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new Oscillator({context:this.context,detune:i.detune,frequency:i.frequency,onstop:()=>this.onstop(this),phase:i.phase,type:i.type}),this.frequency=this._carrier.frequency,this.detune=this._carrier.detune,this._modulator=new Oscillator({context:this.context,phase:i.phase,type:i.modulationType}),this.harmonicity=new Multiply({context:this.context,units:"positive",value:i.harmonicity}),this.frequency.chain(this.harmonicity,this._modulator.frequency),this._modulator.chain(this._modulationScale,this._modulationNode.gain),this._carrier.chain(this._modulationNode,this.output),readOnly(this,["frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{harmonicity:1,modulationType:"square"})}_start(i){this._modulator.start(i),this._carrier.start(i)}_stop(i){this._modulator.stop(i),this._carrier.stop(i)}_restart(i){this._modulator.restart(i),this._carrier.restart(i)}get type(){return this._carrier.type}set type(i){this._carrier.type=i}get baseType(){return this._carrier.baseType}set baseType(i){this._carrier.baseType=i}get partialCount(){return this._carrier.partialCount}set partialCount(i){this._carrier.partialCount=i}get modulationType(){return this._modulator.type}set modulationType(i){this._modulator.type=i}get phase(){return this._carrier.phase}set phase(i){this._carrier.phase=i,this._modulator.phase=i}get partials(){return this._carrier.partials}set partials(i){this._carrier.partials=i}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this._modulationScale.dispose(),this}}class FMOscillator extends Source{constructor(){super(optionsFromArguments(FMOscillator.getDefaults(),arguments,["frequency","type","modulationType"])),this.name="FMOscillator",this._modulationNode=new Gain({context:this.context,gain:0});const i=optionsFromArguments(FMOscillator.getDefaults(),arguments,["frequency","type","modulationType"]);this._carrier=new Oscillator({context:this.context,detune:i.detune,frequency:0,onstop:()=>this.onstop(this),phase:i.phase,type:i.type}),this.detune=this._carrier.detune,this.frequency=new Signal({context:this.context,units:"frequency",value:i.frequency}),this._modulator=new Oscillator({context:this.context,phase:i.phase,type:i.modulationType}),this.harmonicity=new Multiply({context:this.context,units:"positive",value:i.harmonicity}),this.modulationIndex=new Multiply({context:this.context,units:"positive",value:i.modulationIndex}),this.frequency.connect(this._carrier.frequency),this.frequency.chain(this.harmonicity,this._modulator.frequency),this.frequency.chain(this.modulationIndex,this._modulationNode),this._modulator.connect(this._modulationNode.gain),this._modulationNode.connect(this._carrier.frequency),this._carrier.connect(this.output),this.detune.connect(this._modulator.detune),readOnly(this,["modulationIndex","frequency","detune","harmonicity"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{harmonicity:1,modulationIndex:2,modulationType:"square"})}_start(i){this._modulator.start(i),this._carrier.start(i)}_stop(i){this._modulator.stop(i),this._carrier.stop(i)}_restart(i){return this._modulator.restart(i),this._carrier.restart(i),this}get type(){return this._carrier.type}set type(i){this._carrier.type=i}get baseType(){return this._carrier.baseType}set baseType(i){this._carrier.baseType=i}get partialCount(){return this._carrier.partialCount}set partialCount(i){this._carrier.partialCount=i}get modulationType(){return this._modulator.type}set modulationType(i){this._modulator.type=i}get phase(){return this._carrier.phase}set phase(i){this._carrier.phase=i,this._modulator.phase=i}get partials(){return this._carrier.partials}set partials(i){this._carrier.partials=i}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this.frequency.dispose(),this.harmonicity.dispose(),this._carrier.dispose(),this._modulator.dispose(),this._modulationNode.dispose(),this.modulationIndex.dispose(),this}}class PulseOscillator extends Source{constructor(){super(optionsFromArguments(PulseOscillator.getDefaults(),arguments,["frequency","width"])),this.name="PulseOscillator",this._widthGate=new Gain({context:this.context,gain:0}),this._thresh=new WaveShaper({context:this.context,mapping:s=>s<=0?-1:1});const i=optionsFromArguments(PulseOscillator.getDefaults(),arguments,["frequency","width"]);this.width=new Signal({context:this.context,units:"audioRange",value:i.width}),this._triangle=new Oscillator({context:this.context,detune:i.detune,frequency:i.frequency,onstop:()=>this.onstop(this),phase:i.phase,type:"triangle"}),this.frequency=this._triangle.frequency,this.detune=this._triangle.detune,this._triangle.chain(this._thresh,this.output),this.width.chain(this._widthGate,this._thresh),readOnly(this,["width","frequency","detune"])}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,phase:0,type:"pulse",width:.2})}_start(i){i=this.toSeconds(i),this._triangle.start(i),this._widthGate.gain.setValueAtTime(1,i)}_stop(i){i=this.toSeconds(i),this._triangle.stop(i),this._widthGate.gain.cancelScheduledValues(i),this._widthGate.gain.setValueAtTime(0,i)}_restart(i){this._triangle.restart(i),this._widthGate.gain.cancelScheduledValues(i),this._widthGate.gain.setValueAtTime(1,i)}get phase(){return this._triangle.phase}set phase(i){this._triangle.phase=i}get type(){return"pulse"}get baseType(){return"pulse"}get partials(){return[]}get partialCount(){return 0}set carrierType(i){this._triangle.type=i}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this._triangle.dispose(),this.width.dispose(),this._widthGate.dispose(),this._thresh.dispose(),this}}class FatOscillator extends Source{constructor(){super(optionsFromArguments(FatOscillator.getDefaults(),arguments,["frequency","type","spread"])),this.name="FatOscillator",this._oscillators=[];const i=optionsFromArguments(FatOscillator.getDefaults(),arguments,["frequency","type","spread"]);this.frequency=new Signal({context:this.context,units:"frequency",value:i.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:i.detune}),this._spread=i.spread,this._type=i.type,this._phase=i.phase,this._partials=i.partials,this._partialCount=i.partialCount,this.count=i.count,readOnly(this,["frequency","detune"])}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{count:3,spread:20,type:"sawtooth"})}_start(i){i=this.toSeconds(i),this._forEach(s=>s.start(i))}_stop(i){i=this.toSeconds(i),this._forEach(s=>s.stop(i))}_restart(i){this._forEach(s=>s.restart(i))}_forEach(i){for(let s=0;s<this._oscillators.length;s++)i(this._oscillators[s],s)}get type(){return this._type}set type(i){this._type=i,this._forEach(s=>s.type=i)}get spread(){return this._spread}set spread(i){if(this._spread=i,this._oscillators.length>1){const s=-i/2,a=i/(this._oscillators.length-1);this._forEach((u,l)=>u.detune.value=s+a*l)}}get count(){return this._oscillators.length}set count(i){if(assertRange(i,1),this._oscillators.length!==i){this._forEach(s=>s.dispose()),this._oscillators=[];for(let s=0;s<i;s++){const a=new Oscillator({context:this.context,volume:-6-i*1.1,type:this._type,phase:this._phase+s/i*360,partialCount:this._partialCount,onstop:s===0?()=>this.onstop(this):noOp});this.type==="custom"&&(a.partials=this._partials),this.frequency.connect(a.frequency),this.detune.connect(a.detune),a.detune.overridden=!1,a.connect(this.output),this._oscillators[s]=a}this.spread=this._spread,this.state==="started"&&this._forEach(s=>s.start())}}get phase(){return this._phase}set phase(i){this._phase=i,this._forEach((s,a)=>s.phase=this._phase+a/this.count*360)}get baseType(){return this._oscillators[0].baseType}set baseType(i){this._forEach(s=>s.baseType=i),this._type=this._oscillators[0].type}get partials(){return this._oscillators[0].partials}set partials(i){this._partials=i,this._partialCount=this._partials.length,i.length&&(this._type="custom",this._forEach(s=>s.partials=i))}get partialCount(){return this._oscillators[0].partialCount}set partialCount(i){this._partialCount=i,this._forEach(s=>s.partialCount=i),this._type=this._oscillators[0].type}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this.frequency.dispose(),this.detune.dispose(),this._forEach(i=>i.dispose()),this}}class PWMOscillator extends Source{constructor(){super(optionsFromArguments(PWMOscillator.getDefaults(),arguments,["frequency","modulationFrequency"])),this.name="PWMOscillator",this.sourceType="pwm",this._scale=new Multiply({context:this.context,value:2});const i=optionsFromArguments(PWMOscillator.getDefaults(),arguments,["frequency","modulationFrequency"]);this._pulse=new PulseOscillator({context:this.context,frequency:i.modulationFrequency}),this._pulse.carrierType="sine",this.modulationFrequency=this._pulse.frequency,this._modulator=new Oscillator({context:this.context,detune:i.detune,frequency:i.frequency,onstop:()=>this.onstop(this),phase:i.phase}),this.frequency=this._modulator.frequency,this.detune=this._modulator.detune,this._modulator.chain(this._scale,this._pulse.width),this._pulse.connect(this.output),readOnly(this,["modulationFrequency","frequency","detune"])}static getDefaults(){return Object.assign(Source.getDefaults(),{detune:0,frequency:440,modulationFrequency:.4,phase:0,type:"pwm"})}_start(i){i=this.toSeconds(i),this._modulator.start(i),this._pulse.start(i)}_stop(i){i=this.toSeconds(i),this._modulator.stop(i),this._pulse.stop(i)}_restart(i){this._modulator.restart(i),this._pulse.restart(i)}get type(){return"pwm"}get baseType(){return"pwm"}get partials(){return[]}get partialCount(){return 0}get phase(){return this._modulator.phase}set phase(i){this._modulator.phase=i}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this._pulse.dispose(),this._scale.dispose(),this._modulator.dispose(),this}}const OmniOscillatorSourceMap={am:AMOscillator,fat:FatOscillator,fm:FMOscillator,oscillator:Oscillator,pulse:PulseOscillator,pwm:PWMOscillator};class OmniOscillator extends Source{constructor(){super(optionsFromArguments(OmniOscillator.getDefaults(),arguments,["frequency","type"])),this.name="OmniOscillator";const i=optionsFromArguments(OmniOscillator.getDefaults(),arguments,["frequency","type"]);this.frequency=new Signal({context:this.context,units:"frequency",value:i.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:i.detune}),readOnly(this,["frequency","detune"]),this.set(i)}static getDefaults(){return Object.assign(Oscillator.getDefaults(),FMOscillator.getDefaults(),AMOscillator.getDefaults(),FatOscillator.getDefaults(),PulseOscillator.getDefaults(),PWMOscillator.getDefaults())}_start(i){this._oscillator.start(i)}_stop(i){this._oscillator.stop(i)}_restart(i){return this._oscillator.restart(i),this}get type(){let i="";return["am","fm","fat"].some(s=>this._sourceType===s)&&(i=this._sourceType),i+this._oscillator.type}set type(i){i.substr(0,2)==="fm"?(this._createNewOscillator("fm"),this._oscillator=this._oscillator,this._oscillator.type=i.substr(2)):i.substr(0,2)==="am"?(this._createNewOscillator("am"),this._oscillator=this._oscillator,this._oscillator.type=i.substr(2)):i.substr(0,3)==="fat"?(this._createNewOscillator("fat"),this._oscillator=this._oscillator,this._oscillator.type=i.substr(3)):i==="pwm"?(this._createNewOscillator("pwm"),this._oscillator=this._oscillator):i==="pulse"?this._createNewOscillator("pulse"):(this._createNewOscillator("oscillator"),this._oscillator=this._oscillator,this._oscillator.type=i)}get partials(){return this._oscillator.partials}set partials(i){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partials=i)}get partialCount(){return this._oscillator.partialCount}set partialCount(i){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&(this._oscillator.partialCount=i)}set(i){return Reflect.has(i,"type")&&i.type&&(this.type=i.type),super.set(i),this}_createNewOscillator(i){if(i!==this._sourceType){this._sourceType=i;const s=OmniOscillatorSourceMap[i],a=this.now();if(this._oscillator){const u=this._oscillator;u.stop(a),this.context.setTimeout(()=>u.dispose(),this.blockTime)}this._oscillator=new s({context:this.context}),this.frequency.connect(this._oscillator.frequency),this.detune.connect(this._oscillator.detune),this._oscillator.connect(this.output),this._oscillator.onstop=()=>this.onstop(this),this.state==="started"&&this._oscillator.start(a)}}get phase(){return this._oscillator.phase}set phase(i){this._oscillator.phase=i}get sourceType(){return this._sourceType}set sourceType(i){let s="sine";this._oscillator.type!=="pwm"&&this._oscillator.type!=="pulse"&&(s=this._oscillator.type),i==="fm"?this.type="fm"+s:i==="am"?this.type="am"+s:i==="fat"?this.type="fat"+s:i==="oscillator"?this.type=s:i==="pulse"?this.type="pulse":i==="pwm"&&(this.type="pwm")}_getOscType(i,s){return i instanceof OmniOscillatorSourceMap[s]}get baseType(){return this._oscillator.baseType}set baseType(i){!this._getOscType(this._oscillator,"pulse")&&!this._getOscType(this._oscillator,"pwm")&&i!=="pulse"&&i!=="pwm"&&(this._oscillator.baseType=i)}get width(){if(this._getOscType(this._oscillator,"pulse"))return this._oscillator.width}get count(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.count}set count(i){this._getOscType(this._oscillator,"fat")&&isNumber(i)&&(this._oscillator.count=i)}get spread(){if(this._getOscType(this._oscillator,"fat"))return this._oscillator.spread}set spread(i){this._getOscType(this._oscillator,"fat")&&isNumber(i)&&(this._oscillator.spread=i)}get modulationType(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.modulationType}set modulationType(i){(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))&&isString(i)&&(this._oscillator.modulationType=i)}get modulationIndex(){if(this._getOscType(this._oscillator,"fm"))return this._oscillator.modulationIndex}get harmonicity(){if(this._getOscType(this._oscillator,"fm")||this._getOscType(this._oscillator,"am"))return this._oscillator.harmonicity}get modulationFrequency(){if(this._getOscType(this._oscillator,"pwm"))return this._oscillator.modulationFrequency}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){return generateWaveform(this,i)})}dispose(){return super.dispose(),this.detune.dispose(),this.frequency.dispose(),this._oscillator.dispose(),this}}class Add extends Signal{constructor(){super(Object.assign(optionsFromArguments(Add.getDefaults(),arguments,["value"]))),this.override=!1,this.name="Add",this._sum=new Gain({context:this.context}),this.input=this._sum,this.output=this._sum,this.addend=this._param,connectSeries(this._constantSource,this._sum)}static getDefaults(){return Object.assign(Signal.getDefaults(),{value:0})}dispose(){return super.dispose(),this._sum.dispose(),this}}class Scale extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(Scale.getDefaults(),arguments,["min","max"]))),this.name="Scale";const i=optionsFromArguments(Scale.getDefaults(),arguments,["min","max"]);this._mult=this.input=new Multiply({context:this.context,value:i.max-i.min}),this._add=this.output=new Add({context:this.context,value:i.min}),this._min=i.min,this._max=i.max,this.input.connect(this.output)}static getDefaults(){return Object.assign(SignalOperator.getDefaults(),{max:1,min:0})}get min(){return this._min}set min(i){this._min=i,this._setRange()}get max(){return this._max}set max(i){this._max=i,this._setRange()}_setRange(){this._add.value=this._min,this._mult.value=this._max-this._min}dispose(){return super.dispose(),this._add.dispose(),this._mult.dispose(),this}}class Zero extends SignalOperator{constructor(){super(Object.assign(optionsFromArguments(Zero.getDefaults(),arguments))),this.name="Zero",this._gain=new Gain({context:this.context}),this.output=this._gain,this.input=void 0,connect(this.context.getConstant(0),this._gain)}dispose(){return super.dispose(),disconnect(this.context.getConstant(0),this._gain),this}}class LFO extends ToneAudioNode{constructor(){super(optionsFromArguments(LFO.getDefaults(),arguments,["frequency","min","max"])),this.name="LFO",this._stoppedValue=0,this._units="number",this.convert=!0,this._fromType=Param.prototype._fromType,this._toType=Param.prototype._toType,this._is=Param.prototype._is,this._clampValue=Param.prototype._clampValue;const i=optionsFromArguments(LFO.getDefaults(),arguments,["frequency","min","max"]);this._oscillator=new Oscillator(i),this.frequency=this._oscillator.frequency,this._amplitudeGain=new Gain({context:this.context,gain:i.amplitude,units:"normalRange"}),this.amplitude=this._amplitudeGain.gain,this._stoppedSignal=new Signal({context:this.context,units:"audioRange",value:0}),this._zeros=new Zero({context:this.context}),this._a2g=new AudioToGain({context:this.context}),this._scaler=this.output=new Scale({context:this.context,max:i.max,min:i.min}),this.units=i.units,this.min=i.min,this.max=i.max,this._oscillator.chain(this._amplitudeGain,this._a2g,this._scaler),this._zeros.connect(this._a2g),this._stoppedSignal.connect(this._a2g),readOnly(this,["amplitude","frequency"]),this.phase=i.phase}static getDefaults(){return Object.assign(Oscillator.getDefaults(),{amplitude:1,frequency:"4n",max:1,min:0,type:"sine",units:"number"})}start(i){return i=this.toSeconds(i),this._stoppedSignal.setValueAtTime(0,i),this._oscillator.start(i),this}stop(i){return i=this.toSeconds(i),this._stoppedSignal.setValueAtTime(this._stoppedValue,i),this._oscillator.stop(i),this}sync(){return this._oscillator.sync(),this._oscillator.syncFrequency(),this}unsync(){return this._oscillator.unsync(),this._oscillator.unsyncFrequency(),this}_setStoppedValue(){this._stoppedValue=this._oscillator.getInitialValue(),this._stoppedSignal.value=this._stoppedValue}get min(){return this._toType(this._scaler.min)}set min(i){i=this._fromType(i),this._scaler.min=i}get max(){return this._toType(this._scaler.max)}set max(i){i=this._fromType(i),this._scaler.max=i}get type(){return this._oscillator.type}set type(i){this._oscillator.type=i,this._setStoppedValue()}get partials(){return this._oscillator.partials}set partials(i){this._oscillator.partials=i,this._setStoppedValue()}get phase(){return this._oscillator.phase}set phase(i){this._oscillator.phase=i,this._setStoppedValue()}get units(){return this._units}set units(i){const s=this.min,a=this.max;this._units=i,this.min=s,this.max=a}get state(){return this._oscillator.state}connect(i,s,a){return(i instanceof Param||i instanceof Signal)&&(this.convert=i.convert,this.units=i.units),connectSignal(this,i,s,a),this}dispose(){return super.dispose(),this._oscillator.dispose(),this._stoppedSignal.dispose(),this._zeros.dispose(),this._scaler.dispose(),this._a2g.dispose(),this._amplitudeGain.dispose(),this.amplitude.dispose(),this}}function range(c,i=1/0){const s=new WeakMap;return function(a,u){Reflect.defineProperty(a,u,{configurable:!0,enumerable:!0,get:function(){return s.get(this)},set:function(l){assertRange(l,c,i),s.set(this,l)}})}}function timeRange(c,i=1/0){const s=new WeakMap;return function(a,u){Reflect.defineProperty(a,u,{configurable:!0,enumerable:!0,get:function(){return s.get(this)},set:function(l){assertRange(this.toSeconds(l),c,i),s.set(this,l)}})}}let Player$1=class extends Source{constructor(){super(optionsFromArguments(Player$1.getDefaults(),arguments,["url","onload"])),this.name="Player",this._activeSources=new Set;const i=optionsFromArguments(Player$1.getDefaults(),arguments,["url","onload"]);this._buffer=new ToneAudioBuffer({onload:this._onload.bind(this,i.onload),onerror:i.onerror,reverse:i.reverse,url:i.url}),this.autostart=i.autostart,this._loop=i.loop,this._loopStart=i.loopStart,this._loopEnd=i.loopEnd,this._playbackRate=i.playbackRate,this.fadeIn=i.fadeIn,this.fadeOut=i.fadeOut}static getDefaults(){return Object.assign(Source.getDefaults(),{autostart:!1,fadeIn:0,fadeOut:0,loop:!1,loopEnd:0,loopStart:0,onload:noOp,onerror:noOp,playbackRate:1,reverse:!1})}load(i){return __awaiter(this,void 0,void 0,function*(){return yield this._buffer.load(i),this._onload(),this})}_onload(i=noOp){i(),this.autostart&&this.start()}_onSourceEnd(i){this.onstop(this),this._activeSources.delete(i),this._activeSources.size===0&&!this._synced&&this._state.getValueAtTime(this.now())==="started"&&(this._state.cancel(this.now()),this._state.setStateAtTime("stopped",this.now()))}start(i,s,a){return super.start(i,s,a),this}_start(i,s,a){this._loop?s=defaultArg(s,this._loopStart):s=defaultArg(s,0);const u=this.toSeconds(s),l=a;a=defaultArg(a,Math.max(this._buffer.duration-u,0));let h=this.toSeconds(a);h=h/this._playbackRate,i=this.toSeconds(i);const f=new ToneBufferSource({url:this._buffer,context:this.context,fadeIn:this.fadeIn,fadeOut:this.fadeOut,loop:this._loop,loopEnd:this._loopEnd,loopStart:this._loopStart,onended:this._onSourceEnd.bind(this),playbackRate:this._playbackRate}).connect(this.output);!this._loop&&!this._synced&&(this._state.cancel(i+h),this._state.setStateAtTime("stopped",i+h,{implicitEnd:!0})),this._activeSources.add(f),this._loop&&isUndef(l)?f.start(i,u):f.start(i,u,h-this.toSeconds(this.fadeOut))}_stop(i){const s=this.toSeconds(i);this._activeSources.forEach(a=>a.stop(s))}restart(i,s,a){return super.restart(i,s,a),this}_restart(i,s,a){this._stop(i),this._start(i,s,a)}seek(i,s){const a=this.toSeconds(s);if(this._state.getValueAtTime(a)==="started"){const u=this.toSeconds(i);this._stop(a),this._start(a,u)}return this}setLoopPoints(i,s){return this.loopStart=i,this.loopEnd=s,this}get loopStart(){return this._loopStart}set loopStart(i){this._loopStart=i,this.buffer.loaded&&assertRange(this.toSeconds(i),0,this.buffer.duration),this._activeSources.forEach(s=>{s.loopStart=i})}get loopEnd(){return this._loopEnd}set loopEnd(i){this._loopEnd=i,this.buffer.loaded&&assertRange(this.toSeconds(i),0,this.buffer.duration),this._activeSources.forEach(s=>{s.loopEnd=i})}get buffer(){return this._buffer}set buffer(i){this._buffer.set(i)}get loop(){return this._loop}set loop(i){if(this._loop!==i&&(this._loop=i,this._activeSources.forEach(s=>{s.loop=i}),i)){const s=this._state.getNextState("stopped",this.now());s&&this._state.cancel(s.time)}}get playbackRate(){return this._playbackRate}set playbackRate(i){this._playbackRate=i;const s=this.now(),a=this._state.getNextState("stopped",s);a&&a.implicitEnd&&(this._state.cancel(a.time),this._activeSources.forEach(u=>u.cancelStop())),this._activeSources.forEach(u=>{u.playbackRate.setValueAtTime(i,s)})}get reverse(){return this._buffer.reverse}set reverse(i){this._buffer.reverse=i}get loaded(){return this._buffer.loaded}dispose(){return super.dispose(),this._activeSources.forEach(i=>i.dispose()),this._activeSources.clear(),this._buffer.dispose(),this}};__decorate([timeRange(0)],Player$1.prototype,"fadeIn",void 0);__decorate([timeRange(0)],Player$1.prototype,"fadeOut",void 0);class GainToAudio extends SignalOperator{constructor(){super(...arguments),this.name="GainToAudio",this._norm=new WaveShaper({context:this.context,mapping:i=>Math.abs(i)*2-1}),this.input=this._norm,this.output=this._norm}dispose(){return super.dispose(),this._norm.dispose(),this}}class Envelope extends ToneAudioNode{constructor(){super(optionsFromArguments(Envelope.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="Envelope",this._sig=new Signal({context:this.context,value:0}),this.output=this._sig,this.input=void 0;const i=optionsFromArguments(Envelope.getDefaults(),arguments,["attack","decay","sustain","release"]);this.attack=i.attack,this.decay=i.decay,this.sustain=i.sustain,this.release=i.release,this.attackCurve=i.attackCurve,this.releaseCurve=i.releaseCurve,this.decayCurve=i.decayCurve}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{attack:.01,attackCurve:"linear",decay:.1,decayCurve:"exponential",release:1,releaseCurve:"exponential",sustain:.5})}get value(){return this.getValueAtTime(this.now())}_getCurve(i,s){if(isString(i))return i;{let a;for(a in EnvelopeCurves)if(EnvelopeCurves[a][s]===i)return a;return i}}_setCurve(i,s,a){if(isString(a)&&Reflect.has(EnvelopeCurves,a)){const u=EnvelopeCurves[a];isObject(u)?i!=="_decayCurve"&&(this[i]=u[s]):this[i]=u}else if(isArray(a)&&i!=="_decayCurve")this[i]=a;else throw new Error("Envelope: invalid curve: "+a)}get attackCurve(){return this._getCurve(this._attackCurve,"In")}set attackCurve(i){this._setCurve("_attackCurve","In",i)}get releaseCurve(){return this._getCurve(this._releaseCurve,"Out")}set releaseCurve(i){this._setCurve("_releaseCurve","Out",i)}get decayCurve(){return this._decayCurve}set decayCurve(i){assert(["linear","exponential"].some(s=>s===i),`Invalid envelope curve: ${i}`),this._decayCurve=i}triggerAttack(i,s=1){this.log("triggerAttack",i,s),i=this.toSeconds(i);let u=this.toSeconds(this.attack);const l=this.toSeconds(this.decay),h=this.getValueAtTime(i);if(h>0){const f=1/u;u=(1-h)/f}if(u<this.sampleTime)this._sig.cancelScheduledValues(i),this._sig.setValueAtTime(s,i);else if(this._attackCurve==="linear")this._sig.linearRampTo(s,u,i);else if(this._attackCurve==="exponential")this._sig.targetRampTo(s,u,i);else{this._sig.cancelAndHoldAtTime(i);let f=this._attackCurve;for(let d=1;d<f.length;d++)if(f[d-1]<=h&&h<=f[d]){f=this._attackCurve.slice(d),f[0]=h;break}this._sig.setValueCurveAtTime(f,i,u,s)}if(l&&this.sustain<1){const f=s*this.sustain,d=i+u;this.log("decay",d),this._decayCurve==="linear"?this._sig.linearRampToValueAtTime(f,l+d):this._sig.exponentialApproachValueAtTime(f,d,l)}return this}triggerRelease(i){this.log("triggerRelease",i),i=this.toSeconds(i);const s=this.getValueAtTime(i);if(s>0){const a=this.toSeconds(this.release);a<this.sampleTime?this._sig.setValueAtTime(0,i):this._releaseCurve==="linear"?this._sig.linearRampTo(0,a,i):this._releaseCurve==="exponential"?this._sig.targetRampTo(0,a,i):(assert(isArray(this._releaseCurve),"releaseCurve must be either 'linear', 'exponential' or an array"),this._sig.cancelAndHoldAtTime(i),this._sig.setValueCurveAtTime(this._releaseCurve,i,a,s))}return this}getValueAtTime(i){return this._sig.getValueAtTime(i)}triggerAttackRelease(i,s,a=1){return s=this.toSeconds(s),this.triggerAttack(s,a),this.triggerRelease(s+this.toSeconds(i)),this}cancel(i){return this._sig.cancelScheduledValues(this.toSeconds(i)),this}connect(i,s=0,a=0){return connectSignal(this,i,s,a),this}asArray(i=1024){return __awaiter(this,void 0,void 0,function*(){const s=i/this.context.sampleRate,a=new OfflineContext(1,s,this.context.sampleRate),u=this.toSeconds(this.attack)+this.toSeconds(this.decay),l=u+this.toSeconds(this.release),h=l*.1,f=l+h,d=new this.constructor(Object.assign(this.get(),{attack:s*this.toSeconds(this.attack)/f,decay:s*this.toSeconds(this.decay)/f,release:s*this.toSeconds(this.release)/f,context:a}));return d._sig.toDestination(),d.triggerAttackRelease(s*(u+h)/f,0),(yield a.render()).getChannelData(0)})}dispose(){return super.dispose(),this._sig.dispose(),this}}__decorate([timeRange(0)],Envelope.prototype,"attack",void 0);__decorate([timeRange(0)],Envelope.prototype,"decay",void 0);__decorate([range(0,1)],Envelope.prototype,"sustain",void 0);__decorate([timeRange(0)],Envelope.prototype,"release",void 0);const EnvelopeCurves=(()=>{let i,s;const a=[];for(i=0;i<128;i++)a[i]=Math.sin(i/(128-1)*(Math.PI/2));const u=[],l=6.4;for(i=0;i<128-1;i++){s=i/(128-1);const y=Math.sin(s*(Math.PI*2)*l-Math.PI/2)+1;u[i]=y/10+s*.83}u[128-1]=1;const h=[],f=5;for(i=0;i<128;i++)h[i]=Math.ceil(i/(128-1)*f)/f;const d=[];for(i=0;i<128;i++)s=i/(128-1),d[i]=.5*(1-Math.cos(Math.PI*s));const p=[];for(i=0;i<128;i++){s=i/(128-1);const y=Math.pow(s,3)*4+.2,v=Math.cos(y*Math.PI*2*s);p[i]=Math.abs(v*(1-s))}function g(y){const v=new Array(y.length);for(let _=0;_<y.length;_++)v[_]=1-y[_];return v}function m(y){return y.slice(0).reverse()}return{bounce:{In:g(p),Out:p},cosine:{In:a,Out:m(a)},exponential:"exponential",linear:"linear",ripple:{In:u,Out:g(u)},sine:{In:d,Out:g(d)},step:{In:h,Out:g(h)}}})();class Instrument extends ToneAudioNode{constructor(){super(optionsFromArguments(Instrument.getDefaults(),arguments)),this._scheduledEvents=[],this._synced=!1,this._original_triggerAttack=this.triggerAttack,this._original_triggerRelease=this.triggerRelease;const i=optionsFromArguments(Instrument.getDefaults(),arguments);this._volume=this.output=new Volume({context:this.context,volume:i.volume}),this.volume=this._volume.volume,readOnly(this,"volume")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{volume:0})}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",0)),this}_syncState(){let i=!1;return this._synced||(this._synced=!0,i=!0),i}_syncMethod(i,s){const a=this["_original_"+i]=this[i];this[i]=(...u)=>{const l=u[s],h=this.context.transport.schedule(f=>{u[s]=f,a.apply(this,u)},l);this._scheduledEvents.push(h)}}unsync(){return this._scheduledEvents.forEach(i=>this.context.transport.clear(i)),this._scheduledEvents=[],this._synced&&(this._synced=!1,this.triggerAttack=this._original_triggerAttack,this.triggerRelease=this._original_triggerRelease),this}triggerAttackRelease(i,s,a,u){const l=this.toSeconds(a),h=this.toSeconds(s);return this.triggerAttack(i,l,u),this.triggerRelease(l+h),this}dispose(){return super.dispose(),this._volume.dispose(),this.unsync(),this._scheduledEvents=[],this}}class Monophonic extends Instrument{constructor(){super(optionsFromArguments(Monophonic.getDefaults(),arguments));const i=optionsFromArguments(Monophonic.getDefaults(),arguments);this.portamento=i.portamento,this.onsilence=i.onsilence}static getDefaults(){return Object.assign(Instrument.getDefaults(),{detune:0,onsilence:noOp,portamento:0})}triggerAttack(i,s,a=1){this.log("triggerAttack",i,s,a);const u=this.toSeconds(s);return this._triggerEnvelopeAttack(u,a),this.setNote(i,u),this}triggerRelease(i){this.log("triggerRelease",i);const s=this.toSeconds(i);return this._triggerEnvelopeRelease(s),this}setNote(i,s){const a=this.toSeconds(s),u=i instanceof FrequencyClass?i.toFrequency():i;if(this.portamento>0&&this.getLevelAtTime(a)>.05){const l=this.toSeconds(this.portamento);this.frequency.exponentialRampTo(u,l,a)}else this.frequency.setValueAtTime(u,a);return this}}__decorate([timeRange(0)],Monophonic.prototype,"portamento",void 0);class AmplitudeEnvelope extends Envelope{constructor(){super(optionsFromArguments(AmplitudeEnvelope.getDefaults(),arguments,["attack","decay","sustain","release"])),this.name="AmplitudeEnvelope",this._gainNode=new Gain({context:this.context,gain:0}),this.output=this._gainNode,this.input=this._gainNode,this._sig.connect(this._gainNode.gain),this.output=this._gainNode,this.input=this._gainNode}dispose(){return super.dispose(),this._gainNode.dispose(),this}}class Synth extends Monophonic{constructor(){super(optionsFromArguments(Synth.getDefaults(),arguments)),this.name="Synth";const i=optionsFromArguments(Synth.getDefaults(),arguments);this.oscillator=new OmniOscillator(Object.assign({context:this.context,detune:i.detune,onstop:()=>this.onsilence(this)},i.oscillator)),this.frequency=this.oscillator.frequency,this.detune=this.oscillator.detune,this.envelope=new AmplitudeEnvelope(Object.assign({context:this.context},i.envelope)),this.oscillator.chain(this.envelope,this.output),readOnly(this,["oscillator","frequency","detune","envelope"])}static getDefaults(){return Object.assign(Monophonic.getDefaults(),{envelope:Object.assign(omitFromObject(Envelope.getDefaults(),Object.keys(ToneAudioNode.getDefaults())),{attack:.005,decay:.1,release:1,sustain:.3}),oscillator:Object.assign(omitFromObject(OmniOscillator.getDefaults(),[...Object.keys(Source.getDefaults()),"frequency","detune"]),{type:"triangle"})})}_triggerEnvelopeAttack(i,s){if(this.envelope.triggerAttack(i,s),this.oscillator.start(i),this.envelope.sustain===0){const a=this.toSeconds(this.envelope.attack),u=this.toSeconds(this.envelope.decay);this.oscillator.stop(i+a+u)}}_triggerEnvelopeRelease(i){this.envelope.triggerRelease(i),this.oscillator.stop(i+this.toSeconds(this.envelope.release))}getLevelAtTime(i){return i=this.toSeconds(i),this.envelope.getValueAtTime(i)}dispose(){return super.dispose(),this.oscillator.dispose(),this.envelope.dispose(),this}}class BiquadFilter extends ToneAudioNode{constructor(){super(optionsFromArguments(BiquadFilter.getDefaults(),arguments,["frequency","type"])),this.name="BiquadFilter";const i=optionsFromArguments(BiquadFilter.getDefaults(),arguments,["frequency","type"]);this._filter=this.context.createBiquadFilter(),this.input=this.output=this._filter,this.Q=new Param({context:this.context,units:"number",value:i.Q,param:this._filter.Q}),this.frequency=new Param({context:this.context,units:"frequency",value:i.frequency,param:this._filter.frequency}),this.detune=new Param({context:this.context,units:"cents",value:i.detune,param:this._filter.detune}),this.gain=new Param({context:this.context,units:"decibels",convert:!1,value:i.gain,param:this._filter.gain}),this.type=i.type}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{Q:1,type:"lowpass",frequency:350,detune:0,gain:0})}get type(){return this._filter.type}set type(i){assert(["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(i)!==-1,`Invalid filter type: ${i}`),this._filter.type=i}getFrequencyResponse(i=128){const s=new Float32Array(i);for(let h=0;h<i;h++){const d=Math.pow(h/i,2)*(2e4-20)+20;s[h]=d}const a=new Float32Array(i),u=new Float32Array(i),l=this.context.createBiquadFilter();return l.type=this.type,l.Q.value=this.Q.value,l.frequency.value=this.frequency.value,l.gain.value=this.gain.value,l.getFrequencyResponse(s,a,u),a}dispose(){return super.dispose(),this._filter.disconnect(),this.Q.dispose(),this.frequency.dispose(),this.gain.dispose(),this.detune.dispose(),this}}class Filter extends ToneAudioNode{constructor(){super(optionsFromArguments(Filter.getDefaults(),arguments,["frequency","type","rolloff"])),this.name="Filter",this.input=new Gain({context:this.context}),this.output=new Gain({context:this.context}),this._filters=[];const i=optionsFromArguments(Filter.getDefaults(),arguments,["frequency","type","rolloff"]);this._filters=[],this.Q=new Signal({context:this.context,units:"positive",value:i.Q}),this.frequency=new Signal({context:this.context,units:"frequency",value:i.frequency}),this.detune=new Signal({context:this.context,units:"cents",value:i.detune}),this.gain=new Signal({context:this.context,units:"decibels",convert:!1,value:i.gain}),this._type=i.type,this.rolloff=i.rolloff,readOnly(this,["detune","frequency","gain","Q"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{Q:1,detune:0,frequency:350,gain:0,rolloff:-12,type:"lowpass"})}get type(){return this._type}set type(i){assert(["lowpass","highpass","bandpass","lowshelf","highshelf","notch","allpass","peaking"].indexOf(i)!==-1,`Invalid filter type: ${i}`),this._type=i,this._filters.forEach(a=>a.type=i)}get rolloff(){return this._rolloff}set rolloff(i){const s=isNumber(i)?i:parseInt(i,10),a=[-12,-24,-48,-96];let u=a.indexOf(s);assert(u!==-1,`rolloff can only be ${a.join(", ")}`),u+=1,this._rolloff=s,this.input.disconnect(),this._filters.forEach(l=>l.disconnect()),this._filters=new Array(u);for(let l=0;l<u;l++){const h=new BiquadFilter({context:this.context});h.type=this._type,this.frequency.connect(h.frequency),this.detune.connect(h.detune),this.Q.connect(h.Q),this.gain.connect(h.gain),this._filters[l]=h}this._internalChannels=this._filters,connectSeries(this.input,...this._internalChannels,this.output)}getFrequencyResponse(i=128){const s=new BiquadFilter({frequency:this.frequency.value,gain:this.gain.value,Q:this.Q.value,type:this._type,detune:this.detune.value}),a=new Float32Array(i).map(()=>1);return this._filters.forEach(()=>{s.getFrequencyResponse(i).forEach((l,h)=>a[h]*=l)}),s.dispose(),a}dispose(){return super.dispose(),this._filters.forEach(i=>{i.dispose()}),writable(this,["detune","frequency","gain","Q"]),this.frequency.dispose(),this.Q.dispose(),this.detune.dispose(),this.gain.dispose(),this}}class MembraneSynth extends Synth{constructor(){super(optionsFromArguments(MembraneSynth.getDefaults(),arguments)),this.name="MembraneSynth",this.portamento=0;const i=optionsFromArguments(MembraneSynth.getDefaults(),arguments);this.pitchDecay=i.pitchDecay,this.octaves=i.octaves,readOnly(this,["oscillator","envelope"])}static getDefaults(){return deepMerge(Monophonic.getDefaults(),Synth.getDefaults(),{envelope:{attack:.001,attackCurve:"exponential",decay:.4,release:1.4,sustain:.01},octaves:10,oscillator:{type:"sine"},pitchDecay:.05})}setNote(i,s){const a=this.toSeconds(s),u=this.toFrequency(i instanceof FrequencyClass?i.toFrequency():i),l=u*this.octaves;return this.oscillator.frequency.setValueAtTime(l,a),this.oscillator.frequency.exponentialRampToValueAtTime(u,a+this.toSeconds(this.pitchDecay)),this}dispose(){return super.dispose(),this}}__decorate([range(0)],MembraneSynth.prototype,"octaves",void 0);__decorate([timeRange(0)],MembraneSynth.prototype,"pitchDecay",void 0);const workletContext=new Set;function addToWorklet(c){workletContext.add(c)}function registerProcessor(c,i){const s=`registerProcessor("${c}", ${i})`;workletContext.add(s)}const toneAudioWorkletProcessor=`
	/**
	 * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. 
	 */
	class ToneAudioWorkletProcessor extends AudioWorkletProcessor {

		constructor(options) {
			
			super(options);
			/**
			 * If the processor was disposed or not. Keep alive until it's disposed.
			 */
			this.disposed = false;
		   	/** 
			 * The number of samples in the processing block
			 */
			this.blockSize = 128;
			/**
			 * the sample rate
			 */
			this.sampleRate = sampleRate;

			this.port.onmessage = (event) => {
				// when it receives a dispose 
				if (event.data === "dispose") {
					this.disposed = true;
				}
			};
		}
	}
`;addToWorklet(toneAudioWorkletProcessor);const singleIOProcess=`
	/**
	 * Abstract class for a single input/output processor. 
	 * has a 'generate' function which processes one sample at a time
	 */
	class SingleIOProcessor extends ToneAudioWorkletProcessor {

		constructor(options) {
			super(Object.assign(options, {
				numberOfInputs: 1,
				numberOfOutputs: 1
			}));
			/**
			 * Holds the name of the parameter and a single value of that
			 * parameter at the current sample
			 * @type { [name: string]: number }
			 */
			this.params = {}
		}

		/**
		 * Generate an output sample from the input sample and parameters
		 * @abstract
		 * @param input number
		 * @param channel number
		 * @param parameters { [name: string]: number }
		 * @returns number
		 */
		generate(){}

		/**
		 * Update the private params object with the 
		 * values of the parameters at the given index
		 * @param parameters { [name: string]: Float32Array },
		 * @param index number
		 */
		updateParams(parameters, index) {
			for (const paramName in parameters) {
				const param = parameters[paramName];
				if (param.length > 1) {
					this.params[paramName] = parameters[paramName][index];
				} else {
					this.params[paramName] = parameters[paramName][0];
				}
			}
		}

		/**
		 * Process a single frame of the audio
		 * @param inputs Float32Array[][]
		 * @param outputs Float32Array[][]
		 */
		process(inputs, outputs, parameters) {
			const input = inputs[0];
			const output = outputs[0];
			// get the parameter values
			const channelCount = Math.max(input && input.length || 0, output.length);
			for (let sample = 0; sample < this.blockSize; sample++) {
				this.updateParams(parameters, sample);
				for (let channel = 0; channel < channelCount; channel++) {
					const inputSample = input && input.length ? input[channel][sample] : 0;
					output[channel][sample] = this.generate(inputSample, channel, this.params);
				}
			}
			return !this.disposed;
		}
	};
`;addToWorklet(singleIOProcess);const delayLine=`
	/**
	 * A multichannel buffer for use within an AudioWorkletProcessor as a delay line
	 */
	class DelayLine {
		
		constructor(size, channels) {
			this.buffer = [];
			this.writeHead = []
			this.size = size;

			// create the empty channels
			for (let i = 0; i < channels; i++) {
				this.buffer[i] = new Float32Array(this.size);
				this.writeHead[i] = 0;
			}
		}

		/**
		 * Push a value onto the end
		 * @param channel number
		 * @param value number
		 */
		push(channel, value) {
			this.writeHead[channel] += 1;
			if (this.writeHead[channel] > this.size) {
				this.writeHead[channel] = 0;
			}
			this.buffer[channel][this.writeHead[channel]] = value;
		}

		/**
		 * Get the recorded value of the channel given the delay
		 * @param channel number
		 * @param delay number delay samples
		 */
		get(channel, delay) {
			let readHead = this.writeHead[channel] - Math.floor(delay);
			if (readHead < 0) {
				readHead += this.size;
			}
			return this.buffer[channel][readHead];
		}
	}
`;addToWorklet(delayLine);const workletName$1="feedback-comb-filter",feedbackCombFilter=`
	class FeedbackCombFilterWorklet extends SingleIOProcessor {

		constructor(options) {
			super(options);
			this.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);
		}

		static get parameterDescriptors() {
			return [{
				name: "delayTime",
				defaultValue: 0.1,
				minValue: 0,
				maxValue: 1,
				automationRate: "k-rate"
			}, {
				name: "feedback",
				defaultValue: 0.5,
				minValue: 0,
				maxValue: 0.9999,
				automationRate: "k-rate"
			}];
		}

		generate(input, channel, parameters) {
			const delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);
			this.delayLine.push(channel, input + delayedSample * parameters.feedback);
			return delayedSample;
		}
	}
`;registerProcessor(workletName$1,feedbackCombFilter);class Sampler extends Instrument{constructor(){super(optionsFromArguments(Sampler.getDefaults(),arguments,["urls","onload","baseUrl"],"urls")),this.name="Sampler",this._activeSources=new Map;const i=optionsFromArguments(Sampler.getDefaults(),arguments,["urls","onload","baseUrl"],"urls"),s={};Object.keys(i.urls).forEach(a=>{const u=parseInt(a,10);if(assert(isNote(a)||isNumber(u)&&isFinite(u),`url key is neither a note or midi pitch: ${a}`),isNote(a)){const l=new FrequencyClass(this.context,a).toMidi();s[l]=i.urls[a]}else isNumber(u)&&isFinite(u)&&(s[u]=i.urls[u])}),this._buffers=new ToneAudioBuffers({urls:s,onload:i.onload,baseUrl:i.baseUrl,onerror:i.onerror}),this.attack=i.attack,this.release=i.release,this.curve=i.curve,this._buffers.loaded&&Promise.resolve().then(i.onload)}static getDefaults(){return Object.assign(Instrument.getDefaults(),{attack:0,baseUrl:"",curve:"exponential",onload:noOp,onerror:noOp,release:.1,urls:{}})}_findClosest(i){let a=0;for(;a<96;){if(this._buffers.has(i+a))return-a;if(this._buffers.has(i-a))return a;a++}throw new Error(`No available buffers for note: ${i}`)}triggerAttack(i,s,a=1){return this.log("triggerAttack",i,s,a),Array.isArray(i)||(i=[i]),i.forEach(u=>{const l=ftomf(new FrequencyClass(this.context,u).toFrequency()),h=Math.round(l),f=l-h,d=this._findClosest(h),p=h-d,g=this._buffers.get(p),m=intervalToFrequencyRatio(d+f),y=new ToneBufferSource({url:g,context:this.context,curve:this.curve,fadeIn:this.attack,fadeOut:this.release,playbackRate:m}).connect(this.output);y.start(s,0,g.duration/m,a),isArray(this._activeSources.get(h))||this._activeSources.set(h,[]),this._activeSources.get(h).push(y),y.onended=()=>{if(this._activeSources&&this._activeSources.has(h)){const v=this._activeSources.get(h),_=v.indexOf(y);_!==-1&&v.splice(_,1)}}}),this}triggerRelease(i,s){return this.log("triggerRelease",i,s),Array.isArray(i)||(i=[i]),i.forEach(a=>{const u=new FrequencyClass(this.context,a).toMidi();if(this._activeSources.has(u)&&this._activeSources.get(u).length){const l=this._activeSources.get(u);s=this.toSeconds(s),l.forEach(h=>{h.stop(s)}),this._activeSources.set(u,[])}}),this}releaseAll(i){const s=this.toSeconds(i);return this._activeSources.forEach(a=>{for(;a.length;)a.shift().stop(s)}),this}sync(){return this._syncState()&&(this._syncMethod("triggerAttack",1),this._syncMethod("triggerRelease",1)),this}triggerAttackRelease(i,s,a,u=1){const l=this.toSeconds(a);return this.triggerAttack(i,l,u),isArray(s)?(assert(isArray(i),"notes must be an array when duration is array"),i.forEach((h,f)=>{const d=s[Math.min(f,s.length-1)];this.triggerRelease(h,l+this.toSeconds(d))})):this.triggerRelease(i,l+this.toSeconds(s)),this}add(i,s,a){if(assert(isNote(i)||isFinite(i),`note must be a pitch or midi: ${i}`),isNote(i)){const u=new FrequencyClass(this.context,i).toMidi();this._buffers.add(u,s,a)}else this._buffers.add(i,s,a);return this}get loaded(){return this._buffers.loaded}dispose(){return super.dispose(),this._buffers.dispose(),this._activeSources.forEach(i=>{i.forEach(s=>s.dispose())}),this._activeSources.clear(),this}}__decorate([timeRange(0)],Sampler.prototype,"attack",void 0);__decorate([timeRange(0)],Sampler.prototype,"release",void 0);class CrossFade extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(CrossFade.getDefaults(),arguments,["fade"]))),this.name="CrossFade",this._panner=this.context.createStereoPanner(),this._split=this.context.createChannelSplitter(2),this._g2a=new GainToAudio({context:this.context}),this.a=new Gain({context:this.context,gain:0}),this.b=new Gain({context:this.context,gain:0}),this.output=new Gain({context:this.context}),this._internalChannels=[this.a,this.b];const i=optionsFromArguments(CrossFade.getDefaults(),arguments,["fade"]);this.fade=new Signal({context:this.context,units:"normalRange",value:i.fade}),readOnly(this,"fade"),this.context.getConstant(1).connect(this._panner),this._panner.connect(this._split),this._panner.channelCount=1,this._panner.channelCountMode="explicit",connect(this._split,this.a.gain,0),connect(this._split,this.b.gain,1),this.fade.chain(this._g2a,this._panner.pan),this.a.connect(this.output),this.b.connect(this.output)}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{fade:.5})}dispose(){return super.dispose(),this.a.dispose(),this.b.dispose(),this.output.dispose(),this.fade.dispose(),this._g2a.dispose(),this._panner.disconnect(),this._split.disconnect(),this}}class Effect extends ToneAudioNode{constructor(i){super(i),this.name="Effect",this._dryWet=new CrossFade({context:this.context}),this.wet=this._dryWet.fade,this.effectSend=new Gain({context:this.context}),this.effectReturn=new Gain({context:this.context}),this.input=new Gain({context:this.context}),this.output=this._dryWet,this.input.fan(this._dryWet.a,this.effectSend),this.effectReturn.connect(this._dryWet.b),this.wet.setValueAtTime(i.wet,0),this._internalChannels=[this.effectReturn,this.effectSend],readOnly(this,"wet")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{wet:1})}connectEffect(i){return this._internalChannels.push(i),this.effectSend.chain(i,this.effectReturn),this}dispose(){return super.dispose(),this._dryWet.dispose(),this.effectSend.dispose(),this.effectReturn.dispose(),this.wet.dispose(),this}}class LFOEffect extends Effect{constructor(i){super(i),this.name="LFOEffect",this._lfo=new LFO({context:this.context,frequency:i.frequency,amplitude:i.depth}),this.depth=this._lfo.amplitude,this.frequency=this._lfo.frequency,this.type=i.type,readOnly(this,["frequency","depth"])}static getDefaults(){return Object.assign(Effect.getDefaults(),{frequency:1,type:"sine",depth:1})}start(i){return this._lfo.start(i),this}stop(i){return this._lfo.stop(i),this}sync(){return this._lfo.sync(),this}unsync(){return this._lfo.unsync(),this}get type(){return this._lfo.type}set type(i){this._lfo.type=i}dispose(){return super.dispose(),this._lfo.dispose(),this.frequency.dispose(),this.depth.dispose(),this}}class AutoFilter extends LFOEffect{constructor(){super(optionsFromArguments(AutoFilter.getDefaults(),arguments,["frequency","baseFrequency","octaves"])),this.name="AutoFilter";const i=optionsFromArguments(AutoFilter.getDefaults(),arguments,["frequency","baseFrequency","octaves"]);this.filter=new Filter(Object.assign(i.filter,{context:this.context})),this.connectEffect(this.filter),this._lfo.connect(this.filter.frequency),this.octaves=i.octaves,this.baseFrequency=i.baseFrequency}static getDefaults(){return Object.assign(LFOEffect.getDefaults(),{baseFrequency:200,octaves:2.6,filter:{type:"lowpass",rolloff:-12,Q:1}})}get baseFrequency(){return this._lfo.min}set baseFrequency(i){this._lfo.min=this.toFrequency(i),this.octaves=this._octaves}get octaves(){return this._octaves}set octaves(i){this._octaves=i,this._lfo.max=this._lfo.min*Math.pow(2,i)}dispose(){return super.dispose(),this.filter.dispose(),this}}class Panner extends ToneAudioNode{constructor(){super(Object.assign(optionsFromArguments(Panner.getDefaults(),arguments,["pan"]))),this.name="Panner",this._panner=this.context.createStereoPanner(),this.input=this._panner,this.output=this._panner;const i=optionsFromArguments(Panner.getDefaults(),arguments,["pan"]);this.pan=new Param({context:this.context,param:this._panner.pan,value:i.pan,minValue:-1,maxValue:1}),this._panner.channelCount=i.channelCount,this._panner.channelCountMode="explicit",readOnly(this,"pan")}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{pan:0,channelCount:1})}dispose(){return super.dispose(),this._panner.disconnect(),this.pan.dispose(),this}}const workletName="bit-crusher",bitCrusherWorklet=`
	class BitCrusherWorklet extends SingleIOProcessor {

		static get parameterDescriptors() {
			return [{
				name: "bits",
				defaultValue: 12,
				minValue: 1,
				maxValue: 16,
				automationRate: 'k-rate'
			}];
		}

		generate(input, _channel, parameters) {
			const step = Math.pow(0.5, parameters.bits - 1);
			const val = step * Math.floor(input / step + 0.5);
			return val;
		}
	}
`;registerProcessor(workletName,bitCrusherWorklet);class Solo extends ToneAudioNode{constructor(){super(optionsFromArguments(Solo.getDefaults(),arguments,["solo"])),this.name="Solo";const i=optionsFromArguments(Solo.getDefaults(),arguments,["solo"]);this.input=this.output=new Gain({context:this.context}),Solo._allSolos.has(this.context)||Solo._allSolos.set(this.context,new Set),Solo._allSolos.get(this.context).add(this),this.solo=i.solo}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{solo:!1})}get solo(){return this._isSoloed()}set solo(i){i?this._addSolo():this._removeSolo(),Solo._allSolos.get(this.context).forEach(s=>s._updateSolo())}get muted(){return this.input.gain.value===0}_addSolo(){Solo._soloed.has(this.context)||Solo._soloed.set(this.context,new Set),Solo._soloed.get(this.context).add(this)}_removeSolo(){Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).delete(this)}_isSoloed(){return Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).has(this)}_noSolos(){return!Solo._soloed.has(this.context)||Solo._soloed.has(this.context)&&Solo._soloed.get(this.context).size===0}_updateSolo(){this._isSoloed()?this.input.gain.value=1:this._noSolos()?this.input.gain.value=1:this.input.gain.value=0}dispose(){return super.dispose(),Solo._allSolos.get(this.context).delete(this),this._removeSolo(),this}}Solo._allSolos=new Map;Solo._soloed=new Map;class PanVol extends ToneAudioNode{constructor(){super(optionsFromArguments(PanVol.getDefaults(),arguments,["pan","volume"])),this.name="PanVol";const i=optionsFromArguments(PanVol.getDefaults(),arguments,["pan","volume"]);this._panner=this.input=new Panner({context:this.context,pan:i.pan,channelCount:i.channelCount}),this.pan=this._panner.pan,this._volume=this.output=new Volume({context:this.context,volume:i.volume}),this.volume=this._volume.volume,this._panner.connect(this._volume),this.mute=i.mute,readOnly(this,["pan","volume"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{mute:!1,pan:0,volume:0,channelCount:1})}get mute(){return this._volume.mute}set mute(i){this._volume.mute=i}dispose(){return super.dispose(),this._panner.dispose(),this.pan.dispose(),this._volume.dispose(),this.volume.dispose(),this}}class Channel extends ToneAudioNode{constructor(){super(optionsFromArguments(Channel.getDefaults(),arguments,["volume","pan"])),this.name="Channel";const i=optionsFromArguments(Channel.getDefaults(),arguments,["volume","pan"]);this._solo=this.input=new Solo({solo:i.solo,context:this.context}),this._panVol=this.output=new PanVol({context:this.context,pan:i.pan,volume:i.volume,mute:i.mute,channelCount:i.channelCount}),this.pan=this._panVol.pan,this.volume=this._panVol.volume,this._solo.connect(this._panVol),readOnly(this,["pan","volume"])}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{pan:0,volume:0,mute:!1,solo:!1,channelCount:1})}get solo(){return this._solo.solo}set solo(i){this._solo.solo=i}get muted(){return this._solo.muted||this.mute}get mute(){return this._panVol.mute}set mute(i){this._panVol.mute=i}_getBus(i){return Channel.buses.has(i)||Channel.buses.set(i,new Gain({context:this.context})),Channel.buses.get(i)}send(i,s=0){const a=this._getBus(i),u=new Gain({context:this.context,units:"decibels",gain:s});return this.connect(u),u.connect(a),u}receive(i){return this._getBus(i).connect(this),this}dispose(){return super.dispose(),this._panVol.dispose(),this.pan.dispose(),this.volume.dispose(),this._solo.dispose(),this}}Channel.buses=new Map;class Listener extends ToneAudioNode{constructor(){super(...arguments),this.name="Listener",this.positionX=new Param({context:this.context,param:this.context.rawContext.listener.positionX}),this.positionY=new Param({context:this.context,param:this.context.rawContext.listener.positionY}),this.positionZ=new Param({context:this.context,param:this.context.rawContext.listener.positionZ}),this.forwardX=new Param({context:this.context,param:this.context.rawContext.listener.forwardX}),this.forwardY=new Param({context:this.context,param:this.context.rawContext.listener.forwardY}),this.forwardZ=new Param({context:this.context,param:this.context.rawContext.listener.forwardZ}),this.upX=new Param({context:this.context,param:this.context.rawContext.listener.upX}),this.upY=new Param({context:this.context,param:this.context.rawContext.listener.upY}),this.upZ=new Param({context:this.context,param:this.context.rawContext.listener.upZ})}static getDefaults(){return Object.assign(ToneAudioNode.getDefaults(),{positionX:0,positionY:0,positionZ:0,forwardX:0,forwardY:0,forwardZ:-1,upX:0,upY:1,upZ:0})}dispose(){return super.dispose(),this.positionX.dispose(),this.positionY.dispose(),this.positionZ.dispose(),this.forwardX.dispose(),this.forwardY.dispose(),this.forwardZ.dispose(),this.upX.dispose(),this.upY.dispose(),this.upZ.dispose(),this}}onContextInit(c=>{c.listener=new Listener({context:c})});onContextClose(c=>{c.listener.dispose()});getContext().transport;getContext().destination;getContext().destination;getContext().listener;getContext().draw;getContext();class Controller{constructor(i,s){q(this,"transformMatrix");q(this,"position");q(this,"velocity");q(this,"forward");q(this,"up");q(this,"right");q(this,"rotation");q(this,"noise");this.keyboard=i,this.mouse=s,this.transformMatrix=create$5(),this.position=fromValues$1(0,0,-300),this.velocity=fromValues$1(0,0,0),this.rotation=create$2(),this.forward=create$4(),this.right=create$4(),this.up=fromValues$1(0,1,0),this.noise=null}init(){this.noise=new Noise("pink");const i=new AutoFilter({frequency:"4n",baseFrequency:200,depth:0}).toDestination().start();this.noise.connect(i)}update(i){const s=this.keyboard.keydown("shift")?20:5;zero(this.velocity),this.keyboard.keydown("w")&&(sub(this.velocity,this.velocity,this.forward),add(this.velocity,this.velocity,this.up)),this.keyboard.keydown("s")&&add(this.velocity,this.velocity,this.forward),this.keyboard.keydown("a")&&sub(this.velocity,this.velocity,this.right),this.keyboard.keydown("d")&&add(this.velocity,this.velocity,this.right),this.keyboard.keydown("r")&&add(this.velocity,this.velocity,this.up),this.keyboard.keydown("f")&&sub(this.velocity,this.velocity,this.up),scale(this.velocity,this.velocity,s),length(this.velocity)>0?this.noise!==null&&this.noise.state:this.noise!=null&&this.noise.state,this.keyboard.keydown("q")&&rotateZ(this.rotation,this.rotation,toRadian(1)),this.keyboard.keydown("e")&&rotateZ(this.rotation,this.rotation,toRadian(-1));const a=fromValues$1(2e6,100,100),u=sub(create$4(),this.position,a);normalize$2(u,u);const l=rotationTo(create$2(),scale(create$4(),this.up,1),scale(create$4(),u,1));multiply$1(l,l,this.rotation),slerp(this.rotation,this.rotation,l,.01*i),rotateY(this.rotation,this.rotation,toRadian(-this.mouse.position.x*.08)),identity(this.transformMatrix);const h=fromQuat(create$5(),this.rotation);translate(this.transformMatrix,this.transformMatrix,this.position),translate(this.transformMatrix,this.transformMatrix,scale(u,u,100)),mul(this.transformMatrix,this.transformMatrix,h),normalize$2(this.right,this.transformMatrix.slice(0,3)),normalize$2(this.up,this.transformMatrix.slice(4,7)),normalize$2(this.forward,this.transformMatrix.slice(8,11))}getTransformMatrix(){return this.transformMatrix}}class Keyboard{constructor(){q(this,"keys");q(this,"bufferKeys");q(this,"lastKeys");this.keys=new Map,this.bufferKeys=new Map,this.lastKeys=new Map}init(){const i=a=>{a.preventDefault(),this.bufferKeys.set(a.key.toLowerCase(),!0)},s=({key:a})=>{this.bufferKeys.delete(a.toLowerCase())};document.addEventListener("keydown",i),document.addEventListener("keyup",s)}update(){this.lastKeys=new Map(this.keys),this.keys=new Map(this.bufferKeys)}keydown(i){return this.keys.get(i)===!0}keyup(i){return this.keys.get(i)!==!0}keypress(i){return this.keys.get(i)===!0&&this.lastKeys.get(i)!==!0}}const VertexShader=`struct Uniforms {\r
  modelViewProjectionMatrix : mat4x4<f32>,\r
  stride: i32,\r
  position: vec3<f32>\r
};\r
\r
@binding(0) @group(0) var<uniform> uniforms : Uniforms;\r
\r
struct Lights\r
{\r
  position: vec3<f32>,\r
  diffuse: vec3<f32>\r
};\r
\r
fn lambert(N: vec3<f32>, L: vec3<f32>) -> f32\r
{\r
  var nrmN = normalize(N);\r
  var nrmL = normalize(L);\r
  var result = dot(nrmN, nrmL);\r
  return max(result, 0.0);\r
}\r
\r
struct VertexOutput {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) fragPosition: vec4<f32>,\r
  @location(1) normal: vec3<f32>,\r
  @location(2) color: vec3<f32>,\r
};\r
\r
@vertex\r
fn main(@location(0) position : vec4<f32>,\r
        @location(1) normal : vec4<f32>) -> VertexOutput {\r
\r
  var light: Lights;\r
  light.position = normalize(-position.xyz);\r
  light.diffuse = vec3<f32>(1.0, 1.0, 1.0);\r
\r
  var output : VertexOutput;\r
  output.Position = uniforms.modelViewProjectionMatrix * position;\r
  output.normal = normal.xyz;\r
\r
  var result = vec3<f32>(0.4, 0.4, 0.4) + light.diffuse * lambert(normal.xyz, light.position);\r
\r
  output.fragPosition = position;\r
  output.color = result;\r
  return output;\r
}\r
`,FragmentShader=`struct Uniforms {
  modelViewProjectionMatrix : mat4x4<f32>,
  stride: i32,
  position: vec3<f32>,
  time: f32,
};
@binding(0) @group(0) var<uniform> uniforms : Uniforms;
@binding(1) @group(0) var<storage, read> corners : array<u32, 32768>;

#import density

fn getTriPlanarBlend(_wNorm: vec3<f32>) -> vec3<f32> {
	// in wNorm is the world-space normal of the fragment
	var blending = abs( _wNorm );
  blending.x = max(blending.x, 0.00001);
  blending.y = max(blending.y, 0.00001);
  blending.z = max(blending.z, 0.00001);
	blending = normalize(blending); // Force weights to sum to 1.0
	let b = (blending.x + blending.y + blending.z);
	blending = blending / b;
	return blending;
}

const normalRepeat = 0.01;

const lower = 20.0;
const upper = 49.0;
const diff = 29.0;

fn getFade(y: f32) -> f32 {
  if (y < lower) {
    return 1.0;
  }
  return max(((diff - (min(y, upper) - lower)) / diff), 0.1);
}

fn rand(co: vec2<f32>) -> f32 {
    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
}

fn permute4(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }
fn fade2(t: vec2<f32>) -> vec2<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise2(P: vec2<f32>) -> f32 {
  var Pi: vec4<f32> = floor(P.xyxy) + vec4<f32>(0., 0., 1., 1.);
  let Pf = fract(P.xyxy) - vec4<f32>(0., 0., 1., 1.);
  Pi = Pi % vec4<f32>(289.); // To avoid truncation effects in permutation
  let ix = Pi.xzxz;
  let iy = Pi.yyww;
  let fx = Pf.xzxz;
  let fy = Pf.yyww;
  let i = permute4(permute4(ix) + iy);
  var gx: vec4<f32> = 2. * fract(i * 0.0243902439) - 1.; // 1/41 = 0.024...
  let gy = abs(gx) - 0.5;
  let tx = floor(gx + 0.5);
  gx = gx - tx;
  var g00: vec2<f32> = vec2<f32>(gx.x, gy.x);
  var g10: vec2<f32> = vec2<f32>(gx.y, gy.y);
  var g01: vec2<f32> = vec2<f32>(gx.z, gy.z);
  var g11: vec2<f32> = vec2<f32>(gx.w, gy.w);
  let norm = 1.79284291400159 - 0.85373472095314 *
      vec4<f32>(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));
  g00 = g00 * norm.x;
  g01 = g01 * norm.y;
  g10 = g10 * norm.z;
  g11 = g11 * norm.w;
  let n00 = dot(g00, vec2<f32>(fx.x, fy.x));
  let n10 = dot(g10, vec2<f32>(fx.y, fy.y));
  let n01 = dot(g01, vec2<f32>(fx.z, fy.z));
  let n11 = dot(g11, vec2<f32>(fx.w, fy.w));
  let fade_xy = fade2(Pf.xy);
  let n_x = mix(vec2<f32>(n00, n01), vec2<f32>(n10, n11), vec2<f32>(fade_xy.x));
  let n_xy = mix(n_x.x, n_x.y, fade_xy.y);
  return 2.3 * n_xy;
}

fn random2(p: vec2<f32>) -> vec2<f32> {
    return fract(sin(vec2<f32>(dot(p,vec2<f32>(127.1,311.7)),dot(p,vec2<f32>(269.5,183.3))))*43758.5453);
}

fn cellular(co: vec2<f32>) -> vec3<f32> {
    var color = vec3<f32>(.0);
    let position = co * 1.;

    // Tile the space
    let i_st = floor(position);
    let f_st = fract(position);

    var m_dist = 1.;  // minimum distance

    for (var y= -1; y <= 1; y++) {
        for (var x= -1; x <= 1; x++) {
            // Neighbor place in the grid
            let neighbor = vec2<f32>(f32(x),f32(y));

            // Random position from current + neighbor place in the grid
            let p = random2(i_st + neighbor);

			// Vector between the pixel and the point
            let diff = neighbor + p - f_st;

            // Distance to the point
            let dist = length(diff);

            // Keep the closer distance
            m_dist = min(m_dist, dist);
        }
    }

    // Draw the min distance (distance field)
    color = color + m_dist;

    return color;
}

fn samp(co: vec2<f32>, material: u32) -> vec3<f32> {
  if (material == MATERIAL_ROCK) {
    // Stone
    let cell =  cellular(co * 20.0);
    let n = (1.0 + sin((co.x + perlinNoise2(co * 5.0) / 2.0) * 50.0)) / 2.0;
    let color = mix(vec3<f32>(0.3, 0.3, 0.3), vec3<f32>(0.4,0.4,0.4),(n * 0.4 + cell * 0.6));
    return color;
  }

  if (material == MATERIAL_WOOD) {
    // Wood
    let v = fract((perlinNoise2(co * vec2<f32>(10.0, 0.2))*0.5+0.5)*5.0) + perlinNoise2(co * vec2<f32>(100.0,20.0))*0.2;

    return mix(vec3<f32>(0.19, 0.13, 0.06), vec3<f32>(0.52, 0.32, 0.19), v);
  }

  if (material == MATERIAL_FIRE) {
    let low = vec3<f32>(234.0/255.0, 91.0/255.0, 13.0/255.0);
    let high = vec3<f32>(228.0/255.0, 2.0/255.0, 47.0/255.0);

    let offset = co + vec2(sin(uniforms.time / 1000.0) * 500.0, cos(uniforms.time / 1000.0) * 500.0);
    let offset2 = co + vec2(cos(uniforms.time / 1000.0) * 500.0, sin(-uniforms.time / 1000.0) * 500.0);

    let samp = mix(low, high, perlinNoise2(offset / 500.0));
    let samp2 = mix(low, high, perlinNoise2(offset2 / 500.0));

    return mix(samp, samp2, 0.5);
  }

  return vec3<f32>(1.0, 0.0, 0.0);
}

fn findMaterial(pos: vec3<f32>, normal: vec3<f32>) -> u32 {
  var i = 0;
	loop {
	  let density = calculateDensity(pos - normal * f32(i * uniforms.stride));

    if (i > 10) {
      return MATERIAL_AIR;
    }

		if (density.density <= 0) {
		  return density.material;
		}

		continuing {
			i = i + 1;
		}
	}
}

const lightIterations = 10.0;

fn hasLight(p: vec3<f32>) -> f32 {
  let direction = normalize(-p);
  var i = 0.0;


  loop {
    let position = p + direction * pow(2, i);
    let density = getDensity(position);

    if (density < 0) {
      return 0.5;
      // return mix(0.2, 1.0, 1.0 - i / lightIterations);
    }

    if (i > lightIterations) {
      return 1;
    }

    continuing {
      i = i + 1;
    }
  }
}

@fragment
fn main(@location(0) vPos: vec4<f32>,
        @location(1) vNormal: vec3<f32>,
        @location(2) color: vec3<f32>) -> @location(0) vec4<f32> {
  //let fade = getFade(vPos.y);
  let blending = getTriPlanarBlend(vNormal);
  let material = findMaterial(vPos.xyz, normalize(vNormal.xyz));

  let xaxis = samp(vPos.yz * normalRepeat, material);
  let yaxis = samp(vPos.xz * normalRepeat, material);
  let zaxis = samp(vPos.xy * normalRepeat, material);
	var tex = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;

  if (material == MATERIAL_FIRE) {
    return vec4(tex, 1.0);
  }
  //let cell = vec3<u32>(vPos.xyz - uniforms.position / f32(uniforms.stride));
  //let foo = corners[cell.x * 32 * 32 + cell.y * 32 + cell.z];
  return vec4<f32>(tex * color, 1.0);
  //return vec4<f32>(tex * color * max(0.0, hasLight(vPos.xyz + vNormal.xyz * 10.0)), 1.0);
}
`;class VoxelObject{constructor(i,s,a,u,l,h){q(this,"position");q(this,"stride");q(this,"cornersBuffer");q(this,"vertexBuffer");q(this,"indexCount");q(this,"indexBuffer");q(this,"uniformBuffer");q(this,"uniformBindGroup");q(this,"pipeline");this.index=s,this.consistency=h,this.position=i,this.stride=a,this.pipeline=l;const f=new Float32Array([]);this.vertexBuffer=u.createBuffer({size:f.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(f),this.vertexBuffer.unmap(),this.indexCount=12*3,this.indexBuffer=u.createBuffer({size:this.indexCount*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0}),new Uint16Array(this.indexBuffer.getMappedRange()).set([]),this.indexBuffer.unmap(),this.cornersBuffer=u.createBuffer({size:32*32*32*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!1});const d=4*16+4*4+4*4;this.uniformBuffer=u.createBuffer({size:d,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=u.createBindGroup({layout:l.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.cornersBuffer}}]})}setCorners(i,s){const a=i.createBuffer({size:32768*Uint32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.STORAGE,mappedAtCreation:!0}),u=new Uint32Array(a.getMappedRange());for(let h=0;h<s.length;h++)u[h]=s[h];a.unmap();const l=this.cornersBuffer;this.cornersBuffer=a,this.uniformBindGroup=i.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}},{binding:1,resource:{buffer:this.cornersBuffer}}]}),l.destroy()}setVertexBuffer(i,s,a){const u=i.createBuffer({size:s.length*10*Float32Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),l=new Float32Array(u.getMappedRange());for(let f=0;f<s.length;f+=3)l.set(s.slice(f,f+3),f/3*10),l.set([1],f/3*10+3),l.set(a.slice(f,f+3),f/3*10+4),l.set([1],f/3*10+8);u.unmap();const h=this.vertexBuffer;this.vertexBuffer=u,h.destroy()}setIndexBuffer(i,s){const a=i.createBuffer({size:s.length*Uint16Array.BYTES_PER_ELEMENT,usage:GPUBufferUsage.INDEX,mappedAtCreation:!0});new Uint16Array(a.getMappedRange()).set(s),a.unmap();const l=this.indexBuffer;this.indexBuffer=a,l.destroy(),this.indexCount=s.length}getTransformationMatrix(i){const s=create$5();translate(s,s,this.position);const a=create$5();return multiply$2(a,i,s),a}update(i,s,a){const u=this.getTransformationMatrix(s);i.queue.writeBuffer(this.uniformBuffer,0,u.buffer,u.byteOffset,u.byteLength);const l=new Int32Array(1);l[0]=this.stride,i.queue.writeBuffer(this.uniformBuffer,u.byteLength,l.buffer,l.byteOffset,l.byteLength),i.queue.writeBuffer(this.uniformBuffer,4*16+4*4,this.position.buffer,this.position.byteOffset,this.position.byteLength);const h=new Float32Array(1);h[0]=a,i.queue.writeBuffer(this.uniformBuffer,4*16+4*4+4*3,h.buffer,h.byteOffset,h.byteLength)}draw(i){i.setBindGroup(0,this.uniformBindGroup),i.setVertexBuffer(0,this.vertexBuffer),i.setIndexBuffer(this.indexBuffer,"uint16"),i.drawIndexed(this.indexCount)}}const DensityShader=`const freq = 0.001;

const MATERIAL_AIR = 0u;
const MATERIAL_ROCK = 1u;
const MATERIAL_WOOD = 2u;
const MATERIAL_FIRE = 3u;

struct Density {
  density: f32,
  material: u32
}

struct Augmentations {
  count: u32,
  augmentations: array<Augmentation>
}

struct Augmentation {
  position: vec3<f32>,
  size: f32,
  attributes: u32
}

@binding(0) @group(1) var<storage, read> augmentations: Augmentations;

fn subtract(base: Density, sub: f32) -> Density {
  return Density(max(base.density, sub), base.material);
}

fn add(base: Density, add: f32, material: u32) -> Density {
  if (add <= 0) {
    return Density(add, material);
  }
  return base;
}

fn Box(worldPosition: vec3<f32>, origin: vec3<f32>, halfDimensions: vec3<f32>) -> f32
{
	let local_pos: vec3<f32> = worldPosition - origin;
	let pos: vec3<f32> = local_pos;

	let d: vec3<f32> = vec3<f32>(abs(pos.x), abs(pos.y), abs(pos.z)) - halfDimensions;
	let m: f32 = max(d.x, max(d.y, d.z));
	return clamp(min(m, length(max(d, vec3<f32>(0.0, 0.0, 0.0)))), -100.0, 100.0);
}

fn Torus(worldPosition: vec3<f32>, origin: vec3<f32>, t: vec3<f32>) -> f32
{
	let p: vec3<f32> = worldPosition - origin;

  let q: vec2<f32> = vec2<f32>(length(p.xz)-t.x,p.y);
  return length(q)-t.y;
}

fn Sphere(worldPosition: vec3<f32>, origin: vec3<f32>, radius: f32) -> f32
{
	return clamp(length(worldPosition - origin) - radius, -100.0, 100.0);
}

fn FractalNoise21(octaves: i32, frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32
{
	let SCALE: f32 = 1.0 / 128.0;
	var p: vec3<f32> = position * SCALE;
	var nois: f32 = 0.0;

	var amplitude: f32 = 1.0;
	p = p * frequency;

	var i: i32 = 0;
	loop {
		if (i >= octaves) { break; }

		nois = nois + perlinNoise3(p) * amplitude;
		p = p * lacunarity;
		amplitude = amplitude * persistence;

		continuing {
			i = i + 1;
		}
	}

	return nois;
}

fn FractalNoise2(frequency: f32, lacunarity: f32, persistence: f32, position: vec3<f32>) -> f32
{
	let SCALE: f32 = 1.0 / 128.0;
	var p: vec3<f32> = position * SCALE;
	var nois: f32 = 0.0;

	var amplitude: f32 = 1.0;
	p = p * frequency;

	nois = nois + perlinNoise3(p) * amplitude;
	p = p * lacunarity;
	amplitude = amplitude * persistence;

	return nois;
}

fn permute41(x: vec4<f32>) -> vec4<f32> { return ((x * 34. + 1.) * x) % vec4<f32>(289.); }
fn taylorInvSqrt4(r: vec4<f32>) -> vec4<f32> { return 1.79284291400159 - 0.85373472095314 * r; }
fn fade3(t: vec3<f32>) -> vec3<f32> { return t * t * t * (t * (t * 6. - 15.) + 10.); }

fn perlinNoise3(P: vec3<f32>) -> f32 {
  var Pi0 : vec3<f32> = floor(P); // Integer part for indexing
  var Pi1 : vec3<f32> = Pi0 + vec3<f32>(1.); // Integer part + 1
  Pi0 = Pi0 % vec3<f32>(289.);
  Pi1 = Pi1 % vec3<f32>(289.);
  let Pf0 = fract(P); // Fractional part for interpolation
  let Pf1 = Pf0 - vec3<f32>(1.); // Fractional part - 1.
  let ix = vec4<f32>(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
  let iy = vec4<f32>(Pi0.yy, Pi1.yy);
  let iz0 = Pi0.zzzz;
  let iz1 = Pi1.zzzz;

  let ixy = permute41(permute41(ix) + iy);
  let ixy0 = permute41(ixy + iz0);
  let ixy1 = permute41(ixy + iz1);

  var gx0: vec4<f32> = ixy0 / 7.;
  var gy0: vec4<f32> = fract(floor(gx0) / 7.) - 0.5;
  gx0 = fract(gx0);
  var gz0: vec4<f32> = vec4<f32>(0.5) - abs(gx0) - abs(gy0);
  var sz0: vec4<f32> = step(gz0, vec4<f32>(0.));
  gx0 = gx0 + sz0 * (step(vec4<f32>(0.), gx0) - 0.5);
  gy0 = gy0 + sz0 * (step(vec4<f32>(0.), gy0) - 0.5);

  var gx1: vec4<f32> = ixy1 / 7.;
  var gy1: vec4<f32> = fract(floor(gx1) / 7.) - 0.5;
  gx1 = fract(gx1);
  var gz1: vec4<f32> = vec4<f32>(0.5) - abs(gx1) - abs(gy1);
  var sz1: vec4<f32> = step(gz1, vec4<f32>(0.));
  gx1 = gx1 - sz1 * (step(vec4<f32>(0.), gx1) - 0.5);
  gy1 = gy1 - sz1 * (step(vec4<f32>(0.), gy1) - 0.5);

  var g000: vec3<f32> = vec3<f32>(gx0.x, gy0.x, gz0.x);
  var g100: vec3<f32> = vec3<f32>(gx0.y, gy0.y, gz0.y);
  var g010: vec3<f32> = vec3<f32>(gx0.z, gy0.z, gz0.z);
  var g110: vec3<f32> = vec3<f32>(gx0.w, gy0.w, gz0.w);
  var g001: vec3<f32> = vec3<f32>(gx1.x, gy1.x, gz1.x);
  var g101: vec3<f32> = vec3<f32>(gx1.y, gy1.y, gz1.y);
  var g011: vec3<f32> = vec3<f32>(gx1.z, gy1.z, gz1.z);
  var g111: vec3<f32> = vec3<f32>(gx1.w, gy1.w, gz1.w);

  let norm0 = taylorInvSqrt4(
      vec4<f32>(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
  g000 = g000 * norm0.x;
  g010 = g010 * norm0.y;
  g100 = g100 * norm0.z;
  g110 = g110 * norm0.w;
  let norm1 = taylorInvSqrt4(
      vec4<f32>(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
  g001 = g001 * norm1.x;
  g011 = g011 * norm1.y;
  g101 = g101 * norm1.z;
  g111 = g111 * norm1.w;

  let n000 = dot(g000, Pf0);
  let n100 = dot(g100, vec3<f32>(Pf1.x, Pf0.yz));
  let n010 = dot(g010, vec3<f32>(Pf0.x, Pf1.y, Pf0.z));
  let n110 = dot(g110, vec3<f32>(Pf1.xy, Pf0.z));
  let n001 = dot(g001, vec3<f32>(Pf0.xy, Pf1.z));
  let n101 = dot(g101, vec3<f32>(Pf1.x, Pf0.y, Pf1.z));
  let n011 = dot(g011, vec3<f32>(Pf0.x, Pf1.yz));
  let n111 = dot(g111, Pf1);

  var fade_xyz: vec3<f32> = fade3(Pf0);
  let temp = vec4<f32>(f32(fade_xyz.z)); // simplify after chrome bug fix
  let n_z = mix(vec4<f32>(n000, n100, n010, n110), vec4<f32>(n001, n101, n011, n111), temp);
  let n_yz = mix(n_z.xy, n_z.zw, vec2<f32>(f32(fade_xyz.y))); // simplify after chrome bug fix
  let n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
  return 2.2 * n_xyz;
}

fn CalculateNoiseValue2(pos: vec3<f32>, scale: f32) -> f32
{
	return FractalNoise21(4, 0.5343, 2.2324, 0.68324, pos * scale);
}

fn CLerp2(a: f32, b: f32, t: f32) -> f32
{
	return (1.0 - t) * a + t * b;
}

fn calculateDensity(worldPosition: vec3<f32>) -> Density {
	var worldRadius: f32 = 300000.0;
	var world: vec3<f32> = worldPosition - vec3<f32>(worldRadius);
	var worldDist: f32 = clamp(-worldRadius + length(world), -10000.0, 10000.0);

	let flatlandNoiseScale: f32 = 3.0;
	let flatlandLerpAmount: f32 = 0.07;
	let flatlandYPercent: f32 = 1.2;

	let rockyNoiseScale: f32 = 3.0;
	let rockyLerpAmount: f32 = 0.05;
	let rockyYPercent: f32 = 0.7;

	let maxMountainMixLerpAmount: f32 = 0.075;
	let minMountainMixLerpAmount: f32 = 1.0;

	let rockyBlend: f32 = 1.0;

	//let mountainBlend: f32 = clamp(abs(FractalNoise2(0.5343, 2.2324, 0.68324, world)) * 4.0, 0.0, 1.0);
	let mountainBlend: f32 = 1.0;

	let mountain: f32 = CalculateNoiseValue2(world, 30000.0);
	//let mountain: f32 = 0.0;

	var blob: f32 = CalculateNoiseValue2(world, flatlandNoiseScale + ((rockyNoiseScale - flatlandNoiseScale) * rockyBlend));
	blob = CLerp2(blob, (worldDist) * (flatlandYPercent + ((rockyYPercent - flatlandYPercent) * rockyBlend)),
				flatlandLerpAmount + ((rockyLerpAmount - flatlandLerpAmount) * rockyBlend))
				+ CLerp2(mountain, blob, minMountainMixLerpAmount + ((maxMountainMixLerpAmount - minMountainMixLerpAmount) * mountainBlend));

  var result = Density(1.0, MATERIAL_AIR);

	result = add(result, blob, MATERIAL_WOOD);

  result = add(result, Box(worldPosition, vec3<f32>(2000000.0, 150.0, 5000.0), vec3<f32>(5000.0, 1000.0, 5000.0)), MATERIAL_ROCK);
  result = add(result, Sphere(worldPosition, vec3<f32>(3000000.0, 100.0, 100.0), 1000000.0 + 5000.0), MATERIAL_ROCK);

  //result = add(result, Sphere(worldPosition, vec3<f32>(2000000.0 - 1000000.0, 0.0, 0.0), 1000000.0), MATERIAL_ROCK);

  result = add(result, Sphere(worldPosition, vec3<f32>(0.0, 0.0, 0.0), 200000.0), MATERIAL_FIRE);

  //result = subtract(result, -Sphere(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), 1000.0));
  //result = subtract(result, -Box(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), vec3<f32>(6000.0, 500.0, 500.0)));
  //result = subtract(result, -Box(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), vec3<f32>(500.0, 500.0, 5000.0)));

  //result = add(result, Sphere(worldPosition, vec3<f32>(2000000.0, 0.0, 0.0), 1000.0), MATERIAL_FIRE);


  let count = augmentations.count;

  var i: u32 = 0u;
  loop {
    if (i >= count) { break; }

    let augmentation = augmentations.augmentations[i];
    let shape = (augmentation.attributes & 0xFE) >> 1;
    var density: f32 = 0.0;
    switch(shape) {
      case 0: {
        density = Sphere(worldPosition, vec3<f32>(augmentation.position.x, augmentation.position.y, augmentation.position.z), augmentation.size);
      }
      case 1: {
        density = Box(worldPosition, vec3<f32>(augmentation.position.x, augmentation.position.y, augmentation.position.z), vec3<f32>(augmentation.size));
      }
      default: {
        density = 0.0;
      }
    }

    if ((augmentation.attributes & 0x1) == 0x1) {
      let material = (augmentation.attributes & 0x1FF00) >> 8;
      result = add(result, density, material);
    } else {
      result = subtract(result, -density);
    }


    continuing {
      i = i + 1u;
    }
  }

  return result;
}

fn getDensity(worldPosition: vec3<f32>) -> f32 {
	return calculateDensity(worldPosition).density;
}
`;var DensityType=(c=>(c[c.Subtract=0]="Subtract",c[c.Add=1]="Add",c))(DensityType||{}),DensityShape=(c=>(c[c.Sphere=0]="Sphere",c[c.Box=1]="Box",c))(DensityShape||{}),DensityMaterial=(c=>(c[c.Air=0]="Air",c[c.Rock=1]="Rock",c[c.Wood=2]="Wood",c[c.Fire=3]="Fire",c))(DensityMaterial||{});class DensityInstance{constructor(i){q(this,"bindGroup");this.bindGroup=i}apply(i){i.setBindGroup(1,this.bindGroup)}}class Density{constructor(i){q(this,"augmentationBuffer");q(this,"augmentationArray",[]);q(this,"augmentations");this.augmentationBuffer=i,this.augmentations=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT*4)}static async init(i){const s=64*Float32Array.BYTES_PER_ELEMENT*8+8,a=i.createBuffer({size:s,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1});return new Density(a)}async apply(i,s){const a=i.createBindGroup({layout:s.getBindGroupLayout(1),entries:[{binding:0,resource:{buffer:this.augmentationBuffer}}]});return new DensityInstance(a)}modify(i,s){this.augmentationArray.push(s),this.update(i,this.augmentationArray)}update(i,s){this.augmentations=new ArrayBuffer(Uint32Array.BYTES_PER_ELEMENT*4+Uint32Array.BYTES_PER_ELEMENT*s.length*8);const a=new Uint32Array(this.augmentations,0,4);a[0]=s.length;const u=new Float32Array(this.augmentations,Uint32Array.BYTES_PER_ELEMENT*4),l=new Uint32Array(this.augmentations,Uint32Array.BYTES_PER_ELEMENT*4);for(let h=0;h<s.length;h++)u[h*8]=s[h].x,u[h*8+1]=s[h].y,u[h*8+2]=s[h].z,u[h*8+3]=s[h].size,l[h*8+4]=s[h].type|s[h].shape<<1|s[h].material<<8;i.queue.writeBuffer(this.augmentationBuffer,0,this.augmentations,0,this.augmentations.byteLength)}updateRaw(i,s){this.augmentations=s,i.queue.writeBuffer(this.augmentationBuffer,0,this.augmentations,0,this.augmentations.byteLength)}static patch(i){return i.replace("#import density",DensityShader)}}const swapChainFormat="bgra8unorm";let Ray$1=class{constructor(i,s){q(this,"sign",[]);q(this,"invdir");this.source=i,this.dir=s,this.invdir=create$4(),this.setDirection(s)}setDirection(i){this.dir=i,scale(this.invdir,i,-1),this.sign[0]=this.invdir[0]<0?1:0,this.sign[1]=this.invdir[1]<0?1:0,this.sign[2]=this.invdir[2]<0?1:0}};class VoxelCollection{constructor(i,s){q(this,"objects");q(this,"pool");q(this,"pipeline");q(this,"density");this.pipeline=i,this.objects=new Map,this.density=s,this.pool=[]}static async init(i,s){const a=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),u=i.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage"}}]}),l=i.createPipelineLayout({bindGroupLayouts:[a,u]}),h=i.createRenderPipeline({layout:l,vertex:{module:i.createShaderModule({code:VertexShader}),buffers:[{arrayStride:4*10,attributes:[{shaderLocation:0,offset:0,format:"float32x4"},{shaderLocation:1,offset:4*4,format:"float32x4"}]}],entryPoint:"main"},fragment:{module:i.createShaderModule({code:Density.patch(FragmentShader)}),entryPoint:"main",targets:[{format:swapChainFormat}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),f=await s.apply(i,h);return new VoxelCollection(h,f)}intersects(i,s,a){const u=[{x:s.x-a/2,y:s.y-a/2,z:s.z-a/2},{x:s.x+a/2,y:s.y+a/2,z:s.z+a/2}];let l=(u[i.sign[0]].x-i.orig[0])*i.invdir[0],h=(u[1-i.sign[0]].x-i.orig[0])*i.invdir[0];const f=(u[i.sign[1]].y-i.orig[1])*i.invdir[1],d=(u[1-i.sign[1]].y-i.orig[1])*i.invdir[1];if(l>d||f>h)return!1;f>l&&(l=f),d<h&&(h=d);const p=(u[i.sign[2]].z-i.orig[2])*i.invdir[2],g=(u[1-i.sign[2]].z-i.orig[2])*i.invdir[2];return!(l>g||p>h)}getAdjacent(i,s,a){const u=[],l=s/2,h=new Ray$1([a.x/31,a.y/31,a.z/31],[i.x-a.x,i.y-a.y,i.z-a.z]);for(const f of this.objects.values()){const d=f.stride/2;f.index[0]+d>=i.x-l&&i.x+l>=f.index[0]-d&&f.index[1]+d>=i.y-l&&i.y+l>=f.index[1]-d&&f.index[2]+d>=i.z-l&&i.z+l>=f.index[2]-d&&(h.setDirection([a.x/31-f.index[0],a.y/31-f.index[1],a.z/31-f.index[2]]),this.intersects(h,i,s)&&u.push(f))}return u}set(i,s,a,u,l,h,f,d,p,g){let m=this.objects.get(s);m||(m=this.pool.pop(),m?(m.index=fromValues$1(u.x,u.y,u.z),m.position=fromValues$1(a.x,a.y,a.z)):m=new VoxelObject(fromValues$1(a.x,a.y,a.z),fromValues$1(u.x,u.y,u.z),l,i,this.pipeline,g),this.objects.set(s,m)),m.setCorners(i,p),m.stride=l,m.consistency=g,m.setVertexBuffer(i,h,f),m.setIndexBuffer(i,d);const y=l/2;for(const[v,_]of this.objects){if(_===m)continue;const A=_.stride/2;_.index[0]+A>m.index[0]-y&&m.index[0]+y>_.index[0]-A&&_.index[1]+A>m.index[1]-y&&m.index[1]+y>_.index[1]-A&&_.index[2]+A>m.index[2]-y&&m.index[2]+y>_.index[2]-A&&this.free(v)}}free(i){const s=this.objects.get(i);s&&(this.pool.push(s),this.objects.delete(i))}freeAll(){for(const[i,s]of this.objects)this.pool.push(s),this.objects.delete(i)}update(i,s,a){for(const u of this.objects.values())u.update(i,s,a)}draw(i){i.setPipeline(this.pipeline),this.density.apply(i);for(const s of this.objects.values())s.consistency&&s.draw(i)}}const Physics=`struct Actor {
  position: vec3<f32>,
  velocity: vec3<f32>
};

struct Physics {
  actors: array<Actor>
};

@binding(6) @group(0)
var<storage, read_write> physics : Physics;

#import density

@compute @workgroup_size(1)
fn computePhysics(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let actor: u32 = GlobalInvocationID.x;

  if (getDensity(physics.actors[actor].position) < 0.0) {
    physics.actors[actor].position = physics.actors[actor].position + vec3<f32>(10.0, 0.0, 0.0);
  }

  let gravity = vec3<f32>(2000000.0, 0.0, 0.0);
  let gravityDirection = normalize(physics.actors[actor].position - gravity);

  physics.actors[actor].velocity -= gravityDirection * 9.8;

  let direction = normalize(physics.actors[actor].velocity);
  let pos = physics.actors[actor].position + physics.actors[actor].velocity;

  for (var i = 0; i < 10; i++) {
    let pos = physics.actors[actor].position + physics.actors[actor].velocity + gravityDirection * f32(i);
    if (getDensity(pos) >= 0.0) {
      physics.actors[actor].position = pos;
    }
  }
}
`;var aleaExports={},alea$1={get exports(){return aleaExports},set exports(c){aleaExports=c}};(function(c){(function(i,s,a){function u(d){var p=this,g=f();p.next=function(){var m=2091639*p.s0+p.c*23283064365386963e-26;return p.s0=p.s1,p.s1=p.s2,p.s2=m-(p.c=m|0)},p.c=1,p.s0=g(" "),p.s1=g(" "),p.s2=g(" "),p.s0-=g(d),p.s0<0&&(p.s0+=1),p.s1-=g(d),p.s1<0&&(p.s1+=1),p.s2-=g(d),p.s2<0&&(p.s2+=1),g=null}function l(d,p){return p.c=d.c,p.s0=d.s0,p.s1=d.s1,p.s2=d.s2,p}function h(d,p){var g=new u(d),m=p&&p.state,y=g.next;return y.int32=function(){return g.next()*4294967296|0},y.double=function(){return y()+(y()*2097152|0)*11102230246251565e-32},y.quick=y,m&&(typeof m=="object"&&l(m,g),y.state=function(){return l(g,{})}),y}function f(){var d=4022871197,p=function(g){g=String(g);for(var m=0;m<g.length;m++){d+=g.charCodeAt(m);var y=.02519603282416938*d;d=y>>>0,y-=d,y*=d,d=y>>>0,y-=d,d+=y*4294967296}return(d>>>0)*23283064365386963e-26};return p}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.alea=h})(commonjsGlobal,c,!1)})(alea$1);var xor128Exports={},xor128$1={get exports(){return xor128Exports},set exports(c){xor128Exports=c}};(function(c){(function(i,s,a){function u(f){var d=this,p="";d.x=0,d.y=0,d.z=0,d.w=0,d.next=function(){var m=d.x^d.x<<11;return d.x=d.y,d.y=d.z,d.z=d.w,d.w^=d.w>>>19^m^m>>>8},f===(f|0)?d.x=f:p+=f;for(var g=0;g<p.length+64;g++)d.x^=p.charCodeAt(g)|0,d.next()}function l(f,d){return d.x=f.x,d.y=f.y,d.z=f.z,d.w=f.w,d}function h(f,d){var p=new u(f),g=d&&d.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var y=p.next()>>>11,v=(p.next()>>>0)/4294967296,_=(y+v)/(1<<21);while(_===0);return _},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.xor128=h})(commonjsGlobal,c,!1)})(xor128$1);var xorwowExports={},xorwow$1={get exports(){return xorwowExports},set exports(c){xorwowExports=c}};(function(c){(function(i,s,a){function u(f){var d=this,p="";d.next=function(){var m=d.x^d.x>>>2;return d.x=d.y,d.y=d.z,d.z=d.w,d.w=d.v,(d.d=d.d+362437|0)+(d.v=d.v^d.v<<4^(m^m<<1))|0},d.x=0,d.y=0,d.z=0,d.w=0,d.v=0,f===(f|0)?d.x=f:p+=f;for(var g=0;g<p.length+64;g++)d.x^=p.charCodeAt(g)|0,g==p.length&&(d.d=d.x<<10^d.x>>>4),d.next()}function l(f,d){return d.x=f.x,d.y=f.y,d.z=f.z,d.w=f.w,d.v=f.v,d.d=f.d,d}function h(f,d){var p=new u(f),g=d&&d.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var y=p.next()>>>11,v=(p.next()>>>0)/4294967296,_=(y+v)/(1<<21);while(_===0);return _},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.xorwow=h})(commonjsGlobal,c,!1)})(xorwow$1);var xorshift7Exports={},xorshift7$1={get exports(){return xorshift7Exports},set exports(c){xorshift7Exports=c}};(function(c){(function(i,s,a){function u(f){var d=this;d.next=function(){var g=d.x,m=d.i,y,v;return y=g[m],y^=y>>>7,v=y^y<<24,y=g[m+1&7],v^=y^y>>>10,y=g[m+3&7],v^=y^y>>>3,y=g[m+4&7],v^=y^y<<7,y=g[m+7&7],y=y^y<<13,v^=y^y<<9,g[m]=v,d.i=m+1&7,v};function p(g,m){var y,v=[];if(m===(m|0))v[0]=m;else for(m=""+m,y=0;y<m.length;++y)v[y&7]=v[y&7]<<15^m.charCodeAt(y)+v[y+1&7]<<13;for(;v.length<8;)v.push(0);for(y=0;y<8&&v[y]===0;++y);for(y==8?v[7]=-1:v[y],g.x=v,g.i=0,y=256;y>0;--y)g.next()}p(d,f)}function l(f,d){return d.x=f.x.slice(),d.i=f.i,d}function h(f,d){f==null&&(f=+new Date);var p=new u(f),g=d&&d.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var y=p.next()>>>11,v=(p.next()>>>0)/4294967296,_=(y+v)/(1<<21);while(_===0);return _},m.int32=p.next,m.quick=m,g&&(g.x&&l(g,p),m.state=function(){return l(p,{})}),m}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.xorshift7=h})(commonjsGlobal,c,!1)})(xorshift7$1);var xor4096Exports={},xor4096$1={get exports(){return xor4096Exports},set exports(c){xor4096Exports=c}};(function(c){(function(i,s,a){function u(f){var d=this;d.next=function(){var g=d.w,m=d.X,y=d.i,v,_;return d.w=g=g+1640531527|0,_=m[y+34&127],v=m[y=y+1&127],_^=_<<13,v^=v<<17,_^=_>>>15,v^=v>>>12,_=m[y]=_^v,d.i=y,_+(g^g>>>16)|0};function p(g,m){var y,v,_,A,T,x=[],w=128;for(m===(m|0)?(v=m,m=null):(m=m+"\0",v=0,w=Math.max(w,m.length)),_=0,A=-32;A<w;++A)m&&(v^=m.charCodeAt((A+32)%m.length)),A===0&&(T=v),v^=v<<10,v^=v>>>15,v^=v<<4,v^=v>>>13,A>=0&&(T=T+1640531527|0,y=x[A&127]^=v+T,_=y==0?_+1:0);for(_>=128&&(x[(m&&m.length||0)&127]=-1),_=127,A=4*128;A>0;--A)v=x[_+34&127],y=x[_=_+1&127],v^=v<<13,y^=y<<17,v^=v>>>15,y^=y>>>12,x[_]=v^y;g.w=T,g.X=x,g.i=_}p(d,f)}function l(f,d){return d.i=f.i,d.w=f.w,d.X=f.X.slice(),d}function h(f,d){f==null&&(f=+new Date);var p=new u(f),g=d&&d.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var y=p.next()>>>11,v=(p.next()>>>0)/4294967296,_=(y+v)/(1<<21);while(_===0);return _},m.int32=p.next,m.quick=m,g&&(g.X&&l(g,p),m.state=function(){return l(p,{})}),m}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.xor4096=h})(commonjsGlobal,c,!1)})(xor4096$1);var tycheiExports={},tychei$1={get exports(){return tycheiExports},set exports(c){tycheiExports=c}};(function(c){(function(i,s,a){function u(f){var d=this,p="";d.next=function(){var m=d.b,y=d.c,v=d.d,_=d.a;return m=m<<25^m>>>7^y,y=y-v|0,v=v<<24^v>>>8^_,_=_-m|0,d.b=m=m<<20^m>>>12^y,d.c=y=y-v|0,d.d=v<<16^y>>>16^_,d.a=_-m|0},d.a=0,d.b=0,d.c=-1640531527,d.d=1367130551,f===Math.floor(f)?(d.a=f/4294967296|0,d.b=f|0):p+=f;for(var g=0;g<p.length+20;g++)d.b^=p.charCodeAt(g)|0,d.next()}function l(f,d){return d.a=f.a,d.b=f.b,d.c=f.c,d.d=f.d,d}function h(f,d){var p=new u(f),g=d&&d.state,m=function(){return(p.next()>>>0)/4294967296};return m.double=function(){do var y=p.next()>>>11,v=(p.next()>>>0)/4294967296,_=(y+v)/(1<<21);while(_===0);return _},m.int32=p.next,m.quick=m,g&&(typeof g=="object"&&l(g,p),m.state=function(){return l(p,{})}),m}s&&s.exports?s.exports=h:a&&a.amd?a(function(){return h}):this.tychei=h})(commonjsGlobal,c,!1)})(tychei$1);var seedrandomExports={},seedrandom$1={get exports(){return seedrandomExports},set exports(c){seedrandomExports=c}};const __viteBrowserExternal={},__viteBrowserExternal$1=Object.freeze(Object.defineProperty({__proto__:null,default:__viteBrowserExternal},Symbol.toStringTag,{value:"Module"})),require$$0=getAugmentedNamespace(__viteBrowserExternal$1);(function(c){(function(i,s,a){var u=256,l=6,h=52,f="random",d=a.pow(u,l),p=a.pow(2,h),g=p*2,m=u-1,y;function v(C,N,S){var O=[];N=N==!0?{entropy:!0}:N||{};var E=x(T(N.entropy?[C,b(s)]:C??w(),3),O),R=new _(O),I=function(){for(var M=R.g(l),k=d,B=0;M<p;)M=(M+B)*u,k*=u,B=R.g(1);for(;M>=g;)M/=2,k/=2,B>>>=1;return(M+B)/k};return I.int32=function(){return R.g(4)|0},I.quick=function(){return R.g(4)/4294967296},I.double=I,x(b(R.S),s),(N.pass||S||function(M,k,B,P){return P&&(P.S&&A(P,R),M.state=function(){return A(R,{})}),B?(a[f]=M,k):M})(I,E,"global"in N?N.global:this==a,N.state)}function _(C){var N,S=C.length,O=this,E=0,R=O.i=O.j=0,I=O.S=[];for(S||(C=[S++]);E<u;)I[E]=E++;for(E=0;E<u;E++)I[E]=I[R=m&R+C[E%S]+(N=I[E])],I[R]=N;(O.g=function(M){for(var k,B=0,P=O.i,z=O.j,W=O.S;M--;)k=W[P=m&P+1],B=B*u+W[m&(W[P]=W[z=m&z+k])+(W[z]=k)];return O.i=P,O.j=z,B})(u)}function A(C,N){return N.i=C.i,N.j=C.j,N.S=C.S.slice(),N}function T(C,N){var S=[],O=typeof C,E;if(N&&O=="object")for(E in C)try{S.push(T(C[E],N-1))}catch{}return S.length?S:O=="string"?C:C+"\0"}function x(C,N){for(var S=C+"",O,E=0;E<S.length;)N[m&E]=m&(O^=N[m&E]*19)+S.charCodeAt(E++);return b(N)}function w(){try{var C;return y&&(C=y.randomBytes)?C=C(u):(C=new Uint8Array(u),(i.crypto||i.msCrypto).getRandomValues(C)),b(C)}catch{var N=i.navigator,S=N&&N.plugins;return[+new Date,i,S,i.screen,b(s)]}}function b(C){return String.fromCharCode.apply(0,C)}if(x(a.random(),s),c.exports){c.exports=v;try{y=require$$0}catch{}}else a["seed"+f]=v})(typeof self<"u"?self:commonjsGlobal,[],Math)})(seedrandom$1);var alea=aleaExports,xor128=xor128Exports,xorwow=xorwowExports,xorshift7=xorshift7Exports,xor4096=xor4096Exports,tychei=tycheiExports,sr=seedrandomExports;sr.alea=alea;sr.xor128=xor128;sr.xorwow=xorwow;sr.xorshift7=xorshift7;sr.xor4096=xor4096;sr.tychei=tychei;var seedrandom=sr;class Voxel{constructor(i,s,a,u,l,h,f){q(this,"running",!1);q(this,"velocity");q(this,"position");q(this,"computePipeline");q(this,"actorsBuffer");q(this,"computeBindGroup");q(this,"actorsReadBuffer");q(this,"density");this.velocity=i,this.position=s,this.computePipeline=a,this.actorsBuffer=u,this.computeBindGroup=l,this.actorsReadBuffer=h,this.density=f}static async init(i,s,a){const u=Density.patch(Physics),l=fromValues$1(0,0,0),h=performance.now();console.log("Loading physics engine");const f=await i.createComputePipelineAsync({layout:"auto",compute:{module:i.createShaderModule({code:u}),entryPoint:"computePhysics"}}),d=new Int32Array(512),p=new seedrandom("James");for(let T=0;T<256;T++)d[T]=256*p();for(let T=256;T<512;T++)d[T]=d[T-256];const g=i.createBuffer({size:d.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Int32Array(g.getMappedRange()).set(d),g.unmap();const m=i.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});new Float32Array(m.getMappedRange()).set(s),m.unmap();const v=i.createBindGroup({layout:f.getBindGroupLayout(0),entries:[{binding:6,resource:{buffer:m}}]}),_=i.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),A=await a.apply(i,f);return console.log("Physics engine loaded",performance.now()-h),new Voxel(l,s,f,m,v,_,A)}generate(i,s){return new Promise(a=>{i.queue.writeBuffer(this.actorsBuffer,Float32Array.BYTES_PER_ELEMENT*4,this.velocity.buffer);const u=i.createCommandEncoder(),l=u.beginComputePass();l.setPipeline(this.computePipeline),l.setBindGroup(0,this.computeBindGroup),this.density.apply(l),l.dispatchWorkgroups(1),l.end();const h=i.createCommandEncoder();h.copyBufferToBuffer(this.actorsBuffer,0,this.actorsReadBuffer,0,Float32Array.BYTES_PER_ELEMENT*8),s({items:[u.finish(),h.finish()],callback:()=>{this.actorsReadBuffer.mapAsync(GPUMapMode.READ).then(()=>{const f=this.actorsReadBuffer.getMappedRange(),d=new Float32Array(f);this.position.set([d[0],d[1],d[2]]),this.actorsReadBuffer.unmap(),a()})}})})}async update(i,s){if(this.running)return Promise.resolve();this.running=!0,await this.generate(i,s),this.running=!1}}class Mouse{constructor(){q(this,"position");this.position={x:0,y:0}}init(){const i=s=>{this.position.x+=s.movementX,this.position.y+=s.movementY};document.addEventListener("mousemove",i)}update(){this.position.x=0,this.position.y=0}}const Ray=`#import density

struct Uniforms {
  position: vec3<f32>,
  direction: vec3<f32>
}
@binding(0) @group(0) var<uniform> uniforms : Uniforms;

struct Intersection {
  position: vec3<f32>,
  found: u32,
  normal: vec3<f32>,
  distance: f32
}
@binding(1) @group(0) var <storage, read_write> intersection: Intersection;


@compute @workgroup_size(1)
fn main() {

  let direction = normalize(uniforms.direction);
  var i = 1.0;

  intersection.found = 0;

  loop {
    let position = uniforms.position + direction * i;
    let density = getDensity(position);

    if (i > 10000) {
      return;
    }

    if (density < 0) {
      intersection.found = 1;
      intersection.position = position;
      intersection.normal = vec3<f32>(3.0, 5.0, 1.0);
      intersection.distance = length(uniforms.position - position);
      return;
    }

    continuing {
      i = i + 1;
    }
  }
}
`;class Intersection{constructor(i,s,a){q(this,"position");q(this,"normal");q(this,"distance");this.position=i,this.normal=s,this.distance=a}}class Raycast{constructor(i,s,a,u,l,h){q(this,"computePipeline");q(this,"uniformBuffer");q(this,"intersectionsBuffer");q(this,"computeBindGroup");q(this,"intersectionsReadBuffer");q(this,"density");this.computePipeline=i,this.uniformBuffer=s,this.intersectionsBuffer=a,this.computeBindGroup=u,this.intersectionsReadBuffer=l,this.density=h}static async init(i,s){const a=await i.createComputePipelineAsync({layout:"auto",compute:{module:i.createShaderModule({code:Density.patch(Ray)}),entryPoint:"main"}}),u=await s.apply(i,a),l=Float32Array.BYTES_PER_ELEMENT*8,h=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),f=i.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,mappedAtCreation:!0});f.unmap();const d=i.createBindGroup({layout:a.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:h}},{binding:1,resource:{buffer:f}}]}),p=i.createBuffer({size:Float32Array.BYTES_PER_ELEMENT*8,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});return new Raycast(a,h,f,d,p,u)}cast(i,s,a,u){return new Promise(l=>{i.queue.writeBuffer(this.uniformBuffer,0,a.buffer),i.queue.writeBuffer(this.uniformBuffer,Float32Array.BYTES_PER_ELEMENT*4,u.buffer);const h=i.createCommandEncoder(),f=h.beginComputePass();f.setPipeline(this.computePipeline),f.setBindGroup(0,this.computeBindGroup),this.density.apply(f),f.dispatchWorkgroups(1),f.end();const d=i.createCommandEncoder();d.copyBufferToBuffer(this.intersectionsBuffer,0,this.intersectionsReadBuffer,0,Float32Array.BYTES_PER_ELEMENT*8),s({items:[h.finish(),d.finish()],callback:()=>{this.intersectionsReadBuffer.mapAsync(GPUMapMode.READ).then(()=>{const p=this.intersectionsReadBuffer.getMappedRange();new Uint32Array(p,Float32Array.BYTES_PER_ELEMENT*3,1)[0]===0&&l(null);const m=new Float32Array(p),y=new Intersection(fromValues$1(m[0],m[1],m[2]),fromValues$1(m[4],m[5],m[6]),m[7]);this.intersectionsReadBuffer.unmap(),l(y)})}})})}}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var extendStatics=function(c,i){return extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(s,a){s.__proto__=a}||function(s,a){for(var u in a)a.hasOwnProperty(u)&&(s[u]=a[u])},extendStatics(c,i)};function __extends(c,i){extendStatics(c,i);function s(){this.constructor=c}c.prototype=i===null?Object.create(i):(s.prototype=i.prototype,new s)}function __values(c){var i=typeof Symbol=="function"&&c[Symbol.iterator],s=0;return i?i.call(c):{next:function(){return c&&s>=c.length&&(c=void 0),{value:c&&c[s++],done:!c}}}}function __read(c,i){var s=typeof Symbol=="function"&&c[Symbol.iterator];if(!s)return c;var a=s.call(c),u,l=[],h;try{for(;(i===void 0||i-- >0)&&!(u=a.next()).done;)l.push(u.value)}catch(f){h={error:f}}finally{try{u&&!u.done&&(s=a.return)&&s.call(a)}finally{if(h)throw h.error}}return l}function __spread(){for(var c=[],i=0;i<arguments.length;i++)c=c.concat(__read(arguments[i]));return c}var Event=function(){function c(i,s){this.target=s,this.type=i}return c}(),ErrorEvent$1=function(c){__extends(i,c);function i(s,a){var u=c.call(this,"error",a)||this;return u.message=s.message,u.error=s,u}return i}(Event),CloseEvent=function(c){__extends(i,c);function i(s,a,u){s===void 0&&(s=1e3),a===void 0&&(a="");var l=c.call(this,"close",u)||this;return l.wasClean=!0,l.code=s,l.reason=a,l}return i}(Event);/*!
 * Reconnecting WebSocket
 * by Pedro Ladaria <pedro.ladaria@gmail.com>
 * https://github.com/pladaria/reconnecting-websocket
 * License MIT
 */var getGlobalWebSocket=function(){if(typeof WebSocket<"u")return WebSocket},isWebSocket=function(c){return typeof c<"u"&&!!c&&c.CLOSING===2},DEFAULT={maxReconnectionDelay:1e4,minReconnectionDelay:1e3+Math.random()*4e3,minUptime:5e3,reconnectionDelayGrowFactor:1.3,connectionTimeout:4e3,maxRetries:1/0,maxEnqueuedMessages:1/0,startClosed:!1,debug:!1},ReconnectingWebSocket=function(){function c(i,s,a){var u=this;a===void 0&&(a={}),this._listeners={error:[],message:[],open:[],close:[]},this._retryCount=-1,this._shouldReconnect=!0,this._connectLock=!1,this._binaryType="blob",this._closeCalled=!1,this._messageQueue=[],this.onclose=null,this.onerror=null,this.onmessage=null,this.onopen=null,this._handleOpen=function(l){u._debug("open event");var h=u._options.minUptime,f=h===void 0?DEFAULT.minUptime:h;clearTimeout(u._connectTimeout),u._uptimeTimeout=setTimeout(function(){return u._acceptOpen()},f),u._ws.binaryType=u._binaryType,u._messageQueue.forEach(function(d){return u._ws.send(d)}),u._messageQueue=[],u.onopen&&u.onopen(l),u._listeners.open.forEach(function(d){return u._callEventListener(l,d)})},this._handleMessage=function(l){u._debug("message event"),u.onmessage&&u.onmessage(l),u._listeners.message.forEach(function(h){return u._callEventListener(l,h)})},this._handleError=function(l){u._debug("error event",l.message),u._disconnect(void 0,l.message==="TIMEOUT"?"timeout":void 0),u.onerror&&u.onerror(l),u._debug("exec error listeners"),u._listeners.error.forEach(function(h){return u._callEventListener(l,h)}),u._connect()},this._handleClose=function(l){u._debug("close event"),u._clearTimeouts(),u._shouldReconnect&&u._connect(),u.onclose&&u.onclose(l),u._listeners.close.forEach(function(h){return u._callEventListener(l,h)})},this._url=i,this._protocols=s,this._options=a,this._options.startClosed&&(this._shouldReconnect=!1),this._connect()}return Object.defineProperty(c,"CONNECTING",{get:function(){return 0},enumerable:!0,configurable:!0}),Object.defineProperty(c,"OPEN",{get:function(){return 1},enumerable:!0,configurable:!0}),Object.defineProperty(c,"CLOSING",{get:function(){return 2},enumerable:!0,configurable:!0}),Object.defineProperty(c,"CLOSED",{get:function(){return 3},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CONNECTING",{get:function(){return c.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"OPEN",{get:function(){return c.OPEN},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CLOSING",{get:function(){return c.CLOSING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"CLOSED",{get:function(){return c.CLOSED},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"binaryType",{get:function(){return this._ws?this._ws.binaryType:this._binaryType},set:function(i){this._binaryType=i,this._ws&&(this._ws.binaryType=i)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"retryCount",{get:function(){return Math.max(this._retryCount,0)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"bufferedAmount",{get:function(){var i=this._messageQueue.reduce(function(s,a){return typeof a=="string"?s+=a.length:a instanceof Blob?s+=a.size:s+=a.byteLength,s},0);return i+(this._ws?this._ws.bufferedAmount:0)},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"extensions",{get:function(){return this._ws?this._ws.extensions:""},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"protocol",{get:function(){return this._ws?this._ws.protocol:""},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"readyState",{get:function(){return this._ws?this._ws.readyState:this._options.startClosed?c.CLOSED:c.CONNECTING},enumerable:!0,configurable:!0}),Object.defineProperty(c.prototype,"url",{get:function(){return this._ws?this._ws.url:""},enumerable:!0,configurable:!0}),c.prototype.close=function(i,s){if(i===void 0&&(i=1e3),this._closeCalled=!0,this._shouldReconnect=!1,this._clearTimeouts(),!this._ws){this._debug("close enqueued: no ws instance");return}if(this._ws.readyState===this.CLOSED){this._debug("close: already closed");return}this._ws.close(i,s)},c.prototype.reconnect=function(i,s){this._shouldReconnect=!0,this._closeCalled=!1,this._retryCount=-1,!this._ws||this._ws.readyState===this.CLOSED?this._connect():(this._disconnect(i,s),this._connect())},c.prototype.send=function(i){if(this._ws&&this._ws.readyState===this.OPEN)this._debug("send",i),this._ws.send(i);else{var s=this._options.maxEnqueuedMessages,a=s===void 0?DEFAULT.maxEnqueuedMessages:s;this._messageQueue.length<a&&(this._debug("enqueue",i),this._messageQueue.push(i))}},c.prototype.addEventListener=function(i,s){this._listeners[i]&&this._listeners[i].push(s)},c.prototype.dispatchEvent=function(i){var s,a,u=this._listeners[i.type];if(u)try{for(var l=__values(u),h=l.next();!h.done;h=l.next()){var f=h.value;this._callEventListener(i,f)}}catch(d){s={error:d}}finally{try{h&&!h.done&&(a=l.return)&&a.call(l)}finally{if(s)throw s.error}}return!0},c.prototype.removeEventListener=function(i,s){this._listeners[i]&&(this._listeners[i]=this._listeners[i].filter(function(a){return a!==s}))},c.prototype._debug=function(){for(var i=[],s=0;s<arguments.length;s++)i[s]=arguments[s];this._options.debug&&console.log.apply(console,__spread(["RWS>"],i))},c.prototype._getNextDelay=function(){var i=this._options,s=i.reconnectionDelayGrowFactor,a=s===void 0?DEFAULT.reconnectionDelayGrowFactor:s,u=i.minReconnectionDelay,l=u===void 0?DEFAULT.minReconnectionDelay:u,h=i.maxReconnectionDelay,f=h===void 0?DEFAULT.maxReconnectionDelay:h,d=0;return this._retryCount>0&&(d=l*Math.pow(a,this._retryCount-1),d>f&&(d=f)),this._debug("next delay",d),d},c.prototype._wait=function(){var i=this;return new Promise(function(s){setTimeout(s,i._getNextDelay())})},c.prototype._getNextUrl=function(i){if(typeof i=="string")return Promise.resolve(i);if(typeof i=="function"){var s=i();if(typeof s=="string")return Promise.resolve(s);if(s.then)return s}throw Error("Invalid URL")},c.prototype._connect=function(){var i=this;if(!(this._connectLock||!this._shouldReconnect)){this._connectLock=!0;var s=this._options,a=s.maxRetries,u=a===void 0?DEFAULT.maxRetries:a,l=s.connectionTimeout,h=l===void 0?DEFAULT.connectionTimeout:l,f=s.WebSocket,d=f===void 0?getGlobalWebSocket():f;if(this._retryCount>=u){this._debug("max retries reached",this._retryCount,">=",u);return}if(this._retryCount++,this._debug("connect",this._retryCount),this._removeListeners(),!isWebSocket(d))throw Error("No valid WebSocket class provided");this._wait().then(function(){return i._getNextUrl(i._url)}).then(function(p){i._closeCalled||(i._debug("connect",{url:p,protocols:i._protocols}),i._ws=i._protocols?new d(p,i._protocols):new d(p),i._ws.binaryType=i._binaryType,i._connectLock=!1,i._addListeners(),i._connectTimeout=setTimeout(function(){return i._handleTimeout()},h))})}},c.prototype._handleTimeout=function(){this._debug("timeout event"),this._handleError(new ErrorEvent$1(Error("TIMEOUT"),this))},c.prototype._disconnect=function(i,s){if(i===void 0&&(i=1e3),this._clearTimeouts(),!!this._ws){this._removeListeners();try{this._ws.close(i,s),this._handleClose(new CloseEvent(i,s,this))}catch{}}},c.prototype._acceptOpen=function(){this._debug("accept open"),this._retryCount=0},c.prototype._callEventListener=function(i,s){"handleEvent"in s?s.handleEvent(i):s(i)},c.prototype._removeListeners=function(){this._ws&&(this._debug("removeListeners"),this._ws.removeEventListener("open",this._handleOpen),this._ws.removeEventListener("close",this._handleClose),this._ws.removeEventListener("message",this._handleMessage),this._ws.removeEventListener("error",this._handleError))},c.prototype._addListeners=function(){this._ws&&(this._debug("addListeners"),this._ws.addEventListener("open",this._handleOpen),this._ws.addEventListener("close",this._handleClose),this._ws.addEventListener("message",this._handleMessage),this._ws.addEventListener("error",this._handleError))},c.prototype._clearTimeouts=function(){clearTimeout(this._connectTimeout),clearTimeout(this._uptimeTimeout)},c}();function e(c){this.message=c}e.prototype=new Error,e.prototype.name="InvalidCharacterError";var r=typeof window<"u"&&window.atob&&window.atob.bind(window)||function(c){var i=String(c).replace(/=+$/,"");if(i.length%4==1)throw new e("'atob' failed: The string to be decoded is not correctly encoded.");for(var s,a,u=0,l=0,h="";a=i.charAt(l++);~a&&(s=u%4?64*s+a:a,u++%4)?h+=String.fromCharCode(255&s>>(-2*u&6)):0)a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a);return h};function t(c){var i=c.replace(/-/g,"+").replace(/_/g,"/");switch(i.length%4){case 0:break;case 2:i+="==";break;case 3:i+="=";break;default:throw"Illegal base64url string!"}try{return function(s){return decodeURIComponent(r(s).replace(/(.)/g,function(a,u){var l=u.charCodeAt(0).toString(16).toUpperCase();return l.length<2&&(l="0"+l),"%"+l}))}(i)}catch{return r(i)}}function n(c){this.message=c}function o(c,i){if(typeof c!="string")throw new n("Invalid token specified");var s=(i=i||{}).header===!0?0:1;try{return JSON.parse(t(c.split(".")[s]))}catch(a){throw new n("Invalid token specified: "+a.message)}}n.prototype=new Error,n.prototype.name="InvalidTokenError";var protobufjsExports={},protobufjs={get exports(){return protobufjsExports},set exports(c){protobufjsExports=c}},srcExports={},src={get exports(){return srcExports},set exports(c){srcExports=c}},indexLightExports={},indexLight={get exports(){return indexLightExports},set exports(c){indexLightExports=c}},indexMinimal={},minimal={},aspromise=asPromise$1;function asPromise$1(c,i){for(var s=new Array(arguments.length-1),a=0,u=2,l=!0;u<arguments.length;)s[a++]=arguments[u++];return new Promise(function(f,d){s[a]=function(g){if(l)if(l=!1,g)d(g);else{for(var m=new Array(arguments.length-1),y=0;y<m.length;)m[y++]=arguments[y];f.apply(null,m)}};try{c.apply(i||null,s)}catch(p){l&&(l=!1,d(p))}})}var base64$1={};(function(c){var i=c;i.length=function(f){var d=f.length;if(!d)return 0;for(var p=0;--d%4>1&&f.charAt(d)==="=";)++p;return Math.ceil(f.length*3)/4-p};for(var s=new Array(64),a=new Array(123),u=0;u<64;)a[s[u]=u<26?u+65:u<52?u+71:u<62?u-4:u-59|43]=u++;i.encode=function(f,d,p){for(var g=null,m=[],y=0,v=0,_;d<p;){var A=f[d++];switch(v){case 0:m[y++]=s[A>>2],_=(A&3)<<4,v=1;break;case 1:m[y++]=s[_|A>>4],_=(A&15)<<2,v=2;break;case 2:m[y++]=s[_|A>>6],m[y++]=s[A&63],v=0;break}y>8191&&((g||(g=[])).push(String.fromCharCode.apply(String,m)),y=0)}return v&&(m[y++]=s[_],m[y++]=61,v===1&&(m[y++]=61)),g?(y&&g.push(String.fromCharCode.apply(String,m.slice(0,y))),g.join("")):String.fromCharCode.apply(String,m.slice(0,y))};var l="invalid encoding";i.decode=function(f,d,p){for(var g=p,m=0,y,v=0;v<f.length;){var _=f.charCodeAt(v++);if(_===61&&m>1)break;if((_=a[_])===void 0)throw Error(l);switch(m){case 0:y=_,m=1;break;case 1:d[p++]=y<<2|(_&48)>>4,y=_,m=2;break;case 2:d[p++]=(y&15)<<4|(_&60)>>2,y=_,m=3;break;case 3:d[p++]=(y&3)<<6|_,m=0;break}}if(m===1)throw Error(l);return p-g},i.test=function(f){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(f)}})(base64$1);var eventemitter=EventEmitter;function EventEmitter(){this._listeners={}}EventEmitter.prototype.on=function(i,s,a){return(this._listeners[i]||(this._listeners[i]=[])).push({fn:s,ctx:a||this}),this};EventEmitter.prototype.off=function(i,s){if(i===void 0)this._listeners={};else if(s===void 0)this._listeners[i]=[];else for(var a=this._listeners[i],u=0;u<a.length;)a[u].fn===s?a.splice(u,1):++u;return this};EventEmitter.prototype.emit=function(i){var s=this._listeners[i];if(s){for(var a=[],u=1;u<arguments.length;)a.push(arguments[u++]);for(u=0;u<s.length;)s[u].fn.apply(s[u++].ctx,a)}return this};var float=factory(factory);function factory(c){return typeof Float32Array<"u"?function(){var i=new Float32Array([-0]),s=new Uint8Array(i.buffer),a=s[3]===128;function u(d,p,g){i[0]=d,p[g]=s[0],p[g+1]=s[1],p[g+2]=s[2],p[g+3]=s[3]}function l(d,p,g){i[0]=d,p[g]=s[3],p[g+1]=s[2],p[g+2]=s[1],p[g+3]=s[0]}c.writeFloatLE=a?u:l,c.writeFloatBE=a?l:u;function h(d,p){return s[0]=d[p],s[1]=d[p+1],s[2]=d[p+2],s[3]=d[p+3],i[0]}function f(d,p){return s[3]=d[p],s[2]=d[p+1],s[1]=d[p+2],s[0]=d[p+3],i[0]}c.readFloatLE=a?h:f,c.readFloatBE=a?f:h}():function(){function i(a,u,l,h){var f=u<0?1:0;if(f&&(u=-u),u===0)a(1/u>0?0:2147483648,l,h);else if(isNaN(u))a(2143289344,l,h);else if(u>34028234663852886e22)a((f<<31|2139095040)>>>0,l,h);else if(u<11754943508222875e-54)a((f<<31|Math.round(u/1401298464324817e-60))>>>0,l,h);else{var d=Math.floor(Math.log(u)/Math.LN2),p=Math.round(u*Math.pow(2,-d)*8388608)&8388607;a((f<<31|d+127<<23|p)>>>0,l,h)}}c.writeFloatLE=i.bind(null,writeUintLE),c.writeFloatBE=i.bind(null,writeUintBE);function s(a,u,l){var h=a(u,l),f=(h>>31)*2+1,d=h>>>23&255,p=h&8388607;return d===255?p?NaN:f*(1/0):d===0?f*1401298464324817e-60*p:f*Math.pow(2,d-150)*(p+8388608)}c.readFloatLE=s.bind(null,readUintLE),c.readFloatBE=s.bind(null,readUintBE)}(),typeof Float64Array<"u"?function(){var i=new Float64Array([-0]),s=new Uint8Array(i.buffer),a=s[7]===128;function u(d,p,g){i[0]=d,p[g]=s[0],p[g+1]=s[1],p[g+2]=s[2],p[g+3]=s[3],p[g+4]=s[4],p[g+5]=s[5],p[g+6]=s[6],p[g+7]=s[7]}function l(d,p,g){i[0]=d,p[g]=s[7],p[g+1]=s[6],p[g+2]=s[5],p[g+3]=s[4],p[g+4]=s[3],p[g+5]=s[2],p[g+6]=s[1],p[g+7]=s[0]}c.writeDoubleLE=a?u:l,c.writeDoubleBE=a?l:u;function h(d,p){return s[0]=d[p],s[1]=d[p+1],s[2]=d[p+2],s[3]=d[p+3],s[4]=d[p+4],s[5]=d[p+5],s[6]=d[p+6],s[7]=d[p+7],i[0]}function f(d,p){return s[7]=d[p],s[6]=d[p+1],s[5]=d[p+2],s[4]=d[p+3],s[3]=d[p+4],s[2]=d[p+5],s[1]=d[p+6],s[0]=d[p+7],i[0]}c.readDoubleLE=a?h:f,c.readDoubleBE=a?f:h}():function(){function i(a,u,l,h,f,d){var p=h<0?1:0;if(p&&(h=-h),h===0)a(0,f,d+u),a(1/h>0?0:2147483648,f,d+l);else if(isNaN(h))a(0,f,d+u),a(2146959360,f,d+l);else if(h>17976931348623157e292)a(0,f,d+u),a((p<<31|2146435072)>>>0,f,d+l);else{var g;if(h<22250738585072014e-324)g=h/5e-324,a(g>>>0,f,d+u),a((p<<31|g/4294967296)>>>0,f,d+l);else{var m=Math.floor(Math.log(h)/Math.LN2);m===1024&&(m=1023),g=h*Math.pow(2,-m),a(g*4503599627370496>>>0,f,d+u),a((p<<31|m+1023<<20|g*1048576&1048575)>>>0,f,d+l)}}}c.writeDoubleLE=i.bind(null,writeUintLE,0,4),c.writeDoubleBE=i.bind(null,writeUintBE,4,0);function s(a,u,l,h,f){var d=a(h,f+u),p=a(h,f+l),g=(p>>31)*2+1,m=p>>>20&2047,y=4294967296*(p&1048575)+d;return m===2047?y?NaN:g*(1/0):m===0?g*5e-324*y:g*Math.pow(2,m-1075)*(y+4503599627370496)}c.readDoubleLE=s.bind(null,readUintLE,0,4),c.readDoubleBE=s.bind(null,readUintBE,4,0)}(),c}function writeUintLE(c,i,s){i[s]=c&255,i[s+1]=c>>>8&255,i[s+2]=c>>>16&255,i[s+3]=c>>>24}function writeUintBE(c,i,s){i[s]=c>>>24,i[s+1]=c>>>16&255,i[s+2]=c>>>8&255,i[s+3]=c&255}function readUintLE(c,i){return(c[i]|c[i+1]<<8|c[i+2]<<16|c[i+3]<<24)>>>0}function readUintBE(c,i){return(c[i]<<24|c[i+1]<<16|c[i+2]<<8|c[i+3])>>>0}var inquire_1=inquire$1;function inquire$1(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(c){}return null}var utf8$2={};(function(c){var i=c;i.length=function(a){for(var u=0,l=0,h=0;h<a.length;++h)l=a.charCodeAt(h),l<128?u+=1:l<2048?u+=2:(l&64512)===55296&&(a.charCodeAt(h+1)&64512)===56320?(++h,u+=4):u+=3;return u},i.read=function(a,u,l){var h=l-u;if(h<1)return"";for(var f=null,d=[],p=0,g;u<l;)g=a[u++],g<128?d[p++]=g:g>191&&g<224?d[p++]=(g&31)<<6|a[u++]&63:g>239&&g<365?(g=((g&7)<<18|(a[u++]&63)<<12|(a[u++]&63)<<6|a[u++]&63)-65536,d[p++]=55296+(g>>10),d[p++]=56320+(g&1023)):d[p++]=(g&15)<<12|(a[u++]&63)<<6|a[u++]&63,p>8191&&((f||(f=[])).push(String.fromCharCode.apply(String,d)),p=0);return f?(p&&f.push(String.fromCharCode.apply(String,d.slice(0,p))),f.join("")):String.fromCharCode.apply(String,d.slice(0,p))},i.write=function(a,u,l){for(var h=l,f,d,p=0;p<a.length;++p)f=a.charCodeAt(p),f<128?u[l++]=f:f<2048?(u[l++]=f>>6|192,u[l++]=f&63|128):(f&64512)===55296&&((d=a.charCodeAt(p+1))&64512)===56320?(f=65536+((f&1023)<<10)+(d&1023),++p,u[l++]=f>>18|240,u[l++]=f>>12&63|128,u[l++]=f>>6&63|128,u[l++]=f&63|128):(u[l++]=f>>12|224,u[l++]=f>>6&63|128,u[l++]=f&63|128);return l-h}})(utf8$2);var pool_1=pool;function pool(c,i,s){var a=s||8192,u=a>>>1,l=null,h=a;return function(d){if(d<1||d>u)return c(d);h+d>a&&(l=c(a),h=0);var p=i.call(l,h,h+=d);return h&7&&(h=(h|7)+1),p}}var longbits,hasRequiredLongbits;function requireLongbits(){if(hasRequiredLongbits)return longbits;hasRequiredLongbits=1,longbits=i;var c=requireMinimal();function i(l,h){this.lo=l>>>0,this.hi=h>>>0}var s=i.zero=new i(0,0);s.toNumber=function(){return 0},s.zzEncode=s.zzDecode=function(){return this},s.length=function(){return 1};var a=i.zeroHash="\0\0\0\0\0\0\0\0";i.fromNumber=function(h){if(h===0)return s;var f=h<0;f&&(h=-h);var d=h>>>0,p=(h-d)/4294967296>>>0;return f&&(p=~p>>>0,d=~d>>>0,++d>4294967295&&(d=0,++p>4294967295&&(p=0))),new i(d,p)},i.from=function(h){if(typeof h=="number")return i.fromNumber(h);if(c.isString(h))if(c.Long)h=c.Long.fromString(h);else return i.fromNumber(parseInt(h,10));return h.low||h.high?new i(h.low>>>0,h.high>>>0):s},i.prototype.toNumber=function(h){if(!h&&this.hi>>>31){var f=~this.lo+1>>>0,d=~this.hi>>>0;return f||(d=d+1>>>0),-(f+d*4294967296)}return this.lo+this.hi*4294967296},i.prototype.toLong=function(h){return c.Long?new c.Long(this.lo|0,this.hi|0,Boolean(h)):{low:this.lo|0,high:this.hi|0,unsigned:Boolean(h)}};var u=String.prototype.charCodeAt;return i.fromHash=function(h){return h===a?s:new i((u.call(h,0)|u.call(h,1)<<8|u.call(h,2)<<16|u.call(h,3)<<24)>>>0,(u.call(h,4)|u.call(h,5)<<8|u.call(h,6)<<16|u.call(h,7)<<24)>>>0)},i.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},i.prototype.zzEncode=function(){var h=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^h)>>>0,this.lo=(this.lo<<1^h)>>>0,this},i.prototype.zzDecode=function(){var h=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^h)>>>0,this.hi=(this.hi>>>1^h)>>>0,this},i.prototype.length=function(){var h=this.lo,f=(this.lo>>>28|this.hi<<4)>>>0,d=this.hi>>>24;return d===0?f===0?h<16384?h<128?1:2:h<2097152?3:4:f<16384?f<128?5:6:f<2097152?7:8:d<128?9:10},longbits}var hasRequiredMinimal;function requireMinimal(){return hasRequiredMinimal||(hasRequiredMinimal=1,function(c){var i=c;i.asPromise=aspromise,i.base64=base64$1,i.EventEmitter=eventemitter,i.float=float,i.inquire=inquire_1,i.utf8=utf8$2,i.pool=pool_1,i.LongBits=requireLongbits(),i.isNode=Boolean(typeof commonjsGlobal<"u"&&commonjsGlobal&&commonjsGlobal.process&&commonjsGlobal.process.versions&&commonjsGlobal.process.versions.node),i.global=i.isNode&&commonjsGlobal||typeof window<"u"&&window||typeof self<"u"&&self||commonjsGlobal,i.emptyArray=Object.freeze?Object.freeze([]):[],i.emptyObject=Object.freeze?Object.freeze({}):{},i.isInteger=Number.isInteger||function(l){return typeof l=="number"&&isFinite(l)&&Math.floor(l)===l},i.isString=function(l){return typeof l=="string"||l instanceof String},i.isObject=function(l){return l&&typeof l=="object"},i.isset=i.isSet=function(l,h){var f=l[h];return f!=null&&l.hasOwnProperty(h)?typeof f!="object"||(Array.isArray(f)?f.length:Object.keys(f).length)>0:!1},i.Buffer=function(){try{var u=i.inquire("buffer").Buffer;return u.prototype.utf8Write?u:null}catch{return null}}(),i._Buffer_from=null,i._Buffer_allocUnsafe=null,i.newBuffer=function(l){return typeof l=="number"?i.Buffer?i._Buffer_allocUnsafe(l):new i.Array(l):i.Buffer?i._Buffer_from(l):typeof Uint8Array>"u"?l:new Uint8Array(l)},i.Array=typeof Uint8Array<"u"?Uint8Array:Array,i.Long=i.global.dcodeIO&&i.global.dcodeIO.Long||i.global.Long||i.inquire("long"),i.key2Re=/^true|false|0|1$/,i.key32Re=/^-?(?:0|[1-9][0-9]*)$/,i.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,i.longToHash=function(l){return l?i.LongBits.from(l).toHash():i.LongBits.zeroHash},i.longFromHash=function(l,h){var f=i.LongBits.fromHash(l);return i.Long?i.Long.fromBits(f.lo,f.hi,h):f.toNumber(Boolean(h))};function s(u,l,h){for(var f=Object.keys(l),d=0;d<f.length;++d)(u[f[d]]===void 0||!h)&&(u[f[d]]=l[f[d]]);return u}i.merge=s,i.lcFirst=function(l){return l.charAt(0).toLowerCase()+l.substring(1)};function a(u){function l(h,f){if(!(this instanceof l))return new l(h,f);Object.defineProperty(this,"message",{get:function(){return h}}),Error.captureStackTrace?Error.captureStackTrace(this,l):Object.defineProperty(this,"stack",{value:new Error().stack||""}),f&&s(this,f)}return l.prototype=Object.create(Error.prototype,{constructor:{value:l,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return u},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),l}i.newError=a,i.ProtocolError=a("ProtocolError"),i.oneOfGetter=function(l){for(var h={},f=0;f<l.length;++f)h[l[f]]=1;return function(){for(var d=Object.keys(this),p=d.length-1;p>-1;--p)if(h[d[p]]===1&&this[d[p]]!==void 0&&this[d[p]]!==null)return d[p]}},i.oneOfSetter=function(l){return function(h){for(var f=0;f<l.length;++f)l[f]!==h&&delete this[l[f]]}},i.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},i._configure=function(){var u=i.Buffer;if(!u){i._Buffer_from=i._Buffer_allocUnsafe=null;return}i._Buffer_from=u.from!==Uint8Array.from&&u.from||function(h,f){return new u(h,f)},i._Buffer_allocUnsafe=u.allocUnsafe||function(h){return new u(h)}}}(minimal)),minimal}var writer=Writer$1,util$7=requireMinimal(),BufferWriter$1,LongBits$1=util$7.LongBits,base64=util$7.base64,utf8$1=util$7.utf8;function Op(c,i,s){this.fn=c,this.len=i,this.next=void 0,this.val=s}function noop(){}function State(c){this.head=c.head,this.tail=c.tail,this.len=c.len,this.next=c.states}function Writer$1(){this.len=0,this.head=new Op(noop,0,0),this.tail=this.head,this.states=null}var create$1=function c(){return util$7.Buffer?function(){return(Writer$1.create=function(){return new BufferWriter$1})()}:function(){return new Writer$1}};Writer$1.create=create$1();Writer$1.alloc=function c(i){return new util$7.Array(i)};util$7.Array!==Array&&(Writer$1.alloc=util$7.pool(Writer$1.alloc,util$7.Array.prototype.subarray));Writer$1.prototype._push=function c(i,s,a){return this.tail=this.tail.next=new Op(i,s,a),this.len+=s,this};function writeByte(c,i,s){i[s]=c&255}function writeVarint32(c,i,s){for(;c>127;)i[s++]=c&127|128,c>>>=7;i[s]=c}function VarintOp(c,i){this.len=c,this.next=void 0,this.val=i}VarintOp.prototype=Object.create(Op.prototype);VarintOp.prototype.fn=writeVarint32;Writer$1.prototype.uint32=function c(i){return this.len+=(this.tail=this.tail.next=new VarintOp((i=i>>>0)<128?1:i<16384?2:i<2097152?3:i<268435456?4:5,i)).len,this};Writer$1.prototype.int32=function c(i){return i<0?this._push(writeVarint64,10,LongBits$1.fromNumber(i)):this.uint32(i)};Writer$1.prototype.sint32=function c(i){return this.uint32((i<<1^i>>31)>>>0)};function writeVarint64(c,i,s){for(;c.hi;)i[s++]=c.lo&127|128,c.lo=(c.lo>>>7|c.hi<<25)>>>0,c.hi>>>=7;for(;c.lo>127;)i[s++]=c.lo&127|128,c.lo=c.lo>>>7;i[s++]=c.lo}Writer$1.prototype.uint64=function c(i){var s=LongBits$1.from(i);return this._push(writeVarint64,s.length(),s)};Writer$1.prototype.int64=Writer$1.prototype.uint64;Writer$1.prototype.sint64=function c(i){var s=LongBits$1.from(i).zzEncode();return this._push(writeVarint64,s.length(),s)};Writer$1.prototype.bool=function c(i){return this._push(writeByte,1,i?1:0)};function writeFixed32(c,i,s){i[s]=c&255,i[s+1]=c>>>8&255,i[s+2]=c>>>16&255,i[s+3]=c>>>24}Writer$1.prototype.fixed32=function c(i){return this._push(writeFixed32,4,i>>>0)};Writer$1.prototype.sfixed32=Writer$1.prototype.fixed32;Writer$1.prototype.fixed64=function c(i){var s=LongBits$1.from(i);return this._push(writeFixed32,4,s.lo)._push(writeFixed32,4,s.hi)};Writer$1.prototype.sfixed64=Writer$1.prototype.fixed64;Writer$1.prototype.float=function c(i){return this._push(util$7.float.writeFloatLE,4,i)};Writer$1.prototype.double=function c(i){return this._push(util$7.float.writeDoubleLE,8,i)};var writeBytes=util$7.Array.prototype.set?function c(i,s,a){s.set(i,a)}:function c(i,s,a){for(var u=0;u<i.length;++u)s[a+u]=i[u]};Writer$1.prototype.bytes=function c(i){var s=i.length>>>0;if(!s)return this._push(writeByte,1,0);if(util$7.isString(i)){var a=Writer$1.alloc(s=base64.length(i));base64.decode(i,a,0),i=a}return this.uint32(s)._push(writeBytes,s,i)};Writer$1.prototype.string=function c(i){var s=utf8$1.length(i);return s?this.uint32(s)._push(utf8$1.write,s,i):this._push(writeByte,1,0)};Writer$1.prototype.fork=function c(){return this.states=new State(this),this.head=this.tail=new Op(noop,0,0),this.len=0,this};Writer$1.prototype.reset=function c(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new Op(noop,0,0),this.len=0),this};Writer$1.prototype.ldelim=function c(){var i=this.head,s=this.tail,a=this.len;return this.reset().uint32(a),a&&(this.tail.next=i.next,this.tail=s,this.len+=a),this};Writer$1.prototype.finish=function c(){for(var i=this.head.next,s=this.constructor.alloc(this.len),a=0;i;)i.fn(i.val,s,a),a+=i.len,i=i.next;return s};Writer$1._configure=function(c){BufferWriter$1=c,Writer$1.create=create$1(),BufferWriter$1._configure()};var writer_buffer=BufferWriter,Writer=writer;(BufferWriter.prototype=Object.create(Writer.prototype)).constructor=BufferWriter;var util$6=requireMinimal();function BufferWriter(){Writer.call(this)}BufferWriter._configure=function(){BufferWriter.alloc=util$6._Buffer_allocUnsafe,BufferWriter.writeBytesBuffer=util$6.Buffer&&util$6.Buffer.prototype instanceof Uint8Array&&util$6.Buffer.prototype.set.name==="set"?function(i,s,a){s.set(i,a)}:function(i,s,a){if(i.copy)i.copy(s,a,0,i.length);else for(var u=0;u<i.length;)s[a++]=i[u++]}};BufferWriter.prototype.bytes=function c(i){util$6.isString(i)&&(i=util$6._Buffer_from(i,"base64"));var s=i.length>>>0;return this.uint32(s),s&&this._push(BufferWriter.writeBytesBuffer,s,i),this};function writeStringBuffer(c,i,s){c.length<40?util$6.utf8.write(c,i,s):i.utf8Write?i.utf8Write(c,s):i.write(c,s)}BufferWriter.prototype.string=function c(i){var s=util$6.Buffer.byteLength(i);return this.uint32(s),s&&this._push(writeStringBuffer,s,i),this};BufferWriter._configure();var reader=Reader$1,util$5=requireMinimal(),BufferReader$1,LongBits=util$5.LongBits,utf8=util$5.utf8;function indexOutOfRange(c,i){return RangeError("index out of range: "+c.pos+" + "+(i||1)+" > "+c.len)}function Reader$1(c){this.buf=c,this.pos=0,this.len=c.length}var create_array=typeof Uint8Array<"u"?function c(i){if(i instanceof Uint8Array||Array.isArray(i))return new Reader$1(i);throw Error("illegal buffer")}:function c(i){if(Array.isArray(i))return new Reader$1(i);throw Error("illegal buffer")},create=function c(){return util$5.Buffer?function(s){return(Reader$1.create=function(u){return util$5.Buffer.isBuffer(u)?new BufferReader$1(u):create_array(u)})(s)}:create_array};Reader$1.create=create();Reader$1.prototype._slice=util$5.Array.prototype.subarray||util$5.Array.prototype.slice;Reader$1.prototype.uint32=function c(){var i=4294967295;return function(){if(i=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(i=(i|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(i=(i|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(i=(i|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(i=(i|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return i;if((this.pos+=5)>this.len)throw this.pos=this.len,indexOutOfRange(this,10);return i}}();Reader$1.prototype.int32=function c(){return this.uint32()|0};Reader$1.prototype.sint32=function c(){var i=this.uint32();return i>>>1^-(i&1)|0};function readLongVarint(){var c=new LongBits(0,0),i=0;if(this.len-this.pos>4){for(;i<4;++i)if(c.lo=(c.lo|(this.buf[this.pos]&127)<<i*7)>>>0,this.buf[this.pos++]<128)return c;if(c.lo=(c.lo|(this.buf[this.pos]&127)<<28)>>>0,c.hi=(c.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return c;i=0}else{for(;i<3;++i){if(this.pos>=this.len)throw indexOutOfRange(this);if(c.lo=(c.lo|(this.buf[this.pos]&127)<<i*7)>>>0,this.buf[this.pos++]<128)return c}return c.lo=(c.lo|(this.buf[this.pos++]&127)<<i*7)>>>0,c}if(this.len-this.pos>4){for(;i<5;++i)if(c.hi=(c.hi|(this.buf[this.pos]&127)<<i*7+3)>>>0,this.buf[this.pos++]<128)return c}else for(;i<5;++i){if(this.pos>=this.len)throw indexOutOfRange(this);if(c.hi=(c.hi|(this.buf[this.pos]&127)<<i*7+3)>>>0,this.buf[this.pos++]<128)return c}throw Error("invalid varint encoding")}Reader$1.prototype.bool=function c(){return this.uint32()!==0};function readFixed32_end(c,i){return(c[i-4]|c[i-3]<<8|c[i-2]<<16|c[i-1]<<24)>>>0}Reader$1.prototype.fixed32=function c(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)};Reader$1.prototype.sfixed32=function c(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);return readFixed32_end(this.buf,this.pos+=4)|0};function readFixed64(){if(this.pos+8>this.len)throw indexOutOfRange(this,8);return new LongBits(readFixed32_end(this.buf,this.pos+=4),readFixed32_end(this.buf,this.pos+=4))}Reader$1.prototype.float=function c(){if(this.pos+4>this.len)throw indexOutOfRange(this,4);var i=util$5.float.readFloatLE(this.buf,this.pos);return this.pos+=4,i};Reader$1.prototype.double=function c(){if(this.pos+8>this.len)throw indexOutOfRange(this,4);var i=util$5.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,i};Reader$1.prototype.bytes=function c(){var i=this.uint32(),s=this.pos,a=this.pos+i;if(a>this.len)throw indexOutOfRange(this,i);return this.pos+=i,Array.isArray(this.buf)?this.buf.slice(s,a):s===a?new this.buf.constructor(0):this._slice.call(this.buf,s,a)};Reader$1.prototype.string=function c(){var i=this.bytes();return utf8.read(i,0,i.length)};Reader$1.prototype.skip=function c(i){if(typeof i=="number"){if(this.pos+i>this.len)throw indexOutOfRange(this,i);this.pos+=i}else do if(this.pos>=this.len)throw indexOutOfRange(this);while(this.buf[this.pos++]&128);return this};Reader$1.prototype.skipType=function(c){switch(c){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(c=this.uint32()&7)!==4;)this.skipType(c);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+c+" at offset "+this.pos)}return this};Reader$1._configure=function(c){BufferReader$1=c,Reader$1.create=create(),BufferReader$1._configure();var i=util$5.Long?"toLong":"toNumber";util$5.merge(Reader$1.prototype,{int64:function(){return readLongVarint.call(this)[i](!1)},uint64:function(){return readLongVarint.call(this)[i](!0)},sint64:function(){return readLongVarint.call(this).zzDecode()[i](!1)},fixed64:function(){return readFixed64.call(this)[i](!0)},sfixed64:function(){return readFixed64.call(this)[i](!1)}})};var reader_buffer=BufferReader,Reader=reader;(BufferReader.prototype=Object.create(Reader.prototype)).constructor=BufferReader;var util$4=requireMinimal();function BufferReader(c){Reader.call(this,c)}BufferReader._configure=function(){util$4.Buffer&&(BufferReader.prototype._slice=util$4.Buffer.prototype.slice)};BufferReader.prototype.string=function c(){var i=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+i,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+i,this.len))};BufferReader._configure();var rpc={},service$1=Service$1,util$3=requireMinimal();(Service$1.prototype=Object.create(util$3.EventEmitter.prototype)).constructor=Service$1;function Service$1(c,i,s){if(typeof c!="function")throw TypeError("rpcImpl must be a function");util$3.EventEmitter.call(this),this.rpcImpl=c,this.requestDelimited=Boolean(i),this.responseDelimited=Boolean(s)}Service$1.prototype.rpcCall=function c(i,s,a,u,l){if(!u)throw TypeError("request must be specified");var h=this;if(!l)return util$3.asPromise(c,h,i,s,a,u);if(!h.rpcImpl){setTimeout(function(){l(Error("already ended"))},0);return}try{return h.rpcImpl(i,s[h.requestDelimited?"encodeDelimited":"encode"](u).finish(),function(d,p){if(d)return h.emit("error",d,i),l(d);if(p===null){h.end(!0);return}if(!(p instanceof a))try{p=a[h.responseDelimited?"decodeDelimited":"decode"](p)}catch(g){return h.emit("error",g,i),l(g)}return h.emit("data",p,i),l(null,p)})}catch(f){h.emit("error",f,i),setTimeout(function(){l(f)},0);return}};Service$1.prototype.end=function c(i){return this.rpcImpl&&(i||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this};(function(c){var i=c;i.Service=service$1})(rpc);var roots={};(function(c){var i=c;i.build="minimal",i.Writer=writer,i.BufferWriter=writer_buffer,i.Reader=reader,i.BufferReader=reader_buffer,i.util=requireMinimal(),i.rpc=rpc,i.roots=roots,i.configure=s;function s(){i.util._configure(),i.Writer._configure(i.BufferWriter),i.Reader._configure(i.BufferReader)}s()})(indexMinimal);var utilExports={},util$2={get exports(){return utilExports},set exports(c){utilExports=c}},codegen_1=codegen;function codegen(c,i){typeof c=="string"&&(i=c,c=void 0);var s=[];function a(l){if(typeof l!="string"){var h=u();if(codegen.verbose&&console.log("codegen: "+h),h="return "+h,l){for(var f=Object.keys(l),d=new Array(f.length+1),p=new Array(f.length),g=0;g<f.length;)d[g]=f[g],p[g]=l[f[g++]];return d[g]=h,Function.apply(null,d).apply(null,p)}return Function(h)()}for(var m=new Array(arguments.length-1),y=0;y<m.length;)m[y]=arguments[++y];if(y=0,l=l.replace(/%([%dfijs])/g,function(_,A){var T=m[y++];switch(A){case"d":case"f":return String(Number(T));case"i":return String(Math.floor(T));case"j":return JSON.stringify(T);case"s":return String(T)}return"%"}),y!==m.length)throw Error("parameter count mismatch");return s.push(l),a}function u(l){return"function "+(l||i||"")+"("+(c&&c.join(",")||"")+`){
  `+s.join(`
  `)+`
}`}return a.toString=u,a}codegen.verbose=!1;var fetch_1=fetch$1,asPromise=aspromise,inquire=inquire_1,fs=inquire("fs");function fetch$1(c,i,s){return typeof i=="function"?(s=i,i={}):i||(i={}),s?!i.xhr&&fs&&fs.readFile?fs.readFile(c,function(u,l){return u&&typeof XMLHttpRequest<"u"?fetch$1.xhr(c,i,s):u?s(u):s(null,i.binary?l:l.toString("utf8"))}):fetch$1.xhr(c,i,s):asPromise(fetch$1,this,c,i)}fetch$1.xhr=function c(i,s,a){var u=new XMLHttpRequest;u.onreadystatechange=function(){if(u.readyState===4){if(u.status!==0&&u.status!==200)return a(Error("status "+u.status));if(s.binary){var h=u.response;if(!h){h=[];for(var f=0;f<u.responseText.length;++f)h.push(u.responseText.charCodeAt(f)&255)}return a(null,typeof Uint8Array<"u"?new Uint8Array(h):h)}return a(null,u.responseText)}},s.binary&&("overrideMimeType"in u&&u.overrideMimeType("text/plain; charset=x-user-defined"),u.responseType="arraybuffer"),u.open("GET",i),u.send()};var path={};(function(c){var i=c,s=i.isAbsolute=function(l){return/^(?:\/|\w+:)/.test(l)},a=i.normalize=function(l){l=l.replace(/\\/g,"/").replace(/\/{2,}/g,"/");var h=l.split("/"),f=s(l),d="";f&&(d=h.shift()+"/");for(var p=0;p<h.length;)h[p]===".."?p>0&&h[p-1]!==".."?h.splice(--p,2):f?h.splice(p,1):++p:h[p]==="."?h.splice(p,1):++p;return d+h.join("/")};i.resolve=function(l,h,f){return f||(h=a(h)),s(h)?h:(f||(l=a(l)),(l=l.replace(/(?:\/|^)[^/]+$/,"")).length?a(l+"/"+h):h)}})(path);var types$1={},hasRequiredTypes;function requireTypes(){return hasRequiredTypes||(hasRequiredTypes=1,function(c){var i=c,s=requireUtil(),a=["double","float","int32","uint32","sint32","fixed32","sfixed32","int64","uint64","sint64","fixed64","sfixed64","bool","string","bytes"];function u(l,h){var f=0,d={};for(h|=0;f<l.length;)d[a[f+h]]=l[f++];return d}i.basic=u([1,5,0,0,0,5,5,0,0,0,1,1,0,2,2]),i.defaults=u([0,0,0,0,0,0,0,0,0,0,0,0,!1,"",s.emptyArray,null]),i.long=u([0,0,0,1,1],7),i.mapKey=u([0,0,0,5,5,0,0,0,1,1,0,2],2),i.packed=u([1,5,0,0,0,5,5,0,0,0,1,1,0])}(types$1)),types$1}var field,hasRequiredField;function requireField(){if(hasRequiredField)return field;hasRequiredField=1,field=h;var c=requireObject();((h.prototype=Object.create(c.prototype)).constructor=h).className="Field";var i=require_enum(),s=requireTypes(),a=requireUtil(),u,l=/^required|optional|repeated$/;h.fromJSON=function(d,p){return new h(d,p.id,p.type,p.rule,p.extend,p.options,p.comment)};function h(f,d,p,g,m,y,v){if(a.isObject(g)?(v=m,y=g,g=m=void 0):a.isObject(m)&&(v=y,y=m,m=void 0),c.call(this,f,y),!a.isInteger(d)||d<0)throw TypeError("id must be a non-negative integer");if(!a.isString(p))throw TypeError("type must be a string");if(g!==void 0&&!l.test(g=g.toString().toLowerCase()))throw TypeError("rule must be a string rule");if(m!==void 0&&!a.isString(m))throw TypeError("extend must be a string");g==="proto3_optional"&&(g="optional"),this.rule=g&&g!=="optional"?g:void 0,this.type=p,this.id=d,this.extend=m||void 0,this.required=g==="required",this.optional=!this.required,this.repeated=g==="repeated",this.map=!1,this.message=null,this.partOf=null,this.typeDefault=null,this.defaultValue=null,this.long=a.Long?s.long[p]!==void 0:!1,this.bytes=p==="bytes",this.resolvedType=null,this.extensionField=null,this.declaringField=null,this._packed=null,this.comment=v}return Object.defineProperty(h.prototype,"packed",{get:function(){return this._packed===null&&(this._packed=this.getOption("packed")!==!1),this._packed}}),h.prototype.setOption=function(d,p,g){return d==="packed"&&(this._packed=null),c.prototype.setOption.call(this,d,p,g)},h.prototype.toJSON=function(d){var p=d?Boolean(d.keepComments):!1;return a.toObject(["rule",this.rule!=="optional"&&this.rule||void 0,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",p?this.comment:void 0])},h.prototype.resolve=function(){if(this.resolved)return this;if((this.typeDefault=s.defaults[this.type])===void 0?(this.resolvedType=(this.declaringField?this.declaringField.parent:this.parent).lookupTypeOrEnum(this.type),this.resolvedType instanceof u?this.typeDefault=null:this.typeDefault=this.resolvedType.values[Object.keys(this.resolvedType.values)[0]]):this.options&&this.options.proto3_optional&&(this.typeDefault=null),this.options&&this.options.default!=null&&(this.typeDefault=this.options.default,this.resolvedType instanceof i&&typeof this.typeDefault=="string"&&(this.typeDefault=this.resolvedType.values[this.typeDefault])),this.options&&((this.options.packed===!0||this.options.packed!==void 0&&this.resolvedType&&!(this.resolvedType instanceof i))&&delete this.options.packed,Object.keys(this.options).length||(this.options=void 0)),this.long)this.typeDefault=a.Long.fromNumber(this.typeDefault,this.type.charAt(0)==="u"),Object.freeze&&Object.freeze(this.typeDefault);else if(this.bytes&&typeof this.typeDefault=="string"){var d;a.base64.test(this.typeDefault)?a.base64.decode(this.typeDefault,d=a.newBuffer(a.base64.length(this.typeDefault)),0):a.utf8.write(this.typeDefault,d=a.newBuffer(a.utf8.length(this.typeDefault)),0),this.typeDefault=d}return this.map?this.defaultValue=a.emptyObject:this.repeated?this.defaultValue=a.emptyArray:this.defaultValue=this.typeDefault,this.parent instanceof u&&(this.parent.ctor.prototype[this.name]=this.defaultValue),c.prototype.resolve.call(this)},h.d=function(d,p,g,m){return typeof p=="function"?p=a.decorateType(p).name:p&&typeof p=="object"&&(p=a.decorateEnum(p).name),function(v,_){a.decorateType(v.constructor).add(new h(_,d,p,g,{default:m}))}},h._configure=function(d){u=d},field}var oneof,hasRequiredOneof;function requireOneof(){if(hasRequiredOneof)return oneof;hasRequiredOneof=1,oneof=a;var c=requireObject();((a.prototype=Object.create(c.prototype)).constructor=a).className="OneOf";var i=requireField(),s=requireUtil();function a(l,h,f,d){if(Array.isArray(h)||(f=h,h=void 0),c.call(this,l,f),!(h===void 0||Array.isArray(h)))throw TypeError("fieldNames must be an Array");this.oneof=h||[],this.fieldsArray=[],this.comment=d}a.fromJSON=function(h,f){return new a(h,f.oneof,f.options,f.comment)},a.prototype.toJSON=function(h){var f=h?Boolean(h.keepComments):!1;return s.toObject(["options",this.options,"oneof",this.oneof,"comment",f?this.comment:void 0])};function u(l){if(l.parent)for(var h=0;h<l.fieldsArray.length;++h)l.fieldsArray[h].parent||l.parent.add(l.fieldsArray[h])}return a.prototype.add=function(h){if(!(h instanceof i))throw TypeError("field must be a Field");return h.parent&&h.parent!==this.parent&&h.parent.remove(h),this.oneof.push(h.name),this.fieldsArray.push(h),h.partOf=this,u(this),this},a.prototype.remove=function(h){if(!(h instanceof i))throw TypeError("field must be a Field");var f=this.fieldsArray.indexOf(h);if(f<0)throw Error(h+" is not a member of "+this);return this.fieldsArray.splice(f,1),f=this.oneof.indexOf(h.name),f>-1&&this.oneof.splice(f,1),h.partOf=null,this},a.prototype.onAdd=function(h){c.prototype.onAdd.call(this,h);for(var f=this,d=0;d<this.oneof.length;++d){var p=h.get(this.oneof[d]);p&&!p.partOf&&(p.partOf=f,f.fieldsArray.push(p))}u(this)},a.prototype.onRemove=function(h){for(var f=0,d;f<this.fieldsArray.length;++f)(d=this.fieldsArray[f]).parent&&d.parent.remove(d);c.prototype.onRemove.call(this,h)},a.d=function(){for(var h=new Array(arguments.length),f=0;f<arguments.length;)h[f]=arguments[f++];return function(p,g){s.decorateType(p.constructor).add(new a(g,h)),Object.defineProperty(p,g,{get:s.oneOfGetter(h),set:s.oneOfSetter(h)})}},oneof}var namespace,hasRequiredNamespace;function requireNamespace(){if(hasRequiredNamespace)return namespace;hasRequiredNamespace=1,namespace=d;var c=requireObject();((d.prototype=Object.create(c.prototype)).constructor=d).className="Namespace";var i=requireField(),s=requireUtil(),a=requireOneof(),u,l,h;d.fromJSON=function(m,y){return new d(m,y.options).addJSON(y.nested)};function f(g,m){if(g&&g.length){for(var y={},v=0;v<g.length;++v)y[g[v].name]=g[v].toJSON(m);return y}}d.arrayToJSON=f,d.isReservedId=function(m,y){if(m){for(var v=0;v<m.length;++v)if(typeof m[v]!="string"&&m[v][0]<=y&&m[v][1]>y)return!0}return!1},d.isReservedName=function(m,y){if(m){for(var v=0;v<m.length;++v)if(m[v]===y)return!0}return!1};function d(g,m){c.call(this,g,m),this.nested=void 0,this._nestedArray=null}function p(g){return g._nestedArray=null,g}return Object.defineProperty(d.prototype,"nestedArray",{get:function(){return this._nestedArray||(this._nestedArray=s.toArray(this.nested))}}),d.prototype.toJSON=function(m){return s.toObject(["options",this.options,"nested",f(this.nestedArray,m)])},d.prototype.addJSON=function(m){var y=this;if(m)for(var v=Object.keys(m),_=0,A;_<v.length;++_)A=m[v[_]],y.add((A.fields!==void 0?u.fromJSON:A.values!==void 0?h.fromJSON:A.methods!==void 0?l.fromJSON:A.id!==void 0?i.fromJSON:d.fromJSON)(v[_],A));return this},d.prototype.get=function(m){return this.nested&&this.nested[m]||null},d.prototype.getEnum=function(m){if(this.nested&&this.nested[m]instanceof h)return this.nested[m].values;throw Error("no such enum: "+m)},d.prototype.add=function(m){if(!(m instanceof i&&m.extend!==void 0||m instanceof u||m instanceof a||m instanceof h||m instanceof l||m instanceof d))throw TypeError("object must be a valid nested object");if(!this.nested)this.nested={};else{var y=this.get(m.name);if(y)if(y instanceof d&&m instanceof d&&!(y instanceof u||y instanceof l)){for(var v=y.nestedArray,_=0;_<v.length;++_)m.add(v[_]);this.remove(y),this.nested||(this.nested={}),m.setOptions(y.options,!0)}else throw Error("duplicate name '"+m.name+"' in "+this)}return this.nested[m.name]=m,m.onAdd(this),p(this)},d.prototype.remove=function(m){if(!(m instanceof c))throw TypeError("object must be a ReflectionObject");if(m.parent!==this)throw Error(m+" is not a member of "+this);return delete this.nested[m.name],Object.keys(this.nested).length||(this.nested=void 0),m.onRemove(this),p(this)},d.prototype.define=function(m,y){if(s.isString(m))m=m.split(".");else if(!Array.isArray(m))throw TypeError("illegal path");if(m&&m.length&&m[0]==="")throw Error("path must be relative");for(var v=this;m.length>0;){var _=m.shift();if(v.nested&&v.nested[_]){if(v=v.nested[_],!(v instanceof d))throw Error("path conflicts with non-namespace objects")}else v.add(v=new d(_))}return y&&v.addJSON(y),v},d.prototype.resolveAll=function(){for(var m=this.nestedArray,y=0;y<m.length;)m[y]instanceof d?m[y++].resolveAll():m[y++].resolve();return this.resolve()},d.prototype.lookup=function(m,y,v){if(typeof y=="boolean"?(v=y,y=void 0):y&&!Array.isArray(y)&&(y=[y]),s.isString(m)&&m.length){if(m===".")return this.root;m=m.split(".")}else if(!m.length)return this;if(m[0]==="")return this.root.lookup(m.slice(1),y);var _=this.get(m[0]);if(_){if(m.length===1){if(!y||y.indexOf(_.constructor)>-1)return _}else if(_ instanceof d&&(_=_.lookup(m.slice(1),y,!0)))return _}else for(var A=0;A<this.nestedArray.length;++A)if(this._nestedArray[A]instanceof d&&(_=this._nestedArray[A].lookup(m,y,!0)))return _;return this.parent===null||v?null:this.parent.lookup(m,y)},d.prototype.lookupType=function(m){var y=this.lookup(m,[u]);if(!y)throw Error("no such type: "+m);return y},d.prototype.lookupEnum=function(m){var y=this.lookup(m,[h]);if(!y)throw Error("no such Enum '"+m+"' in "+this);return y},d.prototype.lookupTypeOrEnum=function(m){var y=this.lookup(m,[u,h]);if(!y)throw Error("no such Type or Enum '"+m+"' in "+this);return y},d.prototype.lookupService=function(m){var y=this.lookup(m,[l]);if(!y)throw Error("no such Service '"+m+"' in "+this);return y},d._configure=function(g,m,y){u=g,l=m,h=y},namespace}var mapfield,hasRequiredMapfield;function requireMapfield(){if(hasRequiredMapfield)return mapfield;hasRequiredMapfield=1,mapfield=a;var c=requireField();((a.prototype=Object.create(c.prototype)).constructor=a).className="MapField";var i=requireTypes(),s=requireUtil();function a(u,l,h,f,d,p){if(c.call(this,u,l,f,void 0,void 0,d,p),!s.isString(h))throw TypeError("keyType must be a string");this.keyType=h,this.resolvedKeyType=null,this.map=!0}return a.fromJSON=function(l,h){return new a(l,h.id,h.keyType,h.type,h.options,h.comment)},a.prototype.toJSON=function(l){var h=l?Boolean(l.keepComments):!1;return s.toObject(["keyType",this.keyType,"type",this.type,"id",this.id,"extend",this.extend,"options",this.options,"comment",h?this.comment:void 0])},a.prototype.resolve=function(){if(this.resolved)return this;if(i.mapKey[this.keyType]===void 0)throw Error("invalid key type: "+this.keyType);return c.prototype.resolve.call(this)},a.d=function(l,h,f){return typeof f=="function"?f=s.decorateType(f).name:f&&typeof f=="object"&&(f=s.decorateEnum(f).name),function(p,g){s.decorateType(p.constructor).add(new a(g,l,h,f))}},mapfield}var method,hasRequiredMethod;function requireMethod(){if(hasRequiredMethod)return method;hasRequiredMethod=1,method=s;var c=requireObject();((s.prototype=Object.create(c.prototype)).constructor=s).className="Method";var i=requireUtil();function s(a,u,l,h,f,d,p,g,m){if(i.isObject(f)?(p=f,f=d=void 0):i.isObject(d)&&(p=d,d=void 0),!(u===void 0||i.isString(u)))throw TypeError("type must be a string");if(!i.isString(l))throw TypeError("requestType must be a string");if(!i.isString(h))throw TypeError("responseType must be a string");c.call(this,a,p),this.type=u||"rpc",this.requestType=l,this.requestStream=f?!0:void 0,this.responseType=h,this.responseStream=d?!0:void 0,this.resolvedRequestType=null,this.resolvedResponseType=null,this.comment=g,this.parsedOptions=m}return s.fromJSON=function(u,l){return new s(u,l.type,l.requestType,l.responseType,l.requestStream,l.responseStream,l.options,l.comment,l.parsedOptions)},s.prototype.toJSON=function(u){var l=u?Boolean(u.keepComments):!1;return i.toObject(["type",this.type!=="rpc"&&this.type||void 0,"requestType",this.requestType,"requestStream",this.requestStream,"responseType",this.responseType,"responseStream",this.responseStream,"options",this.options,"comment",l?this.comment:void 0,"parsedOptions",this.parsedOptions])},s.prototype.resolve=function(){return this.resolved?this:(this.resolvedRequestType=this.parent.lookupType(this.requestType),this.resolvedResponseType=this.parent.lookupType(this.responseType),c.prototype.resolve.call(this))},method}var service,hasRequiredService;function requireService(){if(hasRequiredService)return service;hasRequiredService=1,service=u;var c=requireNamespace();((u.prototype=Object.create(c.prototype)).constructor=u).className="Service";var i=requireMethod(),s=requireUtil(),a=rpc;function u(h,f){c.call(this,h,f),this.methods={},this._methodsArray=null}u.fromJSON=function(f,d){var p=new u(f,d.options);if(d.methods)for(var g=Object.keys(d.methods),m=0;m<g.length;++m)p.add(i.fromJSON(g[m],d.methods[g[m]]));return d.nested&&p.addJSON(d.nested),p.comment=d.comment,p},u.prototype.toJSON=function(f){var d=c.prototype.toJSON.call(this,f),p=f?Boolean(f.keepComments):!1;return s.toObject(["options",d&&d.options||void 0,"methods",c.arrayToJSON(this.methodsArray,f)||{},"nested",d&&d.nested||void 0,"comment",p?this.comment:void 0])},Object.defineProperty(u.prototype,"methodsArray",{get:function(){return this._methodsArray||(this._methodsArray=s.toArray(this.methods))}});function l(h){return h._methodsArray=null,h}return u.prototype.get=function(f){return this.methods[f]||c.prototype.get.call(this,f)},u.prototype.resolveAll=function(){for(var f=this.methodsArray,d=0;d<f.length;++d)f[d].resolve();return c.prototype.resolve.call(this)},u.prototype.add=function(f){if(this.get(f.name))throw Error("duplicate name '"+f.name+"' in "+this);return f instanceof i?(this.methods[f.name]=f,f.parent=this,l(this)):c.prototype.add.call(this,f)},u.prototype.remove=function(f){if(f instanceof i){if(this.methods[f.name]!==f)throw Error(f+" is not a member of "+this);return delete this.methods[f.name],f.parent=null,l(this)}return c.prototype.remove.call(this,f)},u.prototype.create=function(f,d,p){for(var g=new a.Service(f,d,p),m=0,y;m<this.methodsArray.length;++m){var v=s.lcFirst((y=this._methodsArray[m]).resolve().name).replace(/[^$\w_]/g,"");g[v]=s.codegen(["r","c"],s.isReserved(v)?v+"_":v)("return this.rpcCall(m,q,s,r,c)")({m:y,q:y.resolvedRequestType.ctor,s:y.resolvedResponseType.ctor})}return g},service}var message=Message,util$1=requireMinimal();function Message(c){if(c)for(var i=Object.keys(c),s=0;s<i.length;++s)this[i[s]]=c[i[s]]}Message.create=function c(i){return this.$type.create(i)};Message.encode=function c(i,s){return this.$type.encode(i,s)};Message.encodeDelimited=function c(i,s){return this.$type.encodeDelimited(i,s)};Message.decode=function c(i){return this.$type.decode(i)};Message.decodeDelimited=function c(i){return this.$type.decodeDelimited(i)};Message.verify=function c(i){return this.$type.verify(i)};Message.fromObject=function c(i){return this.$type.fromObject(i)};Message.toObject=function c(i,s){return this.$type.toObject(i,s)};Message.prototype.toJSON=function c(){return this.$type.toObject(this,util$1.toJSONOptions)};var decoder_1,hasRequiredDecoder;function requireDecoder(){if(hasRequiredDecoder)return decoder_1;hasRequiredDecoder=1,decoder_1=u;var c=require_enum(),i=requireTypes(),s=requireUtil();function a(l){return"missing required '"+l.name+"'"}function u(l){var h=s.codegen(["r","l"],l.name+"$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor"+(l.fieldsArray.filter(function(y){return y.map}).length?",k,value":""))("while(r.pos<c){")("var t=r.uint32()");l.group&&h("if((t&7)===4)")("break"),h("switch(t>>>3){");for(var f=0;f<l.fieldsArray.length;++f){var d=l._fieldsArray[f].resolve(),p=d.resolvedType instanceof c?"int32":d.type,g="m"+s.safeProp(d.name);h("case %i: {",d.id),d.map?(h("if(%s===util.emptyObject)",g)("%s={}",g)("var c2 = r.uint32()+r.pos"),i.defaults[d.keyType]!==void 0?h("k=%j",i.defaults[d.keyType]):h("k=null"),i.defaults[p]!==void 0?h("value=%j",i.defaults[p]):h("value=null"),h("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break",d.keyType)("case 2:"),i.basic[p]===void 0?h("value=types[%i].decode(r,r.uint32())",f):h("value=r.%s()",p),h("break")("default:")("r.skipType(tag2&7)")("break")("}")("}"),i.long[d.keyType]!==void 0?h('%s[typeof k==="object"?util.longToHash(k):k]=value',g):h("%s[k]=value",g)):d.repeated?(h("if(!(%s&&%s.length))",g,g)("%s=[]",g),i.packed[p]!==void 0&&h("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())",g,p)("}else"),i.basic[p]===void 0?h(d.resolvedType.group?"%s.push(types[%i].decode(r))":"%s.push(types[%i].decode(r,r.uint32()))",g,f):h("%s.push(r.%s())",g,p)):i.basic[p]===void 0?h(d.resolvedType.group?"%s=types[%i].decode(r)":"%s=types[%i].decode(r,r.uint32())",g,f):h("%s=r.%s()",g,p),h("break")("}")}for(h("default:")("r.skipType(t&7)")("break")("}")("}"),f=0;f<l._fieldsArray.length;++f){var m=l._fieldsArray[f];m.required&&h("if(!m.hasOwnProperty(%j))",m.name)("throw util.ProtocolError(%j,{instance:m})",a(m))}return h("return m")}return decoder_1}var verifier_1,hasRequiredVerifier;function requireVerifier(){if(hasRequiredVerifier)return verifier_1;hasRequiredVerifier=1,verifier_1=l;var c=require_enum(),i=requireUtil();function s(h,f){return h.name+": "+f+(h.repeated&&f!=="array"?"[]":h.map&&f!=="object"?"{k:"+h.keyType+"}":"")+" expected"}function a(h,f,d,p){if(f.resolvedType)if(f.resolvedType instanceof c){h("switch(%s){",p)("default:")("return%j",s(f,"enum value"));for(var g=Object.keys(f.resolvedType.values),m=0;m<g.length;++m)h("case %i:",f.resolvedType.values[g[m]]);h("break")("}")}else h("{")("var e=types[%i].verify(%s);",d,p)("if(e)")("return%j+e",f.name+".")("}");else switch(f.type){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":h("if(!util.isInteger(%s))",p)("return%j",s(f,"integer"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":h("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))",p,p,p,p)("return%j",s(f,"integer|Long"));break;case"float":case"double":h('if(typeof %s!=="number")',p)("return%j",s(f,"number"));break;case"bool":h('if(typeof %s!=="boolean")',p)("return%j",s(f,"boolean"));break;case"string":h("if(!util.isString(%s))",p)("return%j",s(f,"string"));break;case"bytes":h('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))',p,p,p)("return%j",s(f,"buffer"));break}return h}function u(h,f,d){switch(f.keyType){case"int32":case"uint32":case"sint32":case"fixed32":case"sfixed32":h("if(!util.key32Re.test(%s))",d)("return%j",s(f,"integer key"));break;case"int64":case"uint64":case"sint64":case"fixed64":case"sfixed64":h("if(!util.key64Re.test(%s))",d)("return%j",s(f,"integer|Long key"));break;case"bool":h("if(!util.key2Re.test(%s))",d)("return%j",s(f,"boolean key"));break}return h}function l(h){var f=i.codegen(["m"],h.name+"$verify")('if(typeof m!=="object"||m===null)')("return%j","object expected"),d=h.oneofsArray,p={};d.length&&f("var p={}");for(var g=0;g<h.fieldsArray.length;++g){var m=h._fieldsArray[g].resolve(),y="m"+i.safeProp(m.name);if(m.optional&&f("if(%s!=null&&m.hasOwnProperty(%j)){",y,m.name),m.map)f("if(!util.isObject(%s))",y)("return%j",s(m,"object"))("var k=Object.keys(%s)",y)("for(var i=0;i<k.length;++i){"),u(f,m,"k[i]"),a(f,m,g,y+"[k[i]]")("}");else if(m.repeated)f("if(!Array.isArray(%s))",y)("return%j",s(m,"array"))("for(var i=0;i<%s.length;++i){",y),a(f,m,g,y+"[i]")("}");else{if(m.partOf){var v=i.safeProp(m.partOf.name);p[m.partOf.name]===1&&f("if(p%s===1)",v)("return%j",m.partOf.name+": multiple values"),p[m.partOf.name]=1,f("p%s=1",v)}a(f,m,g,y)}m.optional&&f("}")}return f("return null")}return verifier_1}var converter={},hasRequiredConverter;function requireConverter(){return hasRequiredConverter||(hasRequiredConverter=1,function(c){var i=c,s=require_enum(),a=requireUtil();function u(h,f,d,p){var g=!1;if(f.resolvedType)if(f.resolvedType instanceof s){h("switch(d%s){",p);for(var m=f.resolvedType.values,y=Object.keys(m),v=0;v<y.length;++v)m[y[v]]===f.typeDefault&&!g&&(h("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}',p,p,p),f.repeated||h("break"),g=!0),h("case%j:",y[v])("case %i:",m[y[v]])("m%s=%j",p,m[y[v]])("break");h("}")}else h('if(typeof d%s!=="object")',p)("throw TypeError(%j)",f.fullName+": object expected")("m%s=types[%i].fromObject(d%s)",p,d,p);else{var _=!1;switch(f.type){case"double":case"float":h("m%s=Number(d%s)",p,p);break;case"uint32":case"fixed32":h("m%s=d%s>>>0",p,p);break;case"int32":case"sint32":case"sfixed32":h("m%s=d%s|0",p,p);break;case"uint64":_=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":h("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j",p,p,_)('else if(typeof d%s==="string")',p)("m%s=parseInt(d%s,10)",p,p)('else if(typeof d%s==="number")',p)("m%s=d%s",p,p)('else if(typeof d%s==="object")',p)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)",p,p,p,_?"true":"");break;case"bytes":h('if(typeof d%s==="string")',p)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)",p,p,p)("else if(d%s.length >= 0)",p)("m%s=d%s",p,p);break;case"string":h("m%s=String(d%s)",p,p);break;case"bool":h("m%s=Boolean(d%s)",p,p);break}}return h}i.fromObject=function(f){var d=f.fieldsArray,p=a.codegen(["d"],f.name+"$fromObject")("if(d instanceof this.ctor)")("return d");if(!d.length)return p("return new this.ctor");p("var m=new this.ctor");for(var g=0;g<d.length;++g){var m=d[g].resolve(),y=a.safeProp(m.name);m.map?(p("if(d%s){",y)('if(typeof d%s!=="object")',y)("throw TypeError(%j)",m.fullName+": object expected")("m%s={}",y)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){",y),u(p,m,g,y+"[ks[i]]")("}")("}")):m.repeated?(p("if(d%s){",y)("if(!Array.isArray(d%s))",y)("throw TypeError(%j)",m.fullName+": array expected")("m%s=[]",y)("for(var i=0;i<d%s.length;++i){",y),u(p,m,g,y+"[i]")("}")("}")):(m.resolvedType instanceof s||p("if(d%s!=null){",y),u(p,m,g,y),m.resolvedType instanceof s||p("}"))}return p("return m")};function l(h,f,d,p){if(f.resolvedType)f.resolvedType instanceof s?h("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s",p,d,p,p,d,p,p):h("d%s=types[%i].toObject(m%s,o)",p,d,p);else{var g=!1;switch(f.type){case"double":case"float":h("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s",p,p,p,p);break;case"uint64":g=!0;case"int64":case"sint64":case"fixed64":case"sfixed64":h('if(typeof m%s==="number")',p)("d%s=o.longs===String?String(m%s):m%s",p,p,p)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s",p,p,p,p,g?"true":"",p);break;case"bytes":h("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s",p,p,p,p,p);break;default:h("d%s=m%s",p,p);break}}return h}i.toObject=function(f){var d=f.fieldsArray.slice().sort(a.compareFieldsById);if(!d.length)return a.codegen()("return {}");for(var p=a.codegen(["m","o"],f.name+"$toObject")("if(!o)")("o={}")("var d={}"),g=[],m=[],y=[],v=0;v<d.length;++v)d[v].partOf||(d[v].resolve().repeated?g:d[v].map?m:y).push(d[v]);if(g.length){for(p("if(o.arrays||o.defaults){"),v=0;v<g.length;++v)p("d%s=[]",a.safeProp(g[v].name));p("}")}if(m.length){for(p("if(o.objects||o.defaults){"),v=0;v<m.length;++v)p("d%s={}",a.safeProp(m[v].name));p("}")}if(y.length){for(p("if(o.defaults){"),v=0;v<y.length;++v){var _=y[v],A=a.safeProp(_.name);if(_.resolvedType instanceof s)p("d%s=o.enums===String?%j:%j",A,_.resolvedType.valuesById[_.typeDefault],_.typeDefault);else if(_.long)p("if(util.Long){")("var n=new util.Long(%i,%i,%j)",_.typeDefault.low,_.typeDefault.high,_.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n",A)("}else")("d%s=o.longs===String?%j:%i",A,_.typeDefault.toString(),_.typeDefault.toNumber());else if(_.bytes){var T="["+Array.prototype.slice.call(_.typeDefault).join(",")+"]";p("if(o.bytes===String)d%s=%j",A,String.fromCharCode.apply(String,_.typeDefault))("else{")("d%s=%s",A,T)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)",A,A)("}")}else p("d%s=%j",A,_.typeDefault)}p("}")}var x=!1;for(v=0;v<d.length;++v){var _=d[v],w=f._fieldsArray.indexOf(_),A=a.safeProp(_.name);_.map?(x||(x=!0,p("var ks2")),p("if(m%s&&(ks2=Object.keys(m%s)).length){",A,A)("d%s={}",A)("for(var j=0;j<ks2.length;++j){"),l(p,_,w,A+"[ks2[j]]")("}")):_.repeated?(p("if(m%s&&m%s.length){",A,A)("d%s=[]",A)("for(var j=0;j<m%s.length;++j){",A),l(p,_,w,A+"[j]")("}")):(p("if(m%s!=null&&m.hasOwnProperty(%j)){",A,_.name),l(p,_,w,A),_.partOf&&p("if(o.oneofs)")("d%s=%j",a.safeProp(_.partOf.name),_.name)),p("}")}return p("return d")}}(converter)),converter}var wrappers={};(function(c){var i=c,s=message;i[".google.protobuf.Any"]={fromObject:function(a){if(a&&a["@type"]){var u=a["@type"].substring(a["@type"].lastIndexOf("/")+1),l=this.lookup(u);if(l){var h=a["@type"].charAt(0)==="."?a["@type"].slice(1):a["@type"];return h.indexOf("/")===-1&&(h="/"+h),this.create({type_url:h,value:l.encode(l.fromObject(a)).finish()})}}return this.fromObject(a)},toObject:function(a,u){var l="type.googleapis.com/",h="",f="";if(u&&u.json&&a.type_url&&a.value){f=a.type_url.substring(a.type_url.lastIndexOf("/")+1),h=a.type_url.substring(0,a.type_url.lastIndexOf("/")+1);var d=this.lookup(f);d&&(a=d.decode(a.value))}if(!(a instanceof this.ctor)&&a instanceof s){var p=a.$type.toObject(a,u),g=a.$type.fullName[0]==="."?a.$type.fullName.slice(1):a.$type.fullName;return h===""&&(h=l),f=h+g,p["@type"]=f,p}return this.toObject(a,u)}}})(wrappers);var type,hasRequiredType;function requireType(){if(hasRequiredType)return type;hasRequiredType=1,type=A;var c=requireNamespace();((A.prototype=Object.create(c.prototype)).constructor=A).className="Type";var i=require_enum(),s=requireOneof(),a=requireField(),u=requireMapfield(),l=requireService(),h=message,f=reader,d=writer,p=requireUtil(),g=requireEncoder(),m=requireDecoder(),y=requireVerifier(),v=requireConverter(),_=wrappers;function A(x,w){c.call(this,x,w),this.fields={},this.oneofs=void 0,this.extensions=void 0,this.reserved=void 0,this.group=void 0,this._fieldsById=null,this._fieldsArray=null,this._oneofsArray=null,this._ctor=null}Object.defineProperties(A.prototype,{fieldsById:{get:function(){if(this._fieldsById)return this._fieldsById;this._fieldsById={};for(var x=Object.keys(this.fields),w=0;w<x.length;++w){var b=this.fields[x[w]],C=b.id;if(this._fieldsById[C])throw Error("duplicate id "+C+" in "+this);this._fieldsById[C]=b}return this._fieldsById}},fieldsArray:{get:function(){return this._fieldsArray||(this._fieldsArray=p.toArray(this.fields))}},oneofsArray:{get:function(){return this._oneofsArray||(this._oneofsArray=p.toArray(this.oneofs))}},ctor:{get:function(){return this._ctor||(this.ctor=A.generateConstructor(this)())},set:function(x){var w=x.prototype;w instanceof h||((x.prototype=new h).constructor=x,p.merge(x.prototype,w)),x.$type=x.prototype.$type=this,p.merge(x,h,!0),this._ctor=x;for(var b=0;b<this.fieldsArray.length;++b)this._fieldsArray[b].resolve();var C={};for(b=0;b<this.oneofsArray.length;++b)C[this._oneofsArray[b].resolve().name]={get:p.oneOfGetter(this._oneofsArray[b].oneof),set:p.oneOfSetter(this._oneofsArray[b].oneof)};b&&Object.defineProperties(x.prototype,C)}}}),A.generateConstructor=function(w){for(var b=p.codegen(["p"],w.name),C=0,N;C<w.fieldsArray.length;++C)(N=w._fieldsArray[C]).map?b("this%s={}",p.safeProp(N.name)):N.repeated&&b("this%s=[]",p.safeProp(N.name));return b("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]")};function T(x){return x._fieldsById=x._fieldsArray=x._oneofsArray=null,delete x.encode,delete x.decode,delete x.verify,x}return A.fromJSON=function(w,b){var C=new A(w,b.options);C.extensions=b.extensions,C.reserved=b.reserved;for(var N=Object.keys(b.fields),S=0;S<N.length;++S)C.add((typeof b.fields[N[S]].keyType<"u"?u.fromJSON:a.fromJSON)(N[S],b.fields[N[S]]));if(b.oneofs)for(N=Object.keys(b.oneofs),S=0;S<N.length;++S)C.add(s.fromJSON(N[S],b.oneofs[N[S]]));if(b.nested)for(N=Object.keys(b.nested),S=0;S<N.length;++S){var O=b.nested[N[S]];C.add((O.id!==void 0?a.fromJSON:O.fields!==void 0?A.fromJSON:O.values!==void 0?i.fromJSON:O.methods!==void 0?l.fromJSON:c.fromJSON)(N[S],O))}return b.extensions&&b.extensions.length&&(C.extensions=b.extensions),b.reserved&&b.reserved.length&&(C.reserved=b.reserved),b.group&&(C.group=!0),b.comment&&(C.comment=b.comment),C},A.prototype.toJSON=function(w){var b=c.prototype.toJSON.call(this,w),C=w?Boolean(w.keepComments):!1;return p.toObject(["options",b&&b.options||void 0,"oneofs",c.arrayToJSON(this.oneofsArray,w),"fields",c.arrayToJSON(this.fieldsArray.filter(function(N){return!N.declaringField}),w)||{},"extensions",this.extensions&&this.extensions.length?this.extensions:void 0,"reserved",this.reserved&&this.reserved.length?this.reserved:void 0,"group",this.group||void 0,"nested",b&&b.nested||void 0,"comment",C?this.comment:void 0])},A.prototype.resolveAll=function(){for(var w=this.fieldsArray,b=0;b<w.length;)w[b++].resolve();var C=this.oneofsArray;for(b=0;b<C.length;)C[b++].resolve();return c.prototype.resolveAll.call(this)},A.prototype.get=function(w){return this.fields[w]||this.oneofs&&this.oneofs[w]||this.nested&&this.nested[w]||null},A.prototype.add=function(w){if(this.get(w.name))throw Error("duplicate name '"+w.name+"' in "+this);if(w instanceof a&&w.extend===void 0){if(this._fieldsById?this._fieldsById[w.id]:this.fieldsById[w.id])throw Error("duplicate id "+w.id+" in "+this);if(this.isReservedId(w.id))throw Error("id "+w.id+" is reserved in "+this);if(this.isReservedName(w.name))throw Error("name '"+w.name+"' is reserved in "+this);return w.parent&&w.parent.remove(w),this.fields[w.name]=w,w.message=this,w.onAdd(this),T(this)}return w instanceof s?(this.oneofs||(this.oneofs={}),this.oneofs[w.name]=w,w.onAdd(this),T(this)):c.prototype.add.call(this,w)},A.prototype.remove=function(w){if(w instanceof a&&w.extend===void 0){if(!this.fields||this.fields[w.name]!==w)throw Error(w+" is not a member of "+this);return delete this.fields[w.name],w.parent=null,w.onRemove(this),T(this)}if(w instanceof s){if(!this.oneofs||this.oneofs[w.name]!==w)throw Error(w+" is not a member of "+this);return delete this.oneofs[w.name],w.parent=null,w.onRemove(this),T(this)}return c.prototype.remove.call(this,w)},A.prototype.isReservedId=function(w){return c.isReservedId(this.reserved,w)},A.prototype.isReservedName=function(w){return c.isReservedName(this.reserved,w)},A.prototype.create=function(w){return new this.ctor(w)},A.prototype.setup=function(){for(var w=this.fullName,b=[],C=0;C<this.fieldsArray.length;++C)b.push(this._fieldsArray[C].resolve().resolvedType);this.encode=g(this)({Writer:d,types:b,util:p}),this.decode=m(this)({Reader:f,types:b,util:p}),this.verify=y(this)({types:b,util:p}),this.fromObject=v.fromObject(this)({types:b,util:p}),this.toObject=v.toObject(this)({types:b,util:p});var N=_[w];if(N){var S=Object.create(this);S.fromObject=this.fromObject,this.fromObject=N.fromObject.bind(S),S.toObject=this.toObject,this.toObject=N.toObject.bind(S)}return this},A.prototype.encode=function(w,b){return this.setup().encode(w,b)},A.prototype.encodeDelimited=function(w,b){return this.encode(w,b&&b.len?b.fork():b).ldelim()},A.prototype.decode=function(w,b){return this.setup().decode(w,b)},A.prototype.decodeDelimited=function(w){return w instanceof f||(w=f.create(w)),this.decode(w,w.uint32())},A.prototype.verify=function(w){return this.setup().verify(w)},A.prototype.fromObject=function(w){return this.setup().fromObject(w)},A.prototype.toObject=function(w,b){return this.setup().toObject(w,b)},A.d=function(w){return function(C){p.decorateType(C,w)}},type}var root,hasRequiredRoot;function requireRoot(){if(hasRequiredRoot)return root;hasRequiredRoot=1,root=d;var c=requireNamespace();((d.prototype=Object.create(c.prototype)).constructor=d).className="Root";var i=requireField(),s=require_enum(),a=requireOneof(),u=requireUtil(),l,h,f;function d(y){c.call(this,"",y),this.deferred=[],this.files=[]}d.fromJSON=function(v,_){return _||(_=new d),v.options&&_.setOptions(v.options),_.addJSON(v.nested)},d.prototype.resolvePath=u.path.resolve,d.prototype.fetch=u.fetch;function p(){}d.prototype.load=function y(v,_,A){typeof _=="function"&&(A=_,_=void 0);var T=this;if(!A)return u.asPromise(y,T,v,_);var x=A===p;function w(R,I){if(A){var M=A;if(A=null,x)throw R;M(R,I)}}function b(R){var I=R.lastIndexOf("google/protobuf/");if(I>-1){var M=R.substring(I);if(M in f)return M}return null}function C(R,I){try{if(u.isString(I)&&I.charAt(0)==="{"&&(I=JSON.parse(I)),!u.isString(I))T.setOptions(I.options).addJSON(I.nested);else{h.filename=R;var M=h(I,T,_),k,B=0;if(M.imports)for(;B<M.imports.length;++B)(k=b(M.imports[B])||T.resolvePath(R,M.imports[B]))&&N(k);if(M.weakImports)for(B=0;B<M.weakImports.length;++B)(k=b(M.weakImports[B])||T.resolvePath(R,M.weakImports[B]))&&N(k,!0)}}catch(P){w(P)}!x&&!S&&w(null,T)}function N(R,I){if(R=b(R)||R,!(T.files.indexOf(R)>-1)){if(T.files.push(R),R in f){x?C(R,f[R]):(++S,setTimeout(function(){--S,C(R,f[R])}));return}if(x){var M;try{M=u.fs.readFileSync(R).toString("utf8")}catch(k){I||w(k);return}C(R,M)}else++S,T.fetch(R,function(k,B){if(--S,!!A){if(k){I?S||w(null,T):w(k);return}C(R,B)}})}}var S=0;u.isString(v)&&(v=[v]);for(var O=0,E;O<v.length;++O)(E=T.resolvePath("",v[O]))&&N(E);if(x)return T;S||w(null,T)},d.prototype.loadSync=function(v,_){if(!u.isNode)throw Error("not supported");return this.load(v,_,p)},d.prototype.resolveAll=function(){if(this.deferred.length)throw Error("unresolvable extensions: "+this.deferred.map(function(v){return"'extend "+v.extend+"' in "+v.parent.fullName}).join(", "));return c.prototype.resolveAll.call(this)};var g=/^[A-Z]/;function m(y,v){var _=v.parent.lookup(v.extend);if(_){var A=new i(v.fullName,v.id,v.type,v.rule,void 0,v.options);return _.get(A.name)||(A.declaringField=v,v.extensionField=A,_.add(A)),!0}return!1}return d.prototype._handleAdd=function(v){if(v instanceof i)v.extend!==void 0&&!v.extensionField&&(m(this,v)||this.deferred.push(v));else if(v instanceof s)g.test(v.name)&&(v.parent[v.name]=v.values);else if(!(v instanceof a)){if(v instanceof l)for(var _=0;_<this.deferred.length;)m(this,this.deferred[_])?this.deferred.splice(_,1):++_;for(var A=0;A<v.nestedArray.length;++A)this._handleAdd(v._nestedArray[A]);g.test(v.name)&&(v.parent[v.name]=v)}},d.prototype._handleRemove=function(v){if(v instanceof i){if(v.extend!==void 0)if(v.extensionField)v.extensionField.parent.remove(v.extensionField),v.extensionField=null;else{var _=this.deferred.indexOf(v);_>-1&&this.deferred.splice(_,1)}}else if(v instanceof s)g.test(v.name)&&delete v.parent[v.name];else if(v instanceof c){for(var A=0;A<v.nestedArray.length;++A)this._handleRemove(v._nestedArray[A]);g.test(v.name)&&delete v.parent[v.name]}},d._configure=function(y,v,_){l=y,h=v,f=_},root}var hasRequiredUtil;function requireUtil(){return hasRequiredUtil||(hasRequiredUtil=1,function(c){var i=c.exports=requireMinimal(),s=roots,a,u;i.codegen=codegen_1,i.fetch=fetch_1,i.path=path,i.fs=i.inquire("fs"),i.toArray=function(g){if(g){for(var m=Object.keys(g),y=new Array(m.length),v=0;v<m.length;)y[v]=g[m[v++]];return y}return[]},i.toObject=function(g){for(var m={},y=0;y<g.length;){var v=g[y++],_=g[y++];_!==void 0&&(m[v]=_)}return m};var l=/\\/g,h=/"/g;i.isReserved=function(g){return/^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(g)},i.safeProp=function(g){return!/^[$\w_]+$/.test(g)||i.isReserved(g)?'["'+g.replace(l,"\\\\").replace(h,'\\"')+'"]':"."+g},i.ucFirst=function(g){return g.charAt(0).toUpperCase()+g.substring(1)};var f=/_([a-z])/g;i.camelCase=function(g){return g.substring(0,1)+g.substring(1).replace(f,function(m,y){return y.toUpperCase()})},i.compareFieldsById=function(g,m){return g.id-m.id},i.decorateType=function(g,m){if(g.$type)return m&&g.$type.name!==m&&(i.decorateRoot.remove(g.$type),g.$type.name=m,i.decorateRoot.add(g.$type)),g.$type;a||(a=requireType());var y=new a(m||g.name);return i.decorateRoot.add(y),y.ctor=g,Object.defineProperty(g,"$type",{value:y,enumerable:!1}),Object.defineProperty(g.prototype,"$type",{value:y,enumerable:!1}),y};var d=0;i.decorateEnum=function(g){if(g.$type)return g.$type;u||(u=require_enum());var m=new u("Enum"+d++,g);return i.decorateRoot.add(m),Object.defineProperty(g,"$type",{value:m,enumerable:!1}),m},i.setProperty=function(g,m,y){function v(_,A,T){var x=A.shift();if(x==="__proto__")return _;if(A.length>0)_[x]=v(_[x]||{},A,T);else{var w=_[x];w&&(T=[].concat(w).concat(T)),_[x]=T}return _}if(typeof g!="object")throw TypeError("dst must be an object");if(!m)throw TypeError("path must be specified");return m=m.split("."),v(g,m,y)},Object.defineProperty(i,"decorateRoot",{get:function(){return s.decorated||(s.decorated=new(requireRoot()))}})}(util$2)),utilExports}var object,hasRequiredObject;function requireObject(){if(hasRequiredObject)return object;hasRequiredObject=1,object=s,s.className="ReflectionObject";var c=requireUtil(),i;function s(a,u){if(!c.isString(a))throw TypeError("name must be a string");if(u&&!c.isObject(u))throw TypeError("options must be an object");this.options=u,this.parsedOptions=null,this.name=a,this.parent=null,this.resolved=!1,this.comment=null,this.filename=null}return Object.defineProperties(s.prototype,{root:{get:function(){for(var a=this;a.parent!==null;)a=a.parent;return a}},fullName:{get:function(){for(var a=[this.name],u=this.parent;u;)a.unshift(u.name),u=u.parent;return a.join(".")}}}),s.prototype.toJSON=function(){throw Error()},s.prototype.onAdd=function(u){this.parent&&this.parent!==u&&this.parent.remove(this),this.parent=u,this.resolved=!1;var l=u.root;l instanceof i&&l._handleAdd(this)},s.prototype.onRemove=function(u){var l=u.root;l instanceof i&&l._handleRemove(this),this.parent=null,this.resolved=!1},s.prototype.resolve=function(){return this.resolved?this:(this.root instanceof i&&(this.resolved=!0),this)},s.prototype.getOption=function(u){if(this.options)return this.options[u]},s.prototype.setOption=function(u,l,h){return(!h||!this.options||this.options[u]===void 0)&&((this.options||(this.options={}))[u]=l),this},s.prototype.setParsedOption=function(u,l,h){this.parsedOptions||(this.parsedOptions=[]);var f=this.parsedOptions;if(h){var d=f.find(function(m){return Object.prototype.hasOwnProperty.call(m,u)});if(d){var p=d[u];c.setProperty(p,h,l)}else d={},d[u]=c.setProperty({},h,l),f.push(d)}else{var g={};g[u]=l,f.push(g)}return this},s.prototype.setOptions=function(u,l){if(u)for(var h=Object.keys(u),f=0;f<h.length;++f)this.setOption(h[f],u[h[f]],l);return this},s.prototype.toString=function(){var u=this.constructor.className,l=this.fullName;return l.length?u+" "+l:u},s._configure=function(a){i=a},object}var _enum,hasRequired_enum;function require_enum(){if(hasRequired_enum)return _enum;hasRequired_enum=1,_enum=a;var c=requireObject();((a.prototype=Object.create(c.prototype)).constructor=a).className="Enum";var i=requireNamespace(),s=requireUtil();function a(u,l,h,f,d,p){if(c.call(this,u,h),l&&typeof l!="object")throw TypeError("values must be an object");if(this.valuesById={},this.values=Object.create(this.valuesById),this.comment=f,this.comments=d||{},this.valuesOptions=p,this.reserved=void 0,l)for(var g=Object.keys(l),m=0;m<g.length;++m)typeof l[g[m]]=="number"&&(this.valuesById[this.values[g[m]]=l[g[m]]]=g[m])}return a.fromJSON=function(l,h){var f=new a(l,h.values,h.options,h.comment,h.comments);return f.reserved=h.reserved,f},a.prototype.toJSON=function(l){var h=l?Boolean(l.keepComments):!1;return s.toObject(["options",this.options,"valuesOptions",this.valuesOptions,"values",this.values,"reserved",this.reserved&&this.reserved.length?this.reserved:void 0,"comment",h?this.comment:void 0,"comments",h?this.comments:void 0])},a.prototype.add=function(l,h,f,d){if(!s.isString(l))throw TypeError("name must be a string");if(!s.isInteger(h))throw TypeError("id must be an integer");if(this.values[l]!==void 0)throw Error("duplicate name '"+l+"' in "+this);if(this.isReservedId(h))throw Error("id "+h+" is reserved in "+this);if(this.isReservedName(l))throw Error("name '"+l+"' is reserved in "+this);if(this.valuesById[h]!==void 0){if(!(this.options&&this.options.allow_alias))throw Error("duplicate id "+h+" in "+this);this.values[l]=h}else this.valuesById[this.values[l]=h]=l;return d&&(this.valuesOptions===void 0&&(this.valuesOptions={}),this.valuesOptions[l]=d||null),this.comments[l]=f||null,this},a.prototype.remove=function(l){if(!s.isString(l))throw TypeError("name must be a string");var h=this.values[l];if(h==null)throw Error("name '"+l+"' does not exist in "+this);return delete this.valuesById[h],delete this.values[l],delete this.comments[l],this.valuesOptions&&delete this.valuesOptions[l],this},a.prototype.isReservedId=function(l){return i.isReservedId(this.reserved,l)},a.prototype.isReservedName=function(l){return i.isReservedName(this.reserved,l)},_enum}var encoder_1,hasRequiredEncoder;function requireEncoder(){if(hasRequiredEncoder)return encoder_1;hasRequiredEncoder=1,encoder_1=u;var c=require_enum(),i=requireTypes(),s=requireUtil();function a(l,h,f,d){return h.resolvedType.group?l("types[%i].encode(%s,w.uint32(%i)).uint32(%i)",f,d,(h.id<<3|3)>>>0,(h.id<<3|4)>>>0):l("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()",f,d,(h.id<<3|2)>>>0)}function u(l){for(var h=s.codegen(["m","w"],l.name+"$encode")("if(!w)")("w=Writer.create()"),f,d,p=l.fieldsArray.slice().sort(s.compareFieldsById),f=0;f<p.length;++f){var g=p[f].resolve(),m=l._fieldsArray.indexOf(g),y=g.resolvedType instanceof c?"int32":g.type,v=i.basic[y];d="m"+s.safeProp(g.name),g.map?(h("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){",d,g.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){",d)("w.uint32(%i).fork().uint32(%i).%s(ks[i])",(g.id<<3|2)>>>0,8|i.mapKey[g.keyType],g.keyType),v===void 0?h("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()",m,d):h(".uint32(%i).%s(%s[ks[i]]).ldelim()",16|v,y,d),h("}")("}")):g.repeated?(h("if(%s!=null&&%s.length){",d,d),g.packed&&i.packed[y]!==void 0?h("w.uint32(%i).fork()",(g.id<<3|2)>>>0)("for(var i=0;i<%s.length;++i)",d)("w.%s(%s[i])",y,d)("w.ldelim()"):(h("for(var i=0;i<%s.length;++i)",d),v===void 0?a(h,g,m,d+"[i]"):h("w.uint32(%i).%s(%s[i])",(g.id<<3|v)>>>0,y,d)),h("}")):(g.optional&&h("if(%s!=null&&Object.hasOwnProperty.call(m,%j))",d,g.name),v===void 0?a(h,g,m,d):h("w.uint32(%i).%s(%s)",(g.id<<3|v)>>>0,y,d))}return h("return w")}return encoder_1}(function(c){var i=c.exports=indexMinimal;i.build="light";function s(u,l,h){return typeof l=="function"?(h=l,l=new i.Root):l||(l=new i.Root),l.load(u,h)}i.load=s;function a(u,l){return l||(l=new i.Root),l.loadSync(u)}i.loadSync=a,i.encoder=requireEncoder(),i.decoder=requireDecoder(),i.verifier=requireVerifier(),i.converter=requireConverter(),i.ReflectionObject=requireObject(),i.Namespace=requireNamespace(),i.Root=requireRoot(),i.Enum=require_enum(),i.Type=requireType(),i.Field=requireField(),i.OneOf=requireOneof(),i.MapField=requireMapfield(),i.Service=requireService(),i.Method=requireMethod(),i.Message=message,i.wrappers=wrappers,i.types=requireTypes(),i.util=requireUtil(),i.ReflectionObject._configure(i.Root),i.Namespace._configure(i.Type,i.Service,i.Enum),i.Root._configure(i.Type),i.Field._configure(i.Type)})(indexLight);var tokenize_1=tokenize$1,delimRe=/[\s{}=;:[\],'"()<>]/g,stringDoubleRe=/(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,stringSingleRe=/(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,setCommentRe=/^ *[*/]+ */,setCommentAltRe=/^\s*\*?\/*/,setCommentSplitRe=/\n/g,whitespaceRe=/\s/,unescapeRe=/\\(.?)/g,unescapeMap={0:"\0",r:"\r",n:`
`,t:"	"};function unescape(c){return c.replace(unescapeRe,function(i,s){switch(s){case"\\":case"":return s;default:return unescapeMap[s]||""}})}tokenize$1.unescape=unescape;function tokenize$1(c,i){c=c.toString();var s=0,a=c.length,u=1,l=0,h={},f=[],d=null;function p(C){return Error("illegal "+C+" (line "+u+")")}function g(){var C=d==="'"?stringSingleRe:stringDoubleRe;C.lastIndex=s-1;var N=C.exec(c);if(!N)throw p("string");return s=C.lastIndex,T(d),d=null,unescape(N[1])}function m(C){return c.charAt(C)}function y(C,N,S){var O={type:c.charAt(C++),lineEmpty:!1,leading:S},E;i?E=2:E=3;var R=C-E,I;do if(--R<0||(I=c.charAt(R))===`
`){O.lineEmpty=!0;break}while(I===" "||I==="	");for(var M=c.substring(C,N).split(setCommentSplitRe),k=0;k<M.length;++k)M[k]=M[k].replace(i?setCommentAltRe:setCommentRe,"").trim();O.text=M.join(`
`).trim(),h[u]=O,l=u}function v(C){var N=_(C),S=c.substring(C,N),O=/^\s*\/{1,2}/.test(S);return O}function _(C){for(var N=C;N<a&&m(N)!==`
`;)N++;return N}function A(){if(f.length>0)return f.shift();if(d)return g();var C,N,S,O,E,R=s===0;do{if(s===a)return null;for(C=!1;whitespaceRe.test(S=m(s));)if(S===`
`&&(R=!0,++u),++s===a)return null;if(m(s)==="/"){if(++s===a)throw p("comment");if(m(s)==="/")if(i){if(O=s,E=!1,v(s)){E=!0;do if(s=_(s),s===a||(s++,!R))break;while(v(s))}else s=Math.min(a,_(s)+1);E&&(y(O,s,R),R=!0),u++,C=!0}else{for(E=m(O=s+1)==="/";m(++s)!==`
`;)if(s===a)return null;++s,E&&(y(O,s-1,R),R=!0),++u,C=!0}else if((S=m(s))==="*"){O=s+1,E=i||m(O)==="*";do{if(S===`
`&&++u,++s===a)throw p("comment");N=S,S=m(s)}while(N!=="*"||S!=="/");++s,E&&(y(O,s-2,R),R=!0),C=!0}else return"/"}}while(C);var I=s;delimRe.lastIndex=0;var M=delimRe.test(m(I++));if(!M)for(;I<a&&!delimRe.test(m(I));)++I;var k=c.substring(s,s=I);return(k==='"'||k==="'")&&(d=k),k}function T(C){f.push(C)}function x(){if(!f.length){var C=A();if(C===null)return null;T(C)}return f[0]}function w(C,N){var S=x(),O=S===C;if(O)return A(),!0;if(!N)throw p("token '"+S+"', '"+C+"' expected");return!1}function b(C){var N=null,S;return C===void 0?(S=h[u-1],delete h[u-1],S&&(i||S.type==="*"||S.lineEmpty)&&(N=S.leading?S.text:null)):(l<C&&x(),S=h[C],delete h[C],S&&!S.lineEmpty&&(i||S.type==="/")&&(N=S.leading?null:S.text)),N}return Object.defineProperty({next:A,peek:x,push:T,skip:w,cmnt:b},"line",{get:function(){return u}})}var parse_1=parse;parse.filename=null;parse.defaults={keepCase:!1};var tokenize=tokenize_1,Root=requireRoot(),Type=requireType(),Field=requireField(),MapField=requireMapfield(),OneOf=requireOneof(),Enum=require_enum(),Service=requireService(),Method=requireMethod(),types=requireTypes(),util=requireUtil(),base10Re=/^[1-9][0-9]*$/,base10NegRe=/^-?[1-9][0-9]*$/,base16Re=/^0[x][0-9a-fA-F]+$/,base16NegRe=/^-?0[x][0-9a-fA-F]+$/,base8Re=/^0[0-7]+$/,base8NegRe=/^-?0[0-7]+$/,numberRe=/^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,nameRe=/^[a-zA-Z_][a-zA-Z_0-9]*$/,typeRefRe=/^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,fqTypeRefRe=/^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;function parse(c,i,s){i instanceof Root||(s=i,i=new Root),s||(s=parse.defaults);var a=s.preferTrailingComment||!1,u=tokenize(c,s.alternateCommentMode||!1),l=u.next,h=u.push,f=u.peek,d=u.skip,p=u.cmnt,g=!0,m,y,v,_,A=!1,T=i,x=s.keepCase?function(D){return D}:util.camelCase;function w(D,F,V){var U=parse.filename;return V||(parse.filename=null),Error("illegal "+(F||"token")+" '"+D+"' ("+(U?U+", ":"")+"line "+u.line+")")}function b(){var D=[],F;do{if((F=l())!=='"'&&F!=="'")throw w(F);D.push(l()),d(F),F=f()}while(F==='"'||F==="'");return D.join("")}function C(D){var F=l();switch(F){case"'":case'"':return h(F),b();case"true":case"TRUE":return!0;case"false":case"FALSE":return!1}try{return S(F,!0)}catch{if(D&&typeRefRe.test(F))return F;throw w(F,"value")}}function N(D,F){var V,U;do F&&((V=f())==='"'||V==="'")?D.push(b()):D.push([U=O(l()),d("to",!0)?O(l()):U]);while(d(",",!0));d(";")}function S(D,F){var V=1;switch(D.charAt(0)==="-"&&(V=-1,D=D.substring(1)),D){case"inf":case"INF":case"Inf":return V*(1/0);case"nan":case"NAN":case"Nan":case"NaN":return NaN;case"0":return 0}if(base10Re.test(D))return V*parseInt(D,10);if(base16Re.test(D))return V*parseInt(D,16);if(base8Re.test(D))return V*parseInt(D,8);if(numberRe.test(D))return V*parseFloat(D);throw w(D,"number",F)}function O(D,F){switch(D){case"max":case"MAX":case"Max":return 536870911;case"0":return 0}if(!F&&D.charAt(0)==="-")throw w(D,"id");if(base10NegRe.test(D))return parseInt(D,10);if(base16NegRe.test(D))return parseInt(D,16);if(base8NegRe.test(D))return parseInt(D,8);throw w(D,"id")}function E(){if(m!==void 0)throw w("package");if(m=l(),!typeRefRe.test(m))throw w(m,"name");T=T.define(m),d(";")}function R(){var D=f(),F;switch(D){case"weak":F=v||(v=[]),l();break;case"public":l();default:F=y||(y=[]);break}D=b(),d(";"),F.push(D)}function I(){if(d("="),_=b(),A=_==="proto3",!A&&_!=="proto2")throw w(_,"syntax");d(";")}function M(D,F){switch(F){case"option":return Z(D,F),d(";"),!0;case"message":return B(D,F),!0;case"enum":return J(D,F),!0;case"service":return K(D,F),!0;case"extend":return ae(D,F),!0}return!1}function k(D,F,V){var U=u.line;if(D&&(typeof D.comment!="string"&&(D.comment=p()),D.filename=parse.filename),d("{",!0)){for(var j;(j=l())!=="}";)F(j);d(";",!0)}else V&&V(),d(";"),D&&(typeof D.comment!="string"||a)&&(D.comment=p(U)||D.comment)}function B(D,F){if(!nameRe.test(F=l()))throw w(F,"type name");var V=new Type(F);k(V,function(j){if(!M(V,j))switch(j){case"map":W(V);break;case"required":case"repeated":P(V,j);break;case"optional":A?P(V,"proto3_optional"):P(V,"optional");break;case"oneof":G(V,j);break;case"extensions":N(V.extensions||(V.extensions=[]));break;case"reserved":N(V.reserved||(V.reserved=[]),!0);break;default:if(!A||!typeRefRe.test(j))throw w(j);h(j),P(V,"optional");break}}),D.add(V)}function P(D,F,V){var U=l();if(U==="group"){z(D,F);return}if(!typeRefRe.test(U))throw w(U,"type");var j=l();if(!nameRe.test(j))throw w(j,"name");j=x(j),d("=");var Q=new Field(j,O(l()),U,F,V);if(k(Q,function(ee){if(ee==="option")Z(Q,ee),d(";");else throw w(ee)},function(){oe(Q)}),F==="proto3_optional"){var L=new OneOf("_"+j);Q.setOption("proto3_optional",!0),L.add(Q),D.add(L)}else D.add(Q);!A&&Q.repeated&&(types.packed[U]!==void 0||types.basic[U]===void 0)&&Q.setOption("packed",!1,!0)}function z(D,F){var V=l();if(!nameRe.test(V))throw w(V,"name");var U=util.lcFirst(V);V===U&&(V=util.ucFirst(V)),d("=");var j=O(l()),Q=new Type(V);Q.group=!0;var L=new Field(U,j,V,F);L.filename=parse.filename,k(Q,function(ee){switch(ee){case"option":Z(Q,ee),d(";");break;case"required":case"repeated":P(Q,ee);break;case"optional":A?P(Q,"proto3_optional"):P(Q,"optional");break;case"message":B(Q,ee);break;case"enum":J(Q,ee);break;default:throw w(ee)}}),D.add(Q).add(L)}function W(D){d("<");var F=l();if(types.mapKey[F]===void 0)throw w(F,"type");d(",");var V=l();if(!typeRefRe.test(V))throw w(V,"type");d(">");var U=l();if(!nameRe.test(U))throw w(U,"name");d("=");var j=new MapField(x(U),O(l()),F,V);k(j,function(L){if(L==="option")Z(j,L),d(";");else throw w(L)},function(){oe(j)}),D.add(j)}function G(D,F){if(!nameRe.test(F=l()))throw w(F,"name");var V=new OneOf(x(F));k(V,function(j){j==="option"?(Z(V,j),d(";")):(h(j),P(V,"optional"))}),D.add(V)}function J(D,F){if(!nameRe.test(F=l()))throw w(F,"name");var V=new Enum(F);k(V,function(j){switch(j){case"option":Z(V,j),d(";");break;case"reserved":N(V.reserved||(V.reserved=[]),!0);break;default:X(V,j)}}),D.add(V)}function X(D,F){if(!nameRe.test(F))throw w(F,"name");d("=");var V=O(l(),!0),U={options:void 0};U.setOption=function(j,Q){this.options===void 0&&(this.options={}),this.options[j]=Q},k(U,function(Q){if(Q==="option")Z(U,Q),d(";");else throw w(Q)},function(){oe(U)}),D.add(F,V,U.comment,U.options)}function Z(D,F){var V=d("(",!0);if(!typeRefRe.test(F=l()))throw w(F,"name");var U=F,j=U,Q;V&&(d(")"),U="("+U+")",j=U,F=f(),fqTypeRefRe.test(F)&&(Q=F.slice(1),U+=F,l())),d("=");var L=H(D,U);ce(D,j,L,Q)}function H(D,F){if(d("{",!0)){for(var V={};!d("}",!0);){if(!nameRe.test($=l()))throw w($,"name");var U,j=$;if(d(":",!0),f()==="{")U=H(D,F+"."+$);else if(f()==="["){U=[];var Q;if(d("[",!0)){do Q=C(!0),U.push(Q);while(d(",",!0));d("]"),typeof Q<"u"&&te(D,F+"."+$,Q)}}else U=C(!0),te(D,F+"."+$,U);var L=V[j];L&&(U=[].concat(L).concat(U)),V[j]=U,d(",",!0),d(";",!0)}return V}var Y=C(!0);return te(D,F,Y),Y}function te(D,F,V){D.setOption&&D.setOption(F,V)}function ce(D,F,V,U){D.setParsedOption&&D.setParsedOption(F,V,U)}function oe(D){if(d("[",!0)){do Z(D,"option");while(d(",",!0));d("]")}return D}function K(D,F){if(!nameRe.test(F=l()))throw w(F,"service name");var V=new Service(F);k(V,function(j){if(!M(V,j))if(j==="rpc")ie(V,j);else throw w(j)}),D.add(V)}function ie(D,F){var V=p(),U=F;if(!nameRe.test(F=l()))throw w(F,"name");var j=F,Q,L,Y,ee;if(d("("),d("stream",!0)&&(L=!0),!typeRefRe.test(F=l())||(Q=F,d(")"),d("returns"),d("("),d("stream",!0)&&(ee=!0),!typeRefRe.test(F=l())))throw w(F);Y=F,d(")");var re=new Method(j,U,Q,Y,L,ee);re.comment=V,k(re,function(se){if(se==="option")Z(re,se),d(";");else throw w(se)}),D.add(re)}function ae(D,F){if(!typeRefRe.test(F=l()))throw w(F,"reference");var V=F;k(null,function(j){switch(j){case"required":case"repeated":P(D,j,V);break;case"optional":A?P(D,"proto3_optional",V):P(D,"optional",V);break;default:if(!A||!typeRefRe.test(j))throw w(j);h(j),P(D,"optional",V);break}})}for(var $;($=l())!==null;)switch($){case"package":if(!g)throw w($);E();break;case"import":if(!g)throw w($);R();break;case"syntax":if(!g)throw w($);I();break;case"option":Z(T,$),d(";");break;default:if(M(T,$)){g=!1;continue}throw w($)}return parse.filename=null,{package:m,imports:y,weakImports:v,syntax:_,root:i}}var common_1=common,commonRe=/\/|\./;function common(c,i){commonRe.test(c)||(c="google/protobuf/"+c+".proto",i={nested:{google:{nested:{protobuf:{nested:i}}}}}),common[c]=i}common("any",{Any:{fields:{type_url:{type:"string",id:1},value:{type:"bytes",id:2}}}});var timeType;common("duration",{Duration:timeType={fields:{seconds:{type:"int64",id:1},nanos:{type:"int32",id:2}}}});common("timestamp",{Timestamp:timeType});common("empty",{Empty:{fields:{}}});common("struct",{Struct:{fields:{fields:{keyType:"string",type:"Value",id:1}}},Value:{oneofs:{kind:{oneof:["nullValue","numberValue","stringValue","boolValue","structValue","listValue"]}},fields:{nullValue:{type:"NullValue",id:1},numberValue:{type:"double",id:2},stringValue:{type:"string",id:3},boolValue:{type:"bool",id:4},structValue:{type:"Struct",id:5},listValue:{type:"ListValue",id:6}}},NullValue:{values:{NULL_VALUE:0}},ListValue:{fields:{values:{rule:"repeated",type:"Value",id:1}}}});common("wrappers",{DoubleValue:{fields:{value:{type:"double",id:1}}},FloatValue:{fields:{value:{type:"float",id:1}}},Int64Value:{fields:{value:{type:"int64",id:1}}},UInt64Value:{fields:{value:{type:"uint64",id:1}}},Int32Value:{fields:{value:{type:"int32",id:1}}},UInt32Value:{fields:{value:{type:"uint32",id:1}}},BoolValue:{fields:{value:{type:"bool",id:1}}},StringValue:{fields:{value:{type:"string",id:1}}},BytesValue:{fields:{value:{type:"bytes",id:1}}}});common("field_mask",{FieldMask:{fields:{paths:{rule:"repeated",type:"string",id:1}}}});common.get=function c(i){return common[i]||null};(function(c){var i=c.exports=indexLightExports;i.build="full",i.tokenize=tokenize_1,i.parse=parse_1,i.common=common_1,i.Root._configure(i.Type,i.parse,i.common)})(src);(function(c){c.exports=srcExports})(protobufjs);const protobuf=getDefaultExportFromCjs(protobufjsExports);class ProtoSerializer{constructor(i){this.message=i}static async init(){const s=(await protobuf.load("assets/message.proto")).lookupType("Message");return new ProtoSerializer(s)}serialize(i){const s=this.message.verify(i);if(s)throw Error(s);return this.message.encode(this.message.create(i)).finish()}deserialize(i){const s=this.message.decode(i);return this.message.toObject(s,{longs:String,enums:String,bytes:String})}}const apiUrl="wss://api.new-world.james-parker.dev";class Network{constructor(i,s,a,u,l){this.serializer=i,this.clientId=s,this.socket=a,this.players=u,this.createPlayer=l}static async init(i,s,a){const u=new ReconnectingWebSocket(`${apiUrl}/client`),l=await ProtoSerializer.init();return new Promise(h=>{u.onmessage=f=>{const d=JSON.parse(f.data);if(d.type==="connected"){if(d.state){const g=o(d.state);set(i.position,g.position.x,g.position.y,g.position.z)}const p=new Network(l,d.clientId,u,s,a);u.onmessage=p.processMessage.bind(p),h(p)}}})}async sendData(i){this.socket.send(JSON.stringify({...i,clientId:this.clientId}))}async processMessage(i){const s=JSON.parse(i.data);if(s.state){const a=o(s.state);console.log(a)}switch(s.type){case"client_connected":if(s.clientId===this.clientId)break;this.createPlayer(s.clientId);break;case"position":{if(s.clientId===this.clientId)break;let a=this.players[s.clientId];a||(a=this.createPlayer(s.clientId)),set(a.position,s.position.x,s.position.y,s.position.z);break}}}}const cubeVertexSize=4*10,cubePositionOffset=0,cubeUVOffset=4*8,cubeVertexCount=36,cubeVertexArray=new Float32Array([1,-1,1,1,1,0,1,1,1,1,-1,-1,1,1,0,0,1,1,0,1,-1,-1,-1,1,0,0,0,1,0,0,1,-1,-1,1,1,0,0,1,1,0,1,-1,1,1,1,0,1,1,1,1,-1,-1,-1,1,0,0,0,1,0,0,1,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,0,1,1,-1,-1,1,1,0,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,0,0,-1,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,1,1,1,-1,1,1,1,0,1,0,0,-1,1,-1,1,0,1,0,1,1,0,-1,1,1,1,0,1,1,1,1,1,1,1,-1,1,1,1,0,1,0,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,1,-1,1,0,1,0,1,0,0,-1,-1,-1,1,0,0,0,1,1,0,-1,-1,1,1,0,0,1,1,1,1,-1,1,-1,1,0,1,0,1,0,0,1,1,1,1,1,1,1,1,1,1,-1,1,1,1,0,1,1,1,0,1,-1,-1,1,1,0,0,1,1,0,0,-1,-1,1,1,0,0,1,1,0,0,1,-1,1,1,1,0,1,1,1,0,1,1,1,1,1,1,1,1,1,1,1,-1,-1,1,1,0,0,1,1,1,-1,-1,-1,1,0,0,0,1,0,1,-1,1,-1,1,0,1,0,1,0,0,1,1,-1,1,1,1,0,1,1,0,1,-1,-1,1,1,0,0,1,1,1,-1,1,-1,1,0,1,0,1,0,0]),vertex=`struct Uniforms {\r
  modelViewProjectionMatrix : mat4x4<f32>,\r
}\r
@binding(0) @group(0) var<uniform> uniforms : Uniforms;\r
\r
struct VertexOutput {\r
  @builtin(position) Position : vec4<f32>,\r
  @location(0) fragUV : vec2<f32>,\r
  @location(1) fragPosition: vec4<f32>,\r
}\r
\r
@vertex\r
fn main(\r
  @location(0) position : vec4<f32>,\r
  @location(1) uv : vec2<f32>\r
) -> VertexOutput {\r
  var output : VertexOutput;\r
  output.Position = uniforms.modelViewProjectionMatrix * (position * 100.0);\r
  output.fragUV = uv;\r
  output.fragPosition = 0.5 * (position + vec4(1.0, 1.0, 1.0, 1.0));\r
  return output;\r
}\r
`,fragment=`\r
@fragment\r
fn main(\r
  @location(0) fragUV: vec2<f32>,\r
  @location(1) fragPosition: vec4<f32>\r
) -> @location(0) vec4<f32> {\r
  return fragPosition;\r
}`;class Player{constructor(i,s){q(this,"position");q(this,"vertexBuffer");q(this,"uniformBuffer");q(this,"uniformBindGroup");q(this,"pipeline");this.position=s,this.pipeline=i.createRenderPipeline({layout:"auto",vertex:{module:i.createShaderModule({code:vertex}),entryPoint:"main",buffers:[{arrayStride:cubeVertexSize,attributes:[{shaderLocation:0,offset:cubePositionOffset,format:"float32x4"},{shaderLocation:1,offset:cubeUVOffset,format:"float32x2"}]}]},fragment:{module:i.createShaderModule({code:fragment}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.vertexBuffer=i.createBuffer({size:cubeVertexArray.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(cubeVertexArray),this.vertexBuffer.unmap();const a=4*16;this.uniformBuffer=i.createBuffer({size:a,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=i.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]})}getTransformationMatrix(i){const s=create$5();translate(s,s,this.position),scale$1(s,s,fromValues$1(100,100,100));const a=create$5();return multiply$2(a,i,s),a}update(i,s){const a=this.getTransformationMatrix(s);i.queue.writeBuffer(this.uniformBuffer,0,a.buffer,a.byteOffset,a.byteLength)}draw(i){i.setPipeline(this.pipeline),i.setBindGroup(0,this.uniformBindGroup),i.setVertexBuffer(0,this.vertexBuffer),i.draw(cubeVertexCount,1,0,0)}}function fixPoint(c){return c>=0?c+1:c}function generatePoints(c){const i=[],s=c*2;for(let a=0;a<s;a++)for(let u=0;u<s;u++)for(let l=0;l<s;l++){if(!(a===0||a===s-1||u===0||u===s-1||l===0||l===s-1))continue;const h={x:fixPoint(a-c),y:fixPoint(u-c),z:fixPoint(l-c)};i.push(h)}return i}const points=[];for(let c=0;c<=6;c++)points[c]=generatePoints(c);class WorldGenerator{constructor(i){q(this,"minStride");this.minStride=i}init(i,s,a){return{x:Math.round(i/this.minStride)*this.minStride,y:Math.round(s/this.minStride)*this.minStride,z:Math.round(a/this.minStride)*this.minStride,stride:this.minStride,iteration:0,layer:1,previousOffset:-1*this.minStride/2}}layerRadius(i,s){return s===this.minStride?i:2}radius(i,s,a){return Math.sign(i)*(a+Math.abs(i)*s)}layerCount(i){return i==this.minStride?2:1}next(i){const s=points[this.layerRadius(i.layer,i.stride)],a=s[i.iteration],u=i.stride/2;let l=i.iteration+1,h=i.layer,f=i.stride,d=i.previousOffset;if(l>=s.length){l=0,h++;const p=this.layerCount(i.stride);h>p&&(h=1,f*=2,d=this.radius(i.layer,i.stride,i.previousOffset)-i.stride/2)}return[{x:i.stride*a.x+i.x-Math.sign(a.x)*u,y:i.stride*a.y+i.y-Math.sign(a.y)*u,z:i.stride*a.z+i.z-Math.sign(a.z)*u,stride:i.stride},{...i,iteration:l,layer:h,stride:f,previousOffset:d}]}}class Camera{constructor(i,s){q(this,"forward");q(this,"viewMatrix");q(this,"rotation");this.controller=i,this.mouse=s,this.viewMatrix=create$5(),this.rotation=0,this.forward=create$4()}update(i){this.rotation-=toRadian(this.mouse.position.y*.08),this.rotation=Math.max(-Math.PI/2,Math.min(Math.PI/2,this.rotation));const s=this.controller.getTransformMatrix();copy$1(this.viewMatrix,s),rotateX(this.viewMatrix,this.viewMatrix,this.rotation),normalize$2(this.forward,this.viewMatrix.slice(8,11)),invert(this.viewMatrix,this.viewMatrix),multiply$2(this.viewMatrix,i,this.viewMatrix)}}class Pointer{constructor(i,s,a,u){q(this,"position");q(this,"vertexBuffer");q(this,"uniformBuffer");q(this,"uniformBindGroup");q(this,"pipeline");q(this,"updating");this.controller=s,this.camera=a,this.raycast=u,this.position=create$4(),this.updating=!1,this.pipeline=i.createRenderPipeline({layout:"auto",vertex:{module:i.createShaderModule({code:vertex}),entryPoint:"main",buffers:[{arrayStride:cubeVertexSize,attributes:[{shaderLocation:0,offset:cubePositionOffset,format:"float32x4"},{shaderLocation:1,offset:cubeUVOffset,format:"float32x2"}]}]},fragment:{module:i.createShaderModule({code:fragment}),entryPoint:"main",targets:[{format:"bgra8unorm"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth24plus-stencil8"}}),this.vertexBuffer=i.createBuffer({size:cubeVertexArray.byteLength,usage:GPUBufferUsage.VERTEX,mappedAtCreation:!0}),new Float32Array(this.vertexBuffer.getMappedRange()).set(cubeVertexArray),this.vertexBuffer.unmap();const l=4*16;this.uniformBuffer=i.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),this.uniformBindGroup=i.createBindGroup({layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:this.uniformBuffer}}]})}getTransformationMatrix(i){const s=create$5();translate(s,s,this.position),scale$1(s,s,fromValues$1(10,10,10));const a=create$5();return multiply$2(a,i,s),a}update(i,s,a){if(!this.updating){this.updating=!0;const l=create$4();scale(l,this.controller.up,100),add(l,this.controller.position,l),this.raycast.cast(i,s,l,scale(create$4(),this.camera.forward,-1)).then(h=>{this.updating=!1,h!==null&&copy(this.position,h.position)})}const u=this.getTransformationMatrix(a);i.queue.writeBuffer(this.uniformBuffer,0,u.buffer,u.byteOffset,u.byteLength)}draw(i){i.setPipeline(this.pipeline),i.setBindGroup(0,this.uniformBindGroup),i.setVertexBuffer(0,this.vertexBuffer),i.draw(cubeVertexCount,1,0,0)}}class Game{constructor(i,s,a,u,l,h,f,d,p,g,m,y,v){q(this,"lastUpdate",0);q(this,"lastTimestamp",0);q(this,"tool",DensityType.Add);q(this,"shape",DensityShape.Sphere);q(this,"material",DensityMaterial.Rock);q(this,"size",4);this.voxelWorker=i,this.keyboard=s,this.mouse=a,this.physics=u,this.controller=l,this.camera=h,this.collection=f,this.raycast=d,this.network=p,this.players=g,this.density=m,this.pointer=y,this.generate=v}static async init(i){const s=new Keyboard;s.init();const a=new Mouse;a.init();const u=new Controller(s,a);u.init();const l=new Camera(u,a),h=new Map,f=await Network.init(u,h,S=>{const O=new Player(i,fromValues$1(2e6,100,100));return h[S]=O,O});await f.sendData({type:"move",position:{x:0,y:0,z:0}});const d=await Density.init(i),p=await Voxel.init(i,fromValues(u.position[0],u.position[1],u.position[2],0),d),g=await VoxelCollection.init(i,d),m=await Raycast.init(i,d),y=await new Promise(S=>{const O=new WorkerWrapper;O.onmessage=({data:E})=>{E.type==="init_complete"&&(console.log("Received Voxel engine init complete"),S(O))}}),v=2,_=31,A=new WorldGenerator(v),T=performance.now();let x,w=!1;y.onmessage=({data:S})=>{const{type:O,vertices:E,consistency:R,normals:I,indices:M,corners:k,stride:B}=S;switch(O){case"clear":g.freeAll();break;case"update":{g.set(i,`${S.ix}x${S.iy}x${S.iz}`,{x:S.x,y:S.y,z:S.z},{x:S.ix,y:S.iy,z:S.iz},B,new Float32Array(E),new Float32Array(I),new Uint16Array(M),new Uint32Array(k),R);break}}if(x.stride>2<<14){w=!1,console.log(`Generation complete in ${performance.now()-T} milliseconds with ${g.objects.size} objects`);return}const P=A.next(x),z=P[0];y.postMessage({stride:B,position:u.position,detail:{x:z.x,y:z.y,z:z.z,s:z.stride},density:d.augmentations}),x=P[1]};const b=()=>{if(x=A.init(u.position[0]/_,u.position[1]/_,u.position[2]/_),console.log(w),w)return;w=!0;const S=A.next(x),O=S[0];y.postMessage({stride:v,position:u.position,detail:{x:O.x,y:O.y,z:O.z,s:O.stride},density:d.augmentations}),x=S[1]};b();const C=new Pointer(i,u,l,m),N=new Game(y,s,a,p,u,l,g,m,f,h,d,C,b);return document.getElementById("loading").style.display="none",N}destroy(){this.voxelWorker.terminate()}async update(i,s,a){const u=a-this.lastTimestamp,l=d=>{i.queue.onSubmittedWorkDone().then(()=>{d.callback()}),i.queue.submit(d.items)};this.keyboard.keydown("1")&&(this.tool=DensityType.Add),this.keyboard.keydown("2")&&(this.tool=DensityType.Subtract),this.keyboard.keydown("3")&&(this.shape=DensityShape.Box),this.keyboard.keydown("4")&&(this.shape=DensityShape.Sphere),this.keyboard.keydown("5")&&(this.material=DensityMaterial.Rock),this.keyboard.keydown("6")&&(this.material=DensityMaterial.Wood),this.keyboard.keydown("7")&&(this.material=DensityMaterial.Fire),this.keyboard.keypress("=")&&(this.size=this.size*2),this.keyboard.keypress("-")&&(this.size=Math.max(4,this.size/2));const h=document.getElementById("tool");if(h&&(h.innerText=`${DensityType[this.tool]} - ${DensityShape[this.shape]} - ${DensityMaterial[this.material]} - ${this.size}`),a-this.lastUpdate>1e4&&(this.network.sendData({type:"position",position:{x:this.controller.position[0],y:this.controller.position[1],z:this.controller.position[2]}}),this.lastUpdate=a),this.keyboard.keypress("g")&&this.generate(),this.keyboard.keypress(" ")){const d=create$4();scale(d,this.controller.up,100),add(d,this.controller.position,d),this.raycast.cast(i,l,d,scale(create$4(),this.camera.forward,-1)).then(p=>{if(p===null){console.log("No intersection found");return}console.log(p.position,p.distance),this.density.modify(i,{x:p.position[0],y:p.position[1],z:p.position[2],size:this.size,type:this.tool,shape:this.shape,material:this.material}),this.generate()})}this.physics.velocity=this.controller.velocity,await this.physics.update(i,d=>l(d)),this.controller.position=this.physics.position,this.controller.update(u),this.camera.update(s);const f=this.camera.viewMatrix;this.pointer.update(i,l,f),this.collection.update(i,f,a);for(const d in this.players)this.players[d].update(i,f,a);this.keyboard.update(),this.mouse.update(),this.lastTimestamp=a}draw(i){this.pointer.draw(i);for(const s in this.players)this.players[s].draw(i);this.collection.draw(i)}}(async function(){const canvas=document.getElementById("canvas"),projectionMatrix=create$5(),steamworks=eval(`typeof require === "function" && require('steamworks.js')`);if(steamworks)try{const c=steamworks.init(480);console.log(c.localplayer.getName()),c.localplayer.getSteamId(),c.achievement.activate("ACH_WIN_ONE_GAME")||console.log("Sad fish"),c.auth.getSessionTicket().then(i=>{const s=i.getBytes();console.log("ticket",s.toString("hex"))})}catch{}const renderer=await Renderer.init(canvas),configureRenderer=()=>{canvas.width=window.innerWidth,canvas.height=window.innerHeight;const c=Math.abs(canvas.width/canvas.height);perspective(projectionMatrix,2*Math.PI/5,c,1,1e8),renderer.configure(canvas.width,canvas.height)};window.addEventListener("resize",configureRenderer,!1),window.addEventListener("click",()=>{canvas.requestPointerLock()});let game=await Game.init(renderer.device);configureRenderer(),performance.now();const stats=new Stats;stats.showPanel(0),document.body.appendChild(stats.dom),window.addEventListener("beforeunload",()=>{renderer.running=!1,game.destroy()});const doFrame=async c=>{renderer.running&&(stats.begin(),await game.update(renderer.device,projectionMatrix,c),renderer.render(i=>game.draw(i)),performance.now(),stats.end(),requestAnimationFrame(doFrame))};requestAnimationFrame(doFrame)})();
